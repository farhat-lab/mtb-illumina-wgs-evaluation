{"version":3,"sources":["../../../node_modules/hic-straw/dist/hic-straw.esm.js","../../../node_modules/node-fetch/browser.js"],"names":["Zlib","Huffman","Util","CRC32","DEFLATE","RESERVED","opt_params","this","files","comment","password","Zip","CompressionMethod","STORE","OperatingSystem","MSDOS","UNIX","MACINTOSH","Flags","ENCRYPT","DESCRIPTOR","UTF8","FileHeaderSignature","LocalFileHeaderSignature","CentralDirectorySignature","prototype","addFile","input","compressed","size","length","crc32","Array","Uint8Array","calc","deflateWithOption","Error","push","buffer","option","encrypted","setPassword","compress","file","output","op1","op2","op3","endOfCentralDirectorySize","offset","flags","compressionMethod","date","plainSize","filenameLength","extraFieldLength","commentLength","filename","extraField","tmp","key","i","il","j","jl","localFileSize","centralDirectorySize","createEncryptionKey","set","encode","Math","random","needVersion","Date","getMinutes","getSeconds","getHours","getMonth","getDate","getFullYear","RawDeflate","getByte","n","updateKeys","single","Uint32Array","buildHuffmanTable","lengths","table","bitLength","code","skip","reversed","rtemp","value","listSize","maxCodeLength","minCodeLength","Number","POSITIVE_INFINITY","RawInflate","blocks","bufferSize","totalpos","ip","bitsbuf","bitsbuflen","op","bfinal","bufferType","BufferType","ADAPTIVE","resize","BLOCK","MaxBackwardLength","MaxCopyLength","decompress","parseBlock","concatBufferBlock","concatBufferDynamic","Order","Uint16Array","LengthCodeTable","LengthExtraTable","DistCodeTable","DistExtraTable","FixedLiteralLengthTable","FixedDistanceTable","hdr","readBits","parseUncompressedBlock","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","octet","readCodeByTable","codeWithLength","codeLength","inputLength","codeTable","len","preCopy","olength","subarray","expandBufferBlock","expandBufferAdaptive","fixRatio","decodeHuffmanAdaptive","decodeHuffmanBlock","codeLengthsTable","litlenTable","distTable","lengthTable","prev","repeat","hlit","hdist","hclen","codeLengths","litlen","dist","currentLitlenTable","ti","codeDist","lengthCodeTable","lengthExtraTable","distCodeTable","distExtraTable","opt_param","backward","newSize","maxInflateSize","ratio","addRatio","block","pos","limit","RawInflateStream","opt_buffersize","ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE","blockLength","sp","status","Status","INITIALIZED","ip_","bitsbuflen_","bitsbuf_","BlockType","UNCOMPRESSED","FIXED","DYNAMIC","BLOCK_HEADER_START","BLOCK_HEADER_END","BLOCK_BODY_START","BLOCK_BODY_END","DECODE_BLOCK_START","DECODE_BLOCK_END","newInput","stop","readBlockHeader","currentBlockType","readUncompressedBlockHeader","decodeHuffman","concatBuffer","save_","restore_","expandBuffer","bits","call","e","Inflate","cmf","flg","rawinflate","verify","method","Adler32","InflateStream","readHeader","Gunzip","member","decompressed","getMembers","slice","decodeMember","concatMember","isize","inflated","inflen","c","ci","str","mtime","GunzipMember","id1","id2","cm","xfl","os","Gzip","FlagsMask","FEXTRA","xlen","decodeSubField","FNAME","String","fromCharCode","name","join","FCOMMENT","FHCRC","crc16","data","toString","p","getName","getData","getMtime","deflateOptions","DefaultBufferSize","rawdeflate","now","UNKNOWN","charCodeAt","byteLength","FAT","AMIGA","VMS","VM_CMS","ATARI_TOS","HPFS","Z_SYSTEM","CP_M","TOPS_20","NTFS","QDOS","ACORN_RISCOS","FTEXT","Heap","getParent","index","getChild","current","parent","swap","heap","pop","compressionType","CompressionType","lazy","freqsLitLen","freqsDist","NONE","Lz77MinLength","Lz77MaxLength","WindowSize","MaxCodeLength","HUFMAX","FixedHuffmanTable","blockArray","position","makeNocompressBlock","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","btype","nlen","stream","BitStream","writeBits","lz77","fixedHuffman","finish","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","bitlen","hclenOrder","transLengths","getLengths_","getCodesFromLengths_","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","literal","apply","Lz77Match","backwardDistance","getDistanceCode_","r","toLz77Array","codeArray","matchKey","matchList","longestMatch","prevMatch","windowSize","lz77buf","skipLength","writeMatch","match","lz77Array","shift","searchLongestMatch_","currentMatch","matchLength","l","matchMax","dl","permatch","litlenLengths","runLength","nResult","rpt","src","result","nodes","values","nSymbols","reversePackageMerge_","symbols","t","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","m","count","startCode","Unzip","eocdrOffset","numberOfThisDisk","startDisk","totalEntriesThisDisk","totalEntries","centralDirectoryOffset","fileHeaderList","filenameToIndex","FileHeader","version","compression","time","compressedSize","fileNameLength","fileCommentLength","diskNumberStart","internalFileAttributes","externalFileAttributes","relativeOffset","parse","LocalFileHeader","searchEndOfCentralDirectoryRecord","parseEndOfCentralDirectoryRecord","parseFileHeader","fileHeader","filelist","filetable","getFileData","localFileHeader","createDecryptionKey","decode","getFilenames","filenameList","stringToByteArray","split","array","update","adler","tlen","s1","s2","OptimizationParameter","bufferPosition","bitindex","DefaultBlockSize","oldbuf","number","reverse","ReverseTable","rev32_","s","crc","Table","num","Table_","Deflate","rawDeflate","prop","rawDeflateOption","cinfo","flevel","LOG2E","log","fdict","fs","fsOpen","fsRead","crossFetch","process","versions","node","require","fetch","BrowserLocalFile","blob","Promise","fullfill","reject","fileReader","FileReader","onload","onerror","console","err","undefined","readAsArrayBuffer","util","promisify","open","read","NodeLocalFile","args","path","Buffer","alloc","fd","close","error","b","arrayBuffer","byteOffset","isNode$2","RemoteFile","url","config","includes","replace","startsWith","resolveToken","token","a","resolve","ceil","headers","rangeString","oauthToken","navigator","vendor","indexOf","test","userAgent","isChrome","isAmazonV4Signed","addParameter","apiKey","redirect","mode","response","statusText","paramSeparator","ThrottledFile","rateLimiter","fulfill","limiter","f","RateLimiter","wait","isCalled","calls","fn","self","caller","setTimeout","bind","arguments","BufferedFile","bufferStart","bufferLength","start","end","bufferEnd","sliceEnd","sliceStart","l1","a1","l2","a2","concatBuffers","buffer1","buffer2","BinaryParser","dataView","littleEndian","view","VPointer","available","remLength","hasNext","retValue","getUint8","getShort","getInt16","getUShort","getUint16","getInt","getInt32","getUInt","getUint32","getLong","getString","getFixedLengthString","getFixedLengthTrimmedString","getFloat","getFloat32","getDouble","getFloat64","getVPointer","isLessThan","vp","isGreaterThan","print","MatrixZoomData","chr1","chr2","zoom","unit","binSize","region1","region2","chr","sameChr","binsize","blockBinCount","blockColumnCount","x1","x2","y1","y2","col1","floor","col2","row1","row2","blockNumbers","row","column","blockNumber","getBlockNumbersV8","binX1","binX2","binY1","binY2","translatedLowerPAD","translatedHigherPAD","translatedNearerDepth","log2","abs","sqrt","translatedFurtherDepth","nearerDepth","min","furtherDepth","max","depth","pad","block_number","getBlockNumbersV9","dis","zd","zoomIndex","sumCounts","occupiedCellCount","stdDev","percent95","nBlocks","blockIndex","StaticBlockIndex","avgCount","averageCount","filePosition","Matrix","zoomDataList","bpZoomData","fragZoomData","zdArray","chrIdx1","chrIdx2","chromosomes","DataView","c1","c2","nResolutions","zdList","parseMatrixZoomData","ContactRecord","bin1","bin2","counts","LRU","map","Map","item","get","delete","val","has","first","clear","keys","NormalizationVector","nValues","dataType","cache","adjustedStart","adjustedEnd","startPosition","sizeInBytes","parser","getKey","chrIdx","resolution","isNode$3","GoogleRateLimiter","HicFile","loadFragData","fragmentSitesCache","normVectorCache","normalizationTypes","matrixCache","blockCache","BlockCache","remote","remoteFile","initialized","readHeaderAndFooter","binaryParser","magic","init","meta","footerPosition","readFooter","bodyPostion","Object","masterIndex","reduce","currentValue","MAX_VALUE","remainingSize","genomeId","normVectorIndexPosition","normVectorIndexSize","attributes","nAttributes","chromosomeIndexMap","nChrs","toLowerCase","wholeGenomeChromosome","wholeGenomeResolution","round","bpResolutions","nBpResolutions","fragResolutions","nFragResolutions","chrAliasTable","chrName","substr","nBytes","nEntries","miSize","expectedValueVectors","normExpectedValueVectorsPosition","maxSize","entry","readMatrix","matrix","idx","parseMatrix","normalization","units","allRecords","idx1","getFileChrName","idx2","getBlocks","contactRecords","nvX1","nvX2","nvY1","nvY2","normVector1","normVector2","isNorm","getNormalizationVector","nv1","nv2","getValues","records","rec","y","nvnv","isNaN","getMatrix","getZoomData","msg","getBlockNumbers","blockNumbersToQuery","promises","readBlock","all","newBlocks","concat","getBlockIndexEntry","inflate","plain","nRecords","binX","binY","binXOffset","binYOffset","useFloatContact","useIntXPos","useIntYPos","rowCount","dy","colCount","dx","nPts","w","Block","isInteger","canonicalName","getNormalizationVectorKey","getNormVectorIndex","normVectorIndex","nv","nvi","URL","encodeURIComponent","hostname","pathname","nviResponse","text","nviArray","decodeURIComponent","range","parseInt","readNormVectorIndex","readNormExpectedValuesAndNormVectorIndex","normalizationVectorIndexRange","parseNormVectorEntry","processEntries","byteCount","sizeEstimate","nviStart","skipExpectedValues","normalizedExpectedValueVectors","parseNext","chunkSize","p0","nChrScaleFactors","resolutionArray","chrAlias","hasOwnProperty","zoomData","Straw","hicFile","getMetaData","getContactRecords","getNormalizationOptions","printIndexStats","global","window","getGlobal","module","exports","default","Headers","Request","Response"],"mappings":"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","file":"static/js/33.11cc9b2d.chunk.js","sourcesContent":["// from https://github.com/imaya/zlib.js\n\nvar Zlib = {\n  Huffman: {},\n  Util: {},\n  CRC32: {}\n};\n\n\n/**\n * Compression Method\n * @enum {number}\n */\nZlib.CompressionMethod = {\n  DEFLATE: 8,\n  RESERVED: 15\n};\n\n\n\n\n/**\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Zip = function(opt_params) {\n  opt_params = opt_params || {};\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  this.files = [];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment = opt_params['comment'];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password;\n};\n\n\n/**\n * @enum {number}\n */\nZlib.Zip.CompressionMethod = {\n  STORE: 0,\n  DEFLATE: 8\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.OperatingSystem = {\n  MSDOS: 0,\n  UNIX: 3,\n  MACINTOSH: 7\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.Flags = {\n  ENCRYPT:    0x0001,\n  DESCRIPTOR: 0x0008,\n  UTF8:       0x0800\n};\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\n\n/**\n * @param {Array.<number>|Uint8Array} input\n * @param {Object=} opt_params options.\n */\nZlib.Zip.prototype.addFile = function(input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {string} */\n  var filename =  opt_params['filename'];\n  /** @type {boolean} */\n  var compressed;\n  /** @type {number} */\n  var size = input.length;\n  /** @type {number} */\n  var crc32 = 0;\n\n  if ( input instanceof Array) {\n    input = new Uint8Array(input);\n  }\n\n  // default\n  if (typeof opt_params['compressionMethod'] !== 'number') {\n    opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;\n  }\n\n  // その場で圧縮する場合\n  if (opt_params['compress']) {\n    switch (opt_params['compressionMethod']) {\n      case Zlib.Zip.CompressionMethod.STORE:\n        break;\n      case Zlib.Zip.CompressionMethod.DEFLATE:\n        crc32 = Zlib.CRC32.calc(input);\n        input = this.deflateWithOption(input, opt_params);\n        compressed = true;\n        break;\n      default:\n        throw new Error('unknown compression method:' + opt_params['compressionMethod']);\n    }\n  }\n\n  this.files.push({\n    buffer: input,\n    option: opt_params,\n    compressed: compressed,\n    encrypted: false,\n    size: size,\n    crc32: crc32\n  });\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Zip.prototype.setPassword = function(password) {\n  this.password = password;\n};\n\nZlib.Zip.prototype.compress = function() {\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  var files = this.files;\n  /** @type {{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }} */\n  var file;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var op1;\n  /** @type {number} */\n  var op2;\n  /** @type {number} */\n  var op3;\n  /** @type {number} */\n  var localFileSize = 0;\n  /** @type {number} */\n  var centralDirectorySize = 0;\n  /** @type {number} */\n  var endOfCentralDirectorySize;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var needVersion;\n  /** @type {number} */\n  var flags;\n  /** @type {Zlib.Zip.CompressionMethod} */\n  var compressionMethod;\n  /** @type {Date} */\n  var date;\n  /** @type {number} */\n  var crc32;\n  /** @type {number} */\n  var size;\n  /** @type {number} */\n  var plainSize;\n  /** @type {number} */\n  var filenameLength;\n  /** @type {number} */\n  var extraFieldLength;\n  /** @type {number} */\n  var commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var filename;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var extraField;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var comment;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {*} */\n  var tmp;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var jl;\n\n  // ファイルの圧縮\n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength =\n      (file.option['filename']) ? file.option['filename'].length : 0;\n    extraFieldLength =\n      (file.option['extraField']) ? file.option['extraField'].length : 0;\n    commentLength =\n      (file.option['comment']) ? file.option['comment'].length : 0;\n\n    // 圧縮されていなかったら圧縮\n    if (!file.compressed) {\n      // 圧縮前に CRC32 の計算をしておく\n      file.crc32 = Zlib.CRC32.calc(file.buffer);\n\n      switch (file.option['compressionMethod']) {\n        case Zlib.Zip.CompressionMethod.STORE:\n          break;\n        case Zlib.Zip.CompressionMethod.DEFLATE:\n          file.buffer = this.deflateWithOption(file.buffer, file.option);\n          file.compressed = true;\n          break;\n        default:\n          throw new Error('unknown compression method:' + file.option['compressionMethod']);\n      }\n    }\n\n    // encryption\n    if (file.option['password'] !== void 0|| this.password !== void 0) {\n      // init encryption\n      key = this.createEncryptionKey(file.option['password'] || this.password);\n\n      // add header\n      buffer = file.buffer;\n      {\n        tmp = new Uint8Array(buffer.length + 12);\n        tmp.set(buffer, 12);\n        buffer = tmp;\n      }\n\n      for (j = 0; j < 12; ++j) {\n        buffer[j] = this.encode(\n          key,\n          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\n        );\n      }\n\n      // data encryption\n      for (jl = buffer.length; j < jl; ++j) {\n        buffer[j] = this.encode(key, buffer[j]);\n      }\n      file.buffer = buffer;\n    }\n\n    // 必要バッファサイズの計算\n    localFileSize +=\n      // local file header\n      30 + filenameLength +\n      // file data\n      file.buffer.length;\n\n    centralDirectorySize +=\n      // file header\n      46 + filenameLength + commentLength;\n  }\n\n  // end of central directory\n  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\n  output = new ( Uint8Array )(\n    localFileSize + centralDirectorySize + endOfCentralDirectorySize\n  );\n  op1 = 0;\n  op2 = localFileSize;\n  op3 = op2 + centralDirectorySize;\n\n  // ファイルの圧縮\n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength =\n      file.option['filename'] ? file.option['filename'].length :  0;\n    extraFieldLength = 0; // TODO\n    commentLength =\n      file.option['comment'] ? file.option['comment'].length : 0;\n\n    //-------------------------------------------------------------------------\n    // local file header & file header\n    //-------------------------------------------------------------------------\n\n    offset = op1;\n\n    // signature\n    // local file header\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];\n    // file header\n    output[op2++] = Zlib.Zip.FileHeaderSignature[0];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[1];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[2];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[3];\n\n    // compressor info\n    needVersion = 20;\n    output[op2++] = needVersion & 0xff;\n    output[op2++] =\n      /** @type {Zlib.Zip.OperatingSystem} */\n      (file.option['os']) ||\n      Zlib.Zip.OperatingSystem.MSDOS;\n\n    // need version\n    output[op1++] = output[op2++] =  needVersion       & 0xff;\n    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\n\n    // general purpose bit flag\n    flags = 0;\n    if (file.option['password'] || this.password) {\n      flags |= Zlib.Zip.Flags.ENCRYPT;\n    }\n    output[op1++] = output[op2++] =  flags       & 0xff;\n    output[op1++] = output[op2++] = (flags >> 8) & 0xff;\n\n    // compression method\n    compressionMethod =\n      /** @type {Zlib.Zip.CompressionMethod} */\n      (file.option['compressionMethod']);\n    output[op1++] = output[op2++] =  compressionMethod       & 0xff;\n    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\n\n    // date\n    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\n    output[op1++] = output[op2++] =\n      ((date.getMinutes() & 0x7) << 5) |\n      (date.getSeconds() / 2 | 0);\n    output[op1++] = output[op2++] =\n      (date.getHours()   << 3) |\n      (date.getMinutes() >> 3);\n    //\n    output[op1++] = output[op2++] =\n      ((date.getMonth() + 1 & 0x7) << 5) |\n      (date.getDate());\n    output[op1++] = output[op2++] =\n      ((date.getFullYear() - 1980 & 0x7f) << 1) |\n      (date.getMonth() + 1 >> 3);\n\n    // CRC-32\n    crc32 = file.crc32;\n    output[op1++] = output[op2++] =  crc32        & 0xff;\n    output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\n    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\n    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\n\n    // compressed size\n    size = file.buffer.length;\n    output[op1++] = output[op2++] =  size        & 0xff;\n    output[op1++] = output[op2++] = (size >>  8) & 0xff;\n    output[op1++] = output[op2++] = (size >> 16) & 0xff;\n    output[op1++] = output[op2++] = (size >> 24) & 0xff;\n\n    // uncompressed size\n    plainSize = file.size;\n    output[op1++] = output[op2++] =  plainSize        & 0xff;\n    output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\n    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\n    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\n\n    // filename length\n    output[op1++] = output[op2++] =  filenameLength       & 0xff;\n    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\n\n    // extra field length\n    output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\n    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\n\n    // file comment length\n    output[op2++] =  commentLength       & 0xff;\n    output[op2++] = (commentLength >> 8) & 0xff;\n\n    // disk number start\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // internal file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // external file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // relative offset of local header\n    output[op2++] =  offset        & 0xff;\n    output[op2++] = (offset >>  8) & 0xff;\n    output[op2++] = (offset >> 16) & 0xff;\n    output[op2++] = (offset >> 24) & 0xff;\n\n    // filename\n    filename = file.option['filename'];\n    if (filename) {\n      {\n        output.set(filename, op1);\n        output.set(filename, op2);\n        op1 += filenameLength;\n        op2 += filenameLength;\n      }\n    }\n\n    // extra field\n    extraField = file.option['extraField'];\n    if (extraField) {\n      {\n        output.set(extraField, op1);\n        output.set(extraField, op2);\n        op1 += extraFieldLength;\n        op2 += extraFieldLength;\n      }\n    }\n\n    // comment\n    comment = file.option['comment'];\n    if (comment) {\n      {\n        output.set(comment, op2);\n        op2 += commentLength;\n      }\n    }\n\n    //-------------------------------------------------------------------------\n    // file data\n    //-------------------------------------------------------------------------\n\n    {\n      output.set(file.buffer, op1);\n      op1 += file.buffer.length;\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // end of central directory\n  //-------------------------------------------------------------------------\n\n  // signature\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];\n\n  // number of this disk\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // number of the disk with the start of the central directory\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // total number of entries in the central directory on this disk\n  output[op3++] =  il       & 0xff;\n  output[op3++] = (il >> 8) & 0xff;\n\n  // total number of entries in the central directory\n  output[op3++] =  il       & 0xff;\n  output[op3++] = (il >> 8) & 0xff;\n\n  // size of the central directory\n  output[op3++] =  centralDirectorySize        & 0xff;\n  output[op3++] = (centralDirectorySize >>  8) & 0xff;\n  output[op3++] = (centralDirectorySize >> 16) & 0xff;\n  output[op3++] = (centralDirectorySize >> 24) & 0xff;\n\n  // offset of start of central directory with respect to the starting disk number\n  output[op3++] =  localFileSize        & 0xff;\n  output[op3++] = (localFileSize >>  8) & 0xff;\n  output[op3++] = (localFileSize >> 16) & 0xff;\n  output[op3++] = (localFileSize >> 24) & 0xff;\n\n  // .ZIP file comment length\n  commentLength = this.comment ? this.comment.length : 0;\n  output[op3++] =  commentLength       & 0xff;\n  output[op3++] = (commentLength >> 8) & 0xff;\n\n  // .ZIP file comment\n  if (this.comment) {\n    {\n      output.set(this.comment, op3);\n      op3 += commentLength;\n    }\n  }\n\n  return output;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input\n * @param {Object=} opt_params options.\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Zip.prototype.deflateWithOption = function(input, opt_params) {\n  /** @type {Zlib.RawDeflate} */\n  var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);\n\n  return deflator.compress();\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @return {number}\n */\nZlib.Zip.prototype.getByte = function(key) {\n  /** @type {number} */\n  var tmp = ((key[2] & 0xffff) | 2);\n\n  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Zip.prototype.encode = function(key, n) {\n  /** @type {number} */\n  var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n\n  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n  return tmp ^ n;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @param {number} n\n */\nZlib.Zip.prototype.updateKeys = function(key, n) {\n  key[0] = Zlib.CRC32.single(key[0], n);\n  key[1] =\n    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\n  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n * @return {!(Array.<number>|Uint32Array|Object)}\n */\nZlib.Zip.prototype.createEncryptionKey = function(password) {\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var key = [305419896, 591751049, 878082192];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  {\n    key = new Uint32Array(key);\n  }\n\n  for (i = 0, il = password.length; i < il; ++i) {\n    this.updateKeys(key, password[i] & 0xff);\n  }\n\n  return key;\n};\n\n\n\n/**\n * build huffman table from length list.\n * @param {!(Array.<number>|Uint8Array)} lengths length list.\n * @return {!Array} huffman table.\n */\nZlib.Huffman.buildHuffmanTable = function(lengths) {\n  /** @type {number} length list size. */\n  var listSize = lengths.length;\n  /** @type {number} max code length for table size. */\n  var maxCodeLength = 0;\n  /** @type {number} min code length for table size. */\n  var minCodeLength = Number.POSITIVE_INFINITY;\n  /** @type {number} table size. */\n  var size;\n  /** @type {!(Array|Uint8Array)} huffman code table. */\n  var table;\n  /** @type {number} bit length. */\n  var bitLength;\n  /** @type {number} huffman code. */\n  var code;\n  /**\n   * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.\n   * @type {number} skip length for table filling.\n   */\n  var skip;\n  /** @type {number} reversed code. */\n  var reversed;\n  /** @type {number} reverse temp. */\n  var rtemp;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} table value. */\n  var value;\n\n  // Math.max は遅いので最長の値は for-loop で取得する\n  for (i = 0, il = listSize; i < il; ++i) {\n    if (lengths[i] > maxCodeLength) {\n      maxCodeLength = lengths[i];\n    }\n    if (lengths[i] < minCodeLength) {\n      minCodeLength = lengths[i];\n    }\n  }\n\n  size = 1 << maxCodeLength;\n  table = new ( Uint32Array )(size);\n\n  // ビット長の短い順からハフマン符号を割り当てる\n  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\n    for (i = 0; i < listSize; ++i) {\n      if (lengths[i] === bitLength) {\n        // ビットオーダーが逆になるためビット長分並びを反転する\n        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\n          reversed = (reversed << 1) | (rtemp & 1);\n          rtemp >>= 1;\n        }\n\n        // 最大ビット長をもとにテーブルを作るため、\n        // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる\n        // そのどちらでも良い場所は同じ値で埋めることで\n        // 本来のビット長以上のビット数取得しても問題が起こらないようにする\n        value = (bitLength << 16) | i;\n        for (j = reversed; j < size; j += skip) {\n          table[j] = value;\n        }\n\n        ++code;\n      }\n    }\n\n    // 次のビット長へ\n    ++bitLength;\n    code <<= 1;\n    skip <<= 1;\n  }\n\n  return [table, maxCodeLength, minCodeLength];\n};\n\n\n\n\n//-----------------------------------------------------------------------------\n\n/** @define {number} buffer block size. */\nvar ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\n\n//-----------------------------------------------------------------------------\n\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {Object} opt_params option parameter.\n *\n * opt_params は以下のプロパティを指定する事ができます。\n *   - index: input buffer の deflate コンテナの開始位置.\n *   - blockSize: バッファのブロックサイズ.\n *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.\n *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.\n */\nZlib.RawInflate = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */\n  this.buffer;\n  /** @type {!Array.<(Array.<number>|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input =  new Uint8Array(input) ;\n  /** @type {!(Uint8Array|Array.<number>)} output buffer. */\n  this.output;\n  /** @type {!number} output buffer pointer. */\n  this.op;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {Zlib.RawInflate.BufferType} buffer management. */\n  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['bufferSize']) {\n      this.bufferSize = opt_params['bufferSize'];\n    }\n    if (opt_params['bufferType']) {\n      this.bufferType = opt_params['bufferType'];\n    }\n    if (opt_params['resize']) {\n      this.resize = opt_params['resize'];\n    }\n  }\n\n  // initialize\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.op = Zlib.RawInflate.MaxBackwardLength;\n      this.output =\n        new ( Uint8Array )(\n          Zlib.RawInflate.MaxBackwardLength +\n          this.bufferSize +\n          Zlib.RawInflate.MaxCopyLength\n        );\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.op = 0;\n      this.output = new ( Uint8Array )(this.bufferSize);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflate.BufferType = {\n  BLOCK: 0,\n  ADAPTIVE: 1\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array.<number>)} inflated buffer.\n */\nZlib.RawInflate.prototype.decompress = function() {\n  while (!this.bfinal) {\n    this.parseBlock();\n  }\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      return this.concatBufferBlock();\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      return this.concatBufferDynamic();\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflate.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflate.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.Order = (function(table) {\n  return  new Uint16Array(table) ;\n})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.LengthCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n  0x00e3, 0x0102, 0x0102, 0x0102\n]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.LengthExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0, 0, 0\n]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.DistCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n  0x3001, 0x4001, 0x6001\n]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.DistExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13\n]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedLiteralLengthTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] =\n      (i <= 143) ? 8 :\n      (i <= 255) ? 9 :\n      (i <= 279) ? 7 :\n      8;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedDistanceTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflate.prototype.parseBlock = function() {\n  /** @type {number} header */\n  var hdr = this.readBits(3);\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    // uncompressed\n    case 0:\n      this.parseUncompressedBlock();\n      break;\n    // fixed huffman\n    case 1:\n      this.parseFixedHuffmanBlock();\n      break;\n    // dynamic huffman\n    case 2:\n      this.parseDynamicHuffmanBlock();\n      break;\n    // reserved or other\n    default:\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflate.prototype.readBits = function(length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // input byte\n  if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {\n    throw new Error('input buffer is broken');\n  }\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflate.prototype.readCodeByTable = function(table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {!(Array.<number>|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (ip >= inputLength) {\n      break;\n    }\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflate.prototype.parseUncompressedBlock = function() {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n  /** @type {number} output buffer length */\n  var olength = output.length;\n  /** @type {number} copy counter */\n  var preCopy;\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  // len\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: LEN');\n  }\n  len = input[ip++] | (input[ip++] << 8);\n\n  // nlen\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: NLEN');\n  }\n  nlen = input[ip++] | (input[ip++] << 8);\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // check size\n  if (ip + len > input.length) { throw new Error('input buffer is broken'); }\n\n  // expand buffer\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      // pre copy\n      while (op + len > output.length) {\n        preCopy = olength - op;\n        len -= preCopy;\n        {\n          output.set(input.subarray(ip, ip + preCopy), op);\n          op += preCopy;\n          ip += preCopy;\n        }\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      while (op + len > output.length) {\n        output = this.expandBufferAdaptive({fixRatio: 2});\n      }\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n\n  // copy\n  {\n    output.set(input.subarray(ip, ip + len), op);\n    op += len;\n    ip += len;\n  }\n\n  this.ip = ip;\n  this.op = op;\n  this.output = output;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(\n        Zlib.RawInflate.FixedLiteralLengthTable,\n        Zlib.RawInflate.FixedDistanceTable\n      );\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(\n        Zlib.RawInflate.FixedLiteralLengthTable,\n        Zlib.RawInflate.FixedDistanceTable\n      );\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {\n  /** @type {number} number of literal and length codes. */\n  var hlit = this.readBits(5) + 257;\n  /** @type {number} number of distance codes. */\n  var hdist = this.readBits(5) + 1;\n  /** @type {number} number of code lengths. */\n  var hclen = this.readBits(4) + 4;\n  /** @type {!(Uint8Array|Array.<number>)} code lengths. */\n  var codeLengths =\n    new ( Uint8Array )(Zlib.RawInflate.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\n  var litlenTable;\n  /** @type {!(Uint8Array|Array.<number>)} distance code table. */\n  var distTable;\n  /** @type {!(Uint8Array|Array.<number>)} code length table. */\n  var lengthTable;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var prev;\n  /** @type {number} */\n  var repeat;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n\n  // decode code lengths\n  for (i = 0; i < hclen; ++i) {\n    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);\n  }\n\n  // decode length table\n  codeLengthsTable = buildHuffmanTable(codeLengths);\n  lengthTable = new ( Uint8Array )(hlit + hdist);\n  for (i = 0, il = hlit + hdist; i < il;) {\n    code = this.readCodeByTable(codeLengthsTable);\n    switch (code) {\n      case 16:\n        repeat = 3 + this.readBits(2);\n        while (repeat--) { lengthTable[i++] = prev; }\n        break;\n      case 17:\n        repeat = 3 + this.readBits(3);\n        while (repeat--) { lengthTable[i++] = 0; }\n        prev = 0;\n        break;\n      case 18:\n        repeat = 11 + this.readBits(7);\n        while (repeat--) { lengthTable[i++] = 0; }\n        prev = 0;\n        break;\n      default:\n        lengthTable[i++] = code;\n        prev = code;\n        break;\n    }\n  }\n\n  litlenTable =  buildHuffmanTable(lengthTable.subarray(0, hlit))\n    ;\n  distTable =  buildHuffmanTable(lengthTable.subarray(hlit))\n    ;\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(litlenTable, distTable);\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(litlenTable, distTable);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * decode huffman code\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanBlock = function(litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length - Zlib.RawInflate.MaxCopyLength;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op >= olength) {\n      this.op = op;\n      output = this.expandBufferBlock();\n      op = this.op;\n    }\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * decode huffman code (adaptive)\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        output = this.expandBufferAdaptive();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op + codeLength > olength) {\n      output = this.expandBufferAdaptive();\n      olength = output.length;\n    }\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * expand output buffer.\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.expandBufferBlock = function(opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer =\n    new ( Uint8Array )(\n        this.op - Zlib.RawInflate.MaxBackwardLength\n    );\n  /** @type {number} backward base point */\n  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;\n\n  var output = this.output;\n\n  // copy to output buffer\n  {\n    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));\n  }\n\n  this.blocks.push(buffer);\n  this.totalpos += buffer.length;\n\n  // copy to backward buffer\n  {\n    output.set(\n      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)\n    );\n  }\n\n  this.op = Zlib.RawInflate.MaxBackwardLength;\n\n  return output;\n};\n\n/**\n * expand output buffer. (adaptive)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = (this.input.length / this.ip + 1) | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode =\n      (input.length - this.ip) / this.currentLitlenTable[2];\n    maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n    newSize = maxInflateSize < output.length ?\n      output.length + maxInflateSize :\n      output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferBlock = function() {\n  /** @type {number} buffer pointer. */\n  var pos = 0;\n  /** @type {number} buffer pointer. */\n  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var output = this.output;\n  /** @type {!Array} blocks array. */\n  var blocks = this.blocks;\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var block;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  var buffer = new ( Uint8Array )(limit);\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} loop limiter. */\n  var jl;\n\n  // single buffer\n  if (blocks.length === 0) {\n    return       this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) ;\n  }\n\n  // copy to buffer\n  for (i = 0, il = blocks.length; i < il; ++i) {\n    block = blocks[i];\n    for (j = 0, jl = block.length; j < jl; ++j) {\n      buffer[pos++] = block[j];\n    }\n  }\n\n  // current buffer\n  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\n    buffer[pos++] = output[i];\n  }\n\n  this.blocks = [];\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferDynamic = function() {\n  /** @type {Array.<number>|Uint8Array} output buffer. */\n  var buffer;\n  var op = this.op;\n\n  {\n    if (this.resize) {\n      buffer = new Uint8Array(op);\n      buffer.set(this.output.subarray(0, op));\n    } else {\n      buffer = this.output.subarray(0, op);\n    }\n  }\n\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\n\n\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {number} ip input buffer pointer.\n * @param {number=} opt_buffersize buffer block size.\n * @constructor\n */\nZlib.RawInflateStream = function(input, ip, opt_buffersize) {\n  /** @type {!Array.<(Array|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize =\n    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = ip === void 0 ? 0 : ip;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  this.input =  new Uint8Array(input) ;\n  /** @type {!(Uint8Array|Array)} output buffer. */\n  this.output = new ( Uint8Array )(this.bufferSize);\n  /** @type {!number} output buffer pointer. */\n  this.op = 0;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {number} uncompressed block length. */\n  this.blockLength;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n  /** @type {Array} */\n  this.litlenTable;\n  /** @type {Array} */\n  this.distTable;\n  /** @type {number} */\n  this.sp = 0; // stream pointer\n  /** @type {Zlib.RawInflateStream.Status} */\n  this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n\n  //\n  // backup\n  //\n  /** @type {!number} */\n  this.ip_;\n  /** @type {!number} */\n  this.bitsbuflen_;\n  /** @type {!number} */\n  this.bitsbuf_;\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.BlockType = {\n  UNCOMPRESSED: 0,\n  FIXED: 1,\n  DYNAMIC: 2\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.Status = {\n  INITIALIZED: 0,\n  BLOCK_HEADER_START: 1,\n  BLOCK_HEADER_END: 2,\n  BLOCK_BODY_START: 3,\n  BLOCK_BODY_END: 4,\n  DECODE_BLOCK_START: 5,\n  DECODE_BLOCK_END: 6\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.RawInflateStream.prototype.decompress = function(newInput, ip) {\n  /** @type {boolean} */\n  var stop = false;\n\n  if (newInput !== void 0) {\n    this.input = newInput;\n  }\n\n  if (ip !== void 0) {\n    this.ip = ip;\n  }\n\n  // decompress\n  while (!stop) {\n    switch (this.status) {\n      // block header\n      case Zlib.RawInflateStream.Status.INITIALIZED:\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:\n        if (this.readBlockHeader() < 0) {\n          stop = true;\n        }\n        break;\n      // block body\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:\n        switch(this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.readUncompressedBlockHeader() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED:\n            if (this.parseFixedHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.parseDynamicHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      // decode data\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:\n        switch(this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.parseUncompressedBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.decodeHuffman() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:\n        if (this.bfinal) {\n          stop = true;\n        } else {\n          this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n        }\n        break;\n    }\n  }\n\n  return this.concatBuffer();\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflateStream.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflateStream.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.Order = (function(table) {\n  return  new Uint16Array(table) ;\n})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.LengthCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n  0x00e3, 0x0102, 0x0102, 0x0102\n]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.LengthExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0, 0, 0\n]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.DistCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n  0x3001, 0x4001, 0x6001\n]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.DistExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13\n]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedLiteralLengthTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] =\n      (i <= 143) ? 8 :\n      (i <= 255) ? 9 :\n      (i <= 279) ? 7 :\n      8;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedDistanceTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflateStream.prototype.readBlockHeader = function() {\n  /** @type {number} header */\n  var hdr;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;\n\n  this.save_();\n  if ((hdr = this.readBits(3)) < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    case 0: // uncompressed\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;\n      break;\n    case 1: // fixed huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;\n      break;\n    case 2: // dynamic huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;\n      break;\n    default: // reserved or other\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflateStream.prototype.readBits = function(length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    // input byte\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n\n    // concat octet\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {Array} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflateStream.prototype.readCodeByTable = function(table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {!(Array|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} input byte */\n  var octet;\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * read uncompressed block header\n */\nZlib.RawInflateStream.prototype.readUncompressedBlockHeader = function() {\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  if (ip + 4 >= input.length) {\n    return -1;\n  }\n\n  len = input[ip++] | (input[ip++] << 8);\n  nlen = input[ip++] | (input[ip++] << 8);\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  this.ip = ip;\n  this.blockLength = len;\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflateStream.prototype.parseUncompressedBlock = function() {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n  var len = this.blockLength;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  // copy\n  // XXX: とりあえず素直にコピー\n  while (len--) {\n    if (op === output.length) {\n      output = this.expandBuffer({fixRatio: 2});\n    }\n\n    // not enough input buffer\n    if (ip >= input.length) {\n      this.ip = ip;\n      this.op = op;\n      this.blockLength = len + 1; // コピーしてないので戻す\n      return -1;\n    }\n\n    output[op++] = input[ip++];\n  }\n\n  if (len < 0) {\n    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n  }\n\n  this.ip = ip;\n  this.op = op;\n\n  return 0;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function() {\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;\n  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * オブジェクトのコンテキストを別のプロパティに退避する.\n * @private\n */\nZlib.RawInflateStream.prototype.save_ = function() {\n  this.ip_ = this.ip;\n  this.bitsbuflen_ = this.bitsbuflen;\n  this.bitsbuf_ = this.bitsbuf;\n};\n\n/**\n * 別のプロパティに退避したコンテキストを復元する.\n * @private\n */\nZlib.RawInflateStream.prototype.restore_ = function() {\n  this.ip = this.ip_;\n  this.bitsbuflen = this.bitsbuflen_;\n  this.bitsbuf = this.bitsbuf_;\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {\n  /** @type {number} number of literal and length codes. */\n  var hlit;\n  /** @type {number} number of distance codes. */\n  var hdist;\n  /** @type {number} number of code lengths. */\n  var hclen;\n  /** @type {!(Uint8Array|Array)} code lengths. */\n  var codeLengths =\n    new ( Uint8Array )(Zlib.RawInflateStream.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.save_();\n  hlit = this.readBits(5) + 257;\n  hdist = this.readBits(5) + 1;\n  hclen = this.readBits(4) + 4;\n  if (hlit < 0 || hdist < 0 || hclen < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  try {\n    parseDynamicHuffmanBlockImpl.call(this);\n  } catch(e) {\n    this.restore_();\n    return -1;\n  }\n\n  function parseDynamicHuffmanBlockImpl() {\n    /** @type {number} */\n    var bits;\n    var code;\n    var prev = 0;\n    var repeat;\n    /** @type {!(Uint8Array|Array.<number>)} code length table. */\n    var lengthTable;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limit. */\n    var il;\n\n    // decode code lengths\n    for (i = 0; i < hclen; ++i) {\n      if ((bits = this.readBits(3)) < 0) {\n        throw new Error('not enough input');\n      }\n      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;\n    }\n\n    // decode length table\n    codeLengthsTable = buildHuffmanTable(codeLengths);\n    lengthTable = new ( Uint8Array )(hlit + hdist);\n    for (i = 0, il = hlit + hdist; i < il;) {\n      code = this.readCodeByTable(codeLengthsTable);\n      if (code < 0) {\n        throw new Error('not enough input');\n      }\n      switch (code) {\n        case 16:\n          if ((bits = this.readBits(2)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) { lengthTable[i++] = prev; }\n          break;\n        case 17:\n          if ((bits = this.readBits(3)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        case 18:\n          if ((bits = this.readBits(7)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 11 + bits;\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        default:\n          lengthTable[i++] = code;\n          prev = code;\n          break;\n      }\n    }\n\n    this.litlenTable =  buildHuffmanTable(lengthTable.subarray(0, hlit))\n      ;\n    this.distTable =  buildHuffmanTable(lengthTable.subarray(hlit))\n      ;\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * decode huffman code (dynamic)\n * @return {(number|undefined)} -1 is error.\n */\nZlib.RawInflateStream.prototype.decodeHuffman = function() {\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var litlen = this.litlenTable;\n  var dist = this.distTable;\n\n  var olength = output.length;\n  var bits;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  while (true) {\n    this.save_();\n\n    code = this.readCodeByTable(litlen);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n\n    if (code === 256) {\n      break;\n    }\n\n    // literal\n    if (code < 256) {\n      if (op === olength) {\n        output = this.expandBuffer();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];\n    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeLength += bits;\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n    codeDist = Zlib.RawInflateStream.DistCodeTable[code];\n    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeDist += bits;\n    }\n\n    // lz77 decode\n    if (op + codeLength >= olength) {\n      output = this.expandBuffer();\n      olength = output.length;\n    }\n\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n\n    // break\n    if (this.ip === this.input.length) {\n      this.op = op;\n      return -1;\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n\n  this.op = op;\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n};\n\n/**\n * expand output buffer. (dynamic)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflateStream.prototype.expandBuffer = function(opt_param) {\n  /** @type {!(Array|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = (this.input.length / this.ip + 1) | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode =\n      (input.length - this.ip) / this.litlenTable[2];\n    maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n    newSize = maxInflateSize < output.length ?\n      output.length + maxInflateSize :\n      output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array|Uint8Array)} output buffer.\n */\nZlib.RawInflateStream.prototype.concatBuffer = function() {\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var buffer;\n  /** @type {number} */\n  var op = this.op;\n  /** @type {Uint8Array} */\n  var tmp;\n\n  if (this.resize) {\n    {\n      buffer = new Uint8Array(this.output.subarray(this.sp, op));\n    }\n  } else {\n    buffer =\n       this.output.subarray(this.sp, op) ;\n  }\n\n  this.sp = op;\n\n  // compaction\n  if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {\n    this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;\n    {\n      tmp = /** @type {Uint8Array} */(this.output);\n      this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);\n      this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));\n    }\n  }\n\n  return buffer;\n};\n\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @param {Object=} opt_params option parameters.\n *\n * opt_params は以下のプロパティを指定する事ができます。\n *   - index: input buffer の deflate コンテナの開始位置.\n *   - blockSize: バッファのブロックサイズ.\n *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.\n *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.\n *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.\n */\nZlib.Inflate = function(input, opt_params) {\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflate} */\n  this.rawinflate;\n  /** @type {(boolean|undefined)} verify flag. */\n  this.verify;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['verify']) {\n      this.verify = opt_params['verify'];\n    }\n  }\n\n  // Compression Method and Flags\n  cmf = input[this.ip++];\n  flg = input[this.ip++];\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  // RawInflate\n  this.rawinflate = new Zlib.RawInflate(input, {\n    'index': this.ip,\n    'bufferSize': opt_params['bufferSize'],\n    'bufferType': opt_params['bufferType'],\n    'resize': opt_params['resize']\n  });\n};\n\n/**\n * @enum {number}\n */\nZlib.Inflate.BufferType = Zlib.RawInflate.BufferType;\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.Inflate.prototype.decompress = function() {\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  var input = this.input;\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n  /** @type {number} adler-32 checksum */\n  var adler32;\n\n  buffer = this.rawinflate.decompress();\n  this.ip = this.rawinflate.ip;\n\n  // verify adler-32\n  if (this.verify) {\n    adler32 = (\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\n      input[this.ip++] << 8 | input[this.ip++]\n    ) >>> 0;\n\n    if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n\n  return buffer;\n};\n\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n\n/**\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @constructor\n */\nZlib.InflateStream = function(input) {\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input === void 0 ? new ( Uint8Array )() : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflateStream} */\n  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);\n  /** @type {Zlib.CompressionMethod} */\n  this.method;\n  /** @type {!(Array|Uint8Array)} */\n  this.output = this.rawinflate.output;\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.InflateStream.prototype.decompress = function(input) {\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n\n  // 新しい入力を入力バッファに結合する\n  // XXX Array, Uint8Array のチェックを行うか確認する\n  if (input !== void 0) {\n    {\n      var tmp = new Uint8Array(this.input.length + input.length);\n      tmp.set(this.input, 0);\n      tmp.set(input, this.input.length);\n      this.input = tmp;\n    }\n  }\n\n  if (this.method === void 0) {\n    if(this.readHeader() < 0) {\n      return new ( Uint8Array )();\n    }\n  }\n\n  buffer = this.rawinflate.decompress(this.input, this.ip);\n  if (this.rawinflate.ip !== 0) {\n    this.input = \n      this.input.subarray(this.rawinflate.ip) ;\n    this.ip = 0;\n  }\n\n  // verify adler-32\n  /*\n  if (this.verify) {\n    adler32 =\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\n      input[this.ip++] << 8 | input[this.ip++];\n\n    if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n  */\n\n  return buffer;\n};\n\nZlib.InflateStream.prototype.readHeader = function() {\n  var ip = this.ip;\n  var input = this.input;\n\n  // Compression Method and Flags\n  var cmf = input[ip++];\n  var flg = input[ip++];\n\n  if (cmf === void 0 || flg === void 0) {\n    return -1;\n  }\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  this.ip = ip;\n};\n\n\n/**\n * @fileoverview GZIP (RFC1952) 展開コンテナ実装.\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gunzip = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {Array.<Zlib.GunzipMember>} */\n  this.member = [];\n  /** @type {boolean} */\n  this.decompressed = false;\n};\n\n/**\n * @return {Array.<Zlib.GunzipMember>}\n */\nZlib.Gunzip.prototype.getMembers = function() {\n  if (!this.decompressed) {\n    this.decompress();\n  }\n\n  return this.member.slice();\n};\n\n/**\n * inflate gzip data.\n * @return {!(Array.<number>|Uint8Array)} inflated buffer.\n */\nZlib.Gunzip.prototype.decompress = function() {\n  /** @type {number} input length. */\n  var il = this.input.length;\n\n  while (this.ip < il) {\n    this.decodeMember();\n  }\n\n  this.decompressed = true;\n\n  return this.concatMember();\n};\n\n/**\n * decode gzip member.\n */\nZlib.Gunzip.prototype.decodeMember = function() {\n  /** @type {Zlib.GunzipMember} */\n  var member = new Zlib.GunzipMember();\n  /** @type {number} */\n  var isize;\n  /** @type {Zlib.RawInflate} RawInflate implementation. */\n  var rawinflate;\n  /** @type {!(Array.<number>|Uint8Array)} inflated data. */\n  var inflated;\n  /** @type {number} inflate size */\n  var inflen;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} character index in string. */\n  var ci;\n  /** @type {Array.<string>} character array. */\n  var str;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} */\n  var crc32;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  member.id1 = input[ip++];\n  member.id2 = input[ip++];\n\n  // check signature\n  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {\n    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);\n  }\n\n  // check compression method\n  member.cm = input[ip++];\n  switch (member.cm) {\n    case 8: /* XXX: use Zlib const */\n      break;\n    default:\n      throw new Error('unknown compression method: ' + member.cm);\n  }\n\n  // flags\n  member.flg = input[ip++];\n\n  // modification time\n  mtime = (input[ip++])       |\n          (input[ip++] << 8)  |\n          (input[ip++] << 16) |\n          (input[ip++] << 24);\n  member.mtime = new Date(mtime * 1000);\n\n  // extra flags\n  member.xfl = input[ip++];\n\n  // operating system\n  member.os = input[ip++];\n\n  // extra\n  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {\n    member.xlen = input[ip++] | (input[ip++] << 8);\n    ip = this.decodeSubField(ip, member.xlen);\n  }\n\n  // fname\n  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {\n    for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.name = str.join('');\n  }\n\n  // fcomment\n  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {\n    for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.comment = str.join('');\n  }\n\n  // fhcrc\n  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {\n    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;\n    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {\n      throw new Error('invalid header crc16');\n    }\n  }\n\n  // isize を事前に取得すると展開後のサイズが分かるため、\n  // inflate処理のバッファサイズが事前に分かり、高速になる\n  isize = (input[input.length - 4])       | (input[input.length - 3] << 8) |\n          (input[input.length - 2] << 16) | (input[input.length - 1] << 24);\n\n  // isize の妥当性チェック\n  // ハフマン符号では最小 2-bit のため、最大で 1/4 になる\n  // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、\n  // 1/128 になるとする\n  // ここから入力バッファの残りが isize の 512 倍以上だったら\n  // サイズ指定のバッファ確保は行わない事とする\n  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {\n    inflen = isize;\n  }\n\n  // compressed block\n  rawinflate = new Zlib.RawInflate(input, {'index': ip, 'bufferSize': inflen});\n  member.data = inflated = rawinflate.decompress();\n  ip = rawinflate.ip;\n\n  // crc32\n  member.crc32 = crc32 =\n    ((input[ip++])       | (input[ip++] << 8) |\n     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n  if (Zlib.CRC32.calc(inflated) !== crc32) {\n    throw new Error('invalid CRC-32 checksum: 0x' +\n        Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));\n  }\n\n  // input size\n  member.isize = isize =\n    ((input[ip++])       | (input[ip++] << 8) |\n     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n  if ((inflated.length & 0xffffffff) !== isize) {\n    throw new Error('invalid input size: ' +\n        (inflated.length & 0xffffffff) + ' / ' + isize);\n  }\n\n  this.member.push(member);\n  this.ip = ip;\n};\n\n/**\n * サブフィールドのデコード\n * XXX: 現在は何もせずスキップする\n */\nZlib.Gunzip.prototype.decodeSubField = function(ip, length) {\n  return ip + length;\n};\n\n/**\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Gunzip.prototype.concatMember = function() {\n  /** @type {Array.<Zlib.GunzipMember>} */\n  var member = this.member;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var p = 0;\n  /** @type {number} */\n  var size = 0;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n\n  for (i = 0, il = member.length; i < il; ++i) {\n    size += member[i].data.length;\n  }\n\n  {\n    buffer = new Uint8Array(size);\n    for (i = 0; i < il; ++i) {\n      buffer.set(member[i].data, p);\n      p += member[i].data.length;\n    }\n  }\n\n  return buffer;\n};\n\n\n\n/**\n * @constructor\n */\nZlib.GunzipMember = function() {\n  /** @type {number} signature first byte. */\n  this.id1;\n  /** @type {number} signature second byte. */\n  this.id2;\n  /** @type {number} compression method. */\n  this.cm;\n  /** @type {number} flags. */\n  this.flg;\n  /** @type {Date} modification time. */\n  this.mtime;\n  /** @type {number} extra flags. */\n  this.xfl;\n  /** @type {number} operating system number. */\n  this.os;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  this.crc16;\n  /** @type {number} extra length. */\n  this.xlen;\n  /** @type {number} CRC-32 value for verification. */\n  this.crc32;\n  /** @type {number} input size modulo 32 value. */\n  this.isize;\n  /** @type {string} filename. */\n  this.name;\n  /** @type {string} comment. */\n  this.comment;\n  /** @type {!(Uint8Array|Array.<number>)} */\n  this.data;\n};\n\nZlib.GunzipMember.prototype.getName = function() {\n  return this.name;\n};\n\nZlib.GunzipMember.prototype.getData = function() {\n  return this.data;\n};\n\nZlib.GunzipMember.prototype.getMtime = function() {\n  return this.mtime;\n};\n\n/**\n * @fileoverview GZIP (RFC1952) 実装.\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gzip = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  this.output;\n  /** @type {number} output buffer. */\n  this.op = 0;\n  /** @type {!Object} flags option flags. */\n  this.flags = {};\n  /** @type {!string} filename. */\n  this.filename;\n  /** @type {!string} comment. */\n  this.comment;\n  /** @type {!Object} deflate options. */\n  this.deflateOptions;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['flags']) {\n      this.flags = opt_params['flags'];\n    }\n    if (typeof opt_params['filename'] === 'string') {\n      this.filename = opt_params['filename'];\n    }\n    if (typeof opt_params['comment'] === 'string') {\n      this.comment = opt_params['comment'];\n    }\n    if (opt_params['deflateOptions']) {\n      this.deflateOptions = opt_params['deflateOptions'];\n    }\n  }\n\n  if (!this.deflateOptions) {\n    this.deflateOptions = {};\n  }\n};\n\n/**\n * @type {number}\n * @const\n */\nZlib.Gzip.DefaultBufferSize = 0x8000;\n\n/**\n * encode gzip members.\n * @return {!(Array|Uint8Array)} gzip binary array.\n */\nZlib.Gzip.prototype.compress = function() {\n  /** @type {number} flags. */\n  var flg;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  var crc16;\n  /** @type {number} CRC-32 value for verification. */\n  var crc32;\n  /** @type {!Zlib.RawDeflate} raw deflate object. */\n  var rawdeflate;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output =\n    new ( Uint8Array )(Zlib.Gzip.DefaultBufferSize);\n  /** @type {number} output buffer pointer. */\n  var op = 0;\n\n  var input = this.input;\n  var ip = this.ip;\n  var filename = this.filename;\n  var comment = this.comment;\n\n  // check signature\n  output[op++] = 0x1f;\n  output[op++] = 0x8b;\n\n  // check compression method\n  output[op++] = 8; /* XXX: use Zlib const */\n\n  // flags\n  flg = 0;\n  if (this.flags['fname'])    flg |= Zlib.Gzip.FlagsMask.FNAME;\n  if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;\n  if (this.flags['fhcrc'])    flg |= Zlib.Gzip.FlagsMask.FHCRC;\n  // XXX: FTEXT\n  // XXX: FEXTRA\n  output[op++] = flg;\n\n  // modification time\n  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;\n  output[op++] = mtime        & 0xff;\n  output[op++] = mtime >>>  8 & 0xff;\n  output[op++] = mtime >>> 16 & 0xff;\n  output[op++] = mtime >>> 24 & 0xff;\n\n  // extra flags\n  output[op++] = 0;\n\n  // operating system\n  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;\n\n  // extra\n  /* NOP */\n\n  // fname\n  if (this.flags['fname'] !== void 0) {\n    for (i = 0, il = filename.length; i < il; ++i) {\n      c = filename.charCodeAt(i);\n      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fcomment\n  if (this.flags['comment']) {\n    for (i = 0, il = comment.length; i < il; ++i) {\n      c = comment.charCodeAt(i);\n      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fhcrc\n  if (this.flags['fhcrc']) {\n    crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;\n    output[op++] = (crc16      ) & 0xff;\n    output[op++] = (crc16 >>> 8) & 0xff;\n  }\n\n  // add compress option\n  this.deflateOptions['outputBuffer'] = output;\n  this.deflateOptions['outputIndex'] = op;\n\n  // compress\n  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);\n  output = rawdeflate.compress();\n  op = rawdeflate.op;\n\n  // expand buffer\n  {\n    if (op + 8 > output.buffer.byteLength) {\n      this.output = new Uint8Array(op + 8);\n      this.output.set(new Uint8Array(output.buffer));\n      output = this.output;\n    } else {\n      output = new Uint8Array(output.buffer);\n    }\n  }\n\n  // crc32\n  crc32 = Zlib.CRC32.calc(input);\n  output[op++] = (crc32       ) & 0xff;\n  output[op++] = (crc32 >>>  8) & 0xff;\n  output[op++] = (crc32 >>> 16) & 0xff;\n  output[op++] = (crc32 >>> 24) & 0xff;\n\n  // input size\n  il = input.length;\n  output[op++] = (il       ) & 0xff;\n  output[op++] = (il >>>  8) & 0xff;\n  output[op++] = (il >>> 16) & 0xff;\n  output[op++] = (il >>> 24) & 0xff;\n\n  this.ip = ip;\n\n  if ( op < output.length) {\n    this.output = output = output.subarray(0, op);\n  }\n\n  return output;\n};\n\n/** @enum {number} */\nZlib.Gzip.OperatingSystem = {\n  FAT: 0,\n  AMIGA: 1,\n  VMS: 2,\n  UNIX: 3,\n  VM_CMS: 4,\n  ATARI_TOS: 5,\n  HPFS: 6,\n  MACINTOSH: 7,\n  Z_SYSTEM: 8,\n  CP_M: 9,\n  TOPS_20: 10,\n  NTFS: 11,\n  QDOS: 12,\n  ACORN_RISCOS: 13,\n  UNKNOWN: 255\n};\n\n/** @enum {number} */\nZlib.Gzip.FlagsMask = {\n  FTEXT: 0x01,\n  FHCRC: 0x02,\n  FEXTRA: 0x04,\n  FNAME: 0x08,\n  FCOMMENT: 0x10\n};\n\n\n/**\n * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.\n */\n\n/**\n * カスタムハフマン符号で使用するヒープ実装\n * @param {number} length ヒープサイズ.\n * @constructor\n */\nZlib.Heap = function(length) {\n  this.buffer = new ( Uint16Array )(length * 2);\n  this.length = 0;\n};\n\n/**\n * 親ノードの index 取得\n * @param {number} index 子ノードの index.\n * @return {number} 親ノードの index.\n *\n */\nZlib.Heap.prototype.getParent = function(index) {\n  return ((index - 2) / 4 | 0) * 2;\n};\n\n/**\n * 子ノードの index 取得\n * @param {number} index 親ノードの index.\n * @return {number} 子ノードの index.\n */\nZlib.Heap.prototype.getChild = function(index) {\n  return 2 * index + 2;\n};\n\n/**\n * Heap に値を追加する\n * @param {number} index キー index.\n * @param {number} value 値.\n * @return {number} 現在のヒープ長.\n */\nZlib.Heap.prototype.push = function(index, value) {\n  var current, parent,\n      heap = this.buffer,\n      swap;\n\n  current = this.length;\n  heap[this.length++] = value;\n  heap[this.length++] = index;\n\n  // ルートノードにたどり着くまで入れ替えを試みる\n  while (current > 0) {\n    parent = this.getParent(current);\n\n    // 親ノードと比較して親の方が小さければ入れ替える\n    if (heap[current] > heap[parent]) {\n      swap = heap[current];\n      heap[current] = heap[parent];\n      heap[parent] = swap;\n\n      swap = heap[current + 1];\n      heap[current + 1] = heap[parent + 1];\n      heap[parent + 1] = swap;\n\n      current = parent;\n    // 入れ替えが必要なくなったらそこで抜ける\n    } else {\n      break;\n    }\n  }\n\n  return this.length;\n};\n\n/**\n * Heapから一番大きい値を返す\n * @return {{index: number, value: number, length: number}} {index: キーindex,\n *     value: 値, length: ヒープ長} の Object.\n */\nZlib.Heap.prototype.pop = function() {\n  var index, value,\n      heap = this.buffer, swap,\n      current, parent;\n\n  value = heap[0];\n  index = heap[1];\n\n  // 後ろから値を取る\n  this.length -= 2;\n  heap[0] = heap[this.length];\n  heap[1] = heap[this.length + 1];\n\n  parent = 0;\n  // ルートノードから下がっていく\n  while (true) {\n    current = this.getChild(parent);\n\n    // 範囲チェック\n    if (current >= this.length) {\n      break;\n    }\n\n    // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択\n    if (current + 2 < this.length && heap[current + 2] > heap[current]) {\n      current += 2;\n    }\n\n    // 親ノードと比較して親の方が小さい場合は入れ替える\n    if (heap[current] > heap[parent]) {\n      swap = heap[parent];\n      heap[parent] = heap[current];\n      heap[current] = swap;\n\n      swap = heap[parent + 1];\n      heap[parent + 1] = heap[current + 1];\n      heap[current + 1] = swap;\n    } else {\n      break;\n    }\n\n    parent = current;\n  }\n\n  return {index: index, value: value, length: this.length};\n};\n\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n/**\n * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.\n */\n\n\n/**\n * Raw Deflate 実装\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.\n * @param {Object=} opt_params option parameters.\n *\n * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に\n * 変換されます.\n * 別のオブジェクトになるため出力バッファを参照している変数などは\n * 更新する必要があります.\n */\nZlib.RawDeflate = function(input, opt_params) {\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;\n  /** @type {number} */\n  this.lazy = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsLitLen;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsDist;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input =\n    ( input instanceof Array) ? new Uint8Array(input) : input;\n  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\n  this.output;\n  /** @type {number} pos output buffer position. */\n  this.op = 0;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['lazy']) {\n      this.lazy = opt_params['lazy'];\n    }\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n    if (opt_params['outputBuffer']) {\n      this.output =\n        ( opt_params['outputBuffer'] instanceof Array) ?\n        new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\n    }\n    if (typeof opt_params['outputIndex'] === 'number') {\n      this.op = opt_params['outputIndex'];\n    }\n  }\n\n  if (!this.output) {\n    this.output = new ( Uint8Array )(0x8000);\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawDeflate.CompressionType = {\n  NONE: 0,\n  FIXED: 1,\n  DYNAMIC: 2,\n  RESERVED: 3\n};\n\n\n/**\n * LZ77 の最小マッチ長\n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MinLength = 3;\n\n/**\n * LZ77 の最大マッチ長\n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MaxLength = 258;\n\n/**\n * LZ77 のウィンドウサイズ\n * @const\n * @type {number}\n */\nZlib.RawDeflate.WindowSize = 0x8000;\n\n/**\n * 最長の符号長\n * @const\n * @type {number}\n */\nZlib.RawDeflate.MaxCodeLength = 16;\n\n/**\n * ハフマン符号の最大数値\n * @const\n * @type {number}\n */\nZlib.RawDeflate.HUFMAX = 286;\n\n/**\n * 固定ハフマン符号の符号化テーブル\n * @const\n * @type {Array.<Array.<number, number>>}\n */\nZlib.RawDeflate.FixedHuffmanTable = (function() {\n  var table = [], i;\n\n  for (i = 0; i < 288; i++) {\n    switch (true) {\n      case (i <= 143): table.push([i       + 0x030, 8]); break;\n      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\n      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\n      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\n      default:\n        throw 'invalid literal: ' + i;\n    }\n  }\n\n  return table;\n})();\n\n/**\n * DEFLATE ブロックの作成\n * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.\n */\nZlib.RawDeflate.prototype.compress = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var blockArray;\n  /** @type {number} */\n  var position;\n  /** @type {number} */\n  var length;\n\n  var input = this.input;\n\n  // compression\n  switch (this.compressionType) {\n    case Zlib.RawDeflate.CompressionType.NONE:\n      // each 65535-Byte (length header: 16-bit)\n      for (position = 0, length = input.length; position < length;) {\n        blockArray = \n          input.subarray(position, position + 0xffff) ;\n        position += blockArray.length;\n        this.makeNocompressBlock(blockArray, (position === length));\n      }\n      break;\n    case Zlib.RawDeflate.CompressionType.FIXED:\n      this.output = this.makeFixedHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    case Zlib.RawDeflate.CompressionType.DYNAMIC:\n      this.output = this.makeDynamicHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    default:\n      throw 'invalid compression type';\n  }\n\n  return this.output;\n};\n\n/**\n * 非圧縮ブロックの作成\n * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.\n */\nZlib.RawDeflate.prototype.makeNocompressBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {number} */\n  var len;\n  /** @type {number} */\n  var nlen;\n\n  var output = this.output;\n  var op = this.op;\n\n  // expand buffer\n  {\n    output = new Uint8Array(this.output.buffer);\n    while (output.length <= op + blockArray.length + 5) {\n      output = new Uint8Array(output.length << 1);\n    }\n    output.set(this.output);\n  }\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.NONE;\n  output[op++] = (bfinal) | (btype << 1);\n\n  // length\n  len = blockArray.length;\n  nlen = (~len + 0x10000) & 0xffff;\n  output[op++] =          len & 0xff;\n  output[op++] =  (len >>> 8) & 0xff;\n  output[op++] =         nlen & 0xff;\n  output[op++] = (nlen >>> 8) & 0xff;\n\n  // copy buffer\n  {\n     output.set(blockArray, op);\n     op += blockArray.length;\n     output = output.subarray(0, op);\n  }\n\n  this.op = op;\n  this.output = output;\n\n  return output;\n};\n\n/**\n * 固定ハフマンブロックの作成\n * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.\n */\nZlib.RawDeflate.prototype.makeFixedHuffmanBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(\n    new Uint8Array(this.output.buffer) , this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.FIXED;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n  this.fixedHuffman(data, stream);\n\n  return stream.finish();\n};\n\n/**\n * 動的ハフマンブロックの作成\n * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.\n */\nZlib.RawDeflate.prototype.makeDynamicHuffmanBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(\n    new Uint8Array(this.output.buffer) , this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n  /** @type {number} */\n  var hlit;\n  /** @type {number} */\n  var hdist;\n  /** @type {number} */\n  var hclen;\n  /** @const @type {Array.<number>} */\n  var hclenOrder =\n        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var litLenLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var litLenCodes;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var distLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var distCodes;\n  /** @type {{\n   *   codes: !(Array.<number>|Uint32Array),\n   *   freqs: !(Array.<number>|Uint8Array)\n   * }} */\n  var treeSymbols;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var treeLengths;\n  /** @type {Array} */\n  var transLengths = new Array(19);\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var treeCodes;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var bitlen;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.DYNAMIC;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n\n  // リテラル・長さ, 距離のハフマン符号と符号長の算出\n  litLenLengths = this.getLengths_(this.freqsLitLen, 15);\n  litLenCodes = this.getCodesFromLengths_(litLenLengths);\n  distLengths = this.getLengths_(this.freqsDist, 7);\n  distCodes = this.getCodesFromLengths_(distLengths);\n\n  // HLIT, HDIST の決定\n  for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\n  for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\n\n  // HCLEN\n  treeSymbols =\n    this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\n  treeLengths = this.getLengths_(treeSymbols.freqs, 7);\n  for (i = 0; i < 19; i++) {\n    transLengths[i] = treeLengths[hclenOrder[i]];\n  }\n  for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\n\n  treeCodes = this.getCodesFromLengths_(treeLengths);\n\n  // 出力\n  stream.writeBits(hlit - 257, 5, true);\n  stream.writeBits(hdist - 1, 5, true);\n  stream.writeBits(hclen - 4, 4, true);\n  for (i = 0; i < hclen; i++) {\n    stream.writeBits(transLengths[i], 3, true);\n  }\n\n  // ツリーの出力\n  for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\n    code = treeSymbols.codes[i];\n\n    stream.writeBits(treeCodes[code], treeLengths[code], true);\n\n    // extra bits\n    if (code >= 16) {\n      i++;\n      switch (code) {\n        case 16: bitlen = 2; break;\n        case 17: bitlen = 3; break;\n        case 18: bitlen = 7; break;\n        default:\n          throw 'invalid code: ' + code;\n      }\n\n      stream.writeBits(treeSymbols.codes[i], bitlen, true);\n    }\n  }\n\n  this.dynamicHuffman(\n    data,\n    [litLenCodes, litLenLengths],\n    [distCodes, distLengths],\n    stream\n  );\n\n  return stream.finish();\n};\n\n\n/**\n * 動的ハフマン符号化(カスタムハフマンテーブル)\n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\n * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.\n * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.\n */\nZlib.RawDeflate.prototype.dynamicHuffman =\nfunction(dataArray, litLen, dist, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var litLenCodes;\n  /** @type {number} */\n  var litLenLengths;\n  /** @type {number} */\n  var distCodes;\n  /** @type {number} */\n  var distLengths;\n\n  litLenCodes = litLen[0];\n  litLenLengths = litLen[1];\n  distCodes = dist[0];\n  distLengths = dist[1];\n\n  // 符号を BitStream に書き込んでいく\n  for (index = 0, length = dataArray.length; index < length; ++index) {\n    literal = dataArray[index];\n\n    // literal or length\n    stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\n\n    // 長さ・距離符号\n    if (literal > 256) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      code = dataArray[++index];\n      stream.writeBits(distCodes[code], distLengths[code], true);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n    // 終端\n    } else if (literal === 256) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * 固定ハフマン符号化\n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\n * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.\n * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.\n */\nZlib.RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n\n  // 符号を BitStream に書き込んでいく\n  for (index = 0, length = dataArray.length; index < length; index++) {\n    literal = dataArray[index];\n\n    // 符号の書き込み\n    Zlib.BitStream.prototype.writeBits.apply(\n      stream,\n      Zlib.RawDeflate.FixedHuffmanTable[literal]\n    );\n\n    // 長さ・距離符号\n    if (literal > 0x100) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      stream.writeBits(dataArray[++index], 5);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n    // 終端\n    } else if (literal === 0x100) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * マッチ情報\n * @param {!number} length マッチした長さ.\n * @param {!number} backwardDistance マッチ位置との距離.\n * @constructor\n */\nZlib.RawDeflate.Lz77Match = function(length, backwardDistance) {\n  /** @type {number} match length. */\n  this.length = length;\n  /** @type {number} backward distance. */\n  this.backwardDistance = backwardDistance;\n};\n\n/**\n * 長さ符号テーブル.\n * [コード, 拡張ビット, 拡張ビット長] の配列となっている.\n * @const\n * @type {!(Array.<number>|Uint32Array)}\n */\nZlib.RawDeflate.Lz77Match.LengthCodeTable = (function(table) {\n  return  new Uint32Array(table) ;\n})((function() {\n  /** @type {!Array} */\n  var table = [];\n  /** @type {number} */\n  var i;\n  /** @type {!Array.<number>} */\n  var c;\n\n  for (i = 3; i <= 258; i++) {\n    c = code(i);\n    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\n  }\n\n  /**\n   * @param {number} length lz77 length.\n   * @return {!Array.<number>} lz77 codes.\n   */\n  function code(length) {\n    switch (true) {\n      case (length === 3): return [257, length - 3, 0];      case (length === 4): return [258, length - 4, 0];      case (length === 5): return [259, length - 5, 0];      case (length === 6): return [260, length - 6, 0];      case (length === 7): return [261, length - 7, 0];      case (length === 8): return [262, length - 8, 0];      case (length === 9): return [263, length - 9, 0];      case (length === 10): return [264, length - 10, 0];      case (length <= 12): return [265, length - 11, 1];      case (length <= 14): return [266, length - 13, 1];      case (length <= 16): return [267, length - 15, 1];      case (length <= 18): return [268, length - 17, 1];      case (length <= 22): return [269, length - 19, 2];      case (length <= 26): return [270, length - 23, 2];      case (length <= 30): return [271, length - 27, 2];      case (length <= 34): return [272, length - 31, 2];      case (length <= 42): return [273, length - 35, 3];      case (length <= 50): return [274, length - 43, 3];      case (length <= 58): return [275, length - 51, 3];      case (length <= 66): return [276, length - 59, 3];      case (length <= 82): return [277, length - 67, 4];      case (length <= 98): return [278, length - 83, 4];      case (length <= 114): return [279, length - 99, 4];      case (length <= 130): return [280, length - 115, 4];      case (length <= 162): return [281, length - 131, 5];      case (length <= 194): return [282, length - 163, 5];      case (length <= 226): return [283, length - 195, 5];      case (length <= 257): return [284, length - 227, 5];      case (length === 258): return [285, length - 258, 0];      default: throw 'invalid length: ' + length;\n    }\n  }\n\n  return table;\n})());\n\n/**\n * 距離符号テーブル\n * @param {!number} dist 距離.\n * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.\n * @private\n */\nZlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {\n  /** @type {!Array.<number>} distance code table. */\n  var r;\n\n  switch (true) {\n    case (dist === 1): r = [0, dist - 1, 0]; break;\n    case (dist === 2): r = [1, dist - 2, 0]; break;\n    case (dist === 3): r = [2, dist - 3, 0]; break;\n    case (dist === 4): r = [3, dist - 4, 0]; break;\n    case (dist <= 6): r = [4, dist - 5, 1]; break;\n    case (dist <= 8): r = [5, dist - 7, 1]; break;\n    case (dist <= 12): r = [6, dist - 9, 2]; break;\n    case (dist <= 16): r = [7, dist - 13, 2]; break;\n    case (dist <= 24): r = [8, dist - 17, 3]; break;\n    case (dist <= 32): r = [9, dist - 25, 3]; break;\n    case (dist <= 48): r = [10, dist - 33, 4]; break;\n    case (dist <= 64): r = [11, dist - 49, 4]; break;\n    case (dist <= 96): r = [12, dist - 65, 5]; break;\n    case (dist <= 128): r = [13, dist - 97, 5]; break;\n    case (dist <= 192): r = [14, dist - 129, 6]; break;\n    case (dist <= 256): r = [15, dist - 193, 6]; break;\n    case (dist <= 384): r = [16, dist - 257, 7]; break;\n    case (dist <= 512): r = [17, dist - 385, 7]; break;\n    case (dist <= 768): r = [18, dist - 513, 8]; break;\n    case (dist <= 1024): r = [19, dist - 769, 8]; break;\n    case (dist <= 1536): r = [20, dist - 1025, 9]; break;\n    case (dist <= 2048): r = [21, dist - 1537, 9]; break;\n    case (dist <= 3072): r = [22, dist - 2049, 10]; break;\n    case (dist <= 4096): r = [23, dist - 3073, 10]; break;\n    case (dist <= 6144): r = [24, dist - 4097, 11]; break;\n    case (dist <= 8192): r = [25, dist - 6145, 11]; break;\n    case (dist <= 12288): r = [26, dist - 8193, 12]; break;\n    case (dist <= 16384): r = [27, dist - 12289, 12]; break;\n    case (dist <= 24576): r = [28, dist - 16385, 13]; break;\n    case (dist <= 32768): r = [29, dist - 24577, 13]; break;\n    default: throw 'invalid distance';\n  }\n\n  return r;\n};\n\n/**\n * マッチ情報を LZ77 符号化配列で返す.\n * なお、ここでは以下の内部仕様で符号化している\n * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\n * @return {!Array.<number>} LZ77 符号化 byte array.\n */\nZlib.RawDeflate.Lz77Match.prototype.toLz77Array = function() {\n  /** @type {number} */\n  var length = this.length;\n  /** @type {number} */\n  var dist = this.backwardDistance;\n  /** @type {Array} */\n  var codeArray = [];\n  /** @type {number} */\n  var pos = 0;\n  /** @type {!Array.<number>} */\n  var code;\n\n  // length\n  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];\n  codeArray[pos++] = code & 0xffff;\n  codeArray[pos++] = (code >> 16) & 0xff;\n  codeArray[pos++] = code >> 24;\n\n  // distance\n  code = this.getDistanceCode_(dist);\n  codeArray[pos++] = code[0];\n  codeArray[pos++] = code[1];\n  codeArray[pos++] = code[2];\n\n  return codeArray;\n};\n\n/**\n * LZ77 実装\n * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.\n * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.\n */\nZlib.RawDeflate.prototype.lz77 = function(dataArray) {\n  /** @type {number} input position */\n  var position;\n  /** @type {number} input length */\n  var length;\n  /** @type {number} loop counter */\n  var i;\n  /** @type {number} loop limiter */\n  var il;\n  /** @type {number} chained-hash-table key */\n  var matchKey;\n  /** @type {Object.<number, Array.<number>>} chained-hash-table */\n  var table = {};\n  /** @const @type {number} */\n  var windowSize = Zlib.RawDeflate.WindowSize;\n  /** @type {Array.<number>} match list */\n  var matchList;\n  /** @type {Zlib.RawDeflate.Lz77Match} longest match */\n  var longestMatch;\n  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */\n  var prevMatch;\n  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\n  var lz77buf = \n    new Uint16Array(dataArray.length * 2) ;\n  /** @type {number} lz77 output buffer pointer */\n  var pos = 0;\n  /** @type {number} lz77 skip length */\n  var skipLength = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsLitLen = new ( Uint32Array )(286);\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsDist = new ( Uint32Array )(30);\n  /** @type {number} */\n  var lazy = this.lazy;\n  /** @type {*} temporary variable */\n  var tmp;\n  freqsLitLen[256] = 1; // EOB の最低出現回数は 1\n\n  /**\n   * マッチデータの書き込み\n   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.\n   * @param {!number} offset スキップ開始位置(相対指定).\n   * @private\n   */\n  function writeMatch(match, offset) {\n    /** @type {Array.<number>} */\n    var lz77Array = match.toLz77Array();\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    for (i = 0, il = lz77Array.length; i < il; ++i) {\n      lz77buf[pos++] = lz77Array[i];\n    }\n    freqsLitLen[lz77Array[0]]++;\n    freqsDist[lz77Array[3]]++;\n    skipLength = match.length + offset - 1;\n    prevMatch = null;\n  }\n\n  // LZ77 符号化\n  for (position = 0, length = dataArray.length; position < length; ++position) {\n    // ハッシュキーの作成\n    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {\n      if (position + i === length) {\n        break;\n      }\n      matchKey = (matchKey << 8) | dataArray[position + i];\n    }\n\n    // テーブルが未定義だったら作成する\n    if (table[matchKey] === void 0) { table[matchKey] = []; }\n    matchList = table[matchKey];\n\n    // skip\n    if (skipLength-- > 0) {\n      matchList.push(position);\n      continue;\n    }\n\n    // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)\n    while (matchList.length > 0 && position - matchList[0] > windowSize) {\n      matchList.shift();\n    }\n\n    // データ末尾でマッチしようがない場合はそのまま流しこむ\n    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {\n      if (prevMatch) {\n        writeMatch(prevMatch, -1);\n      }\n\n      for (i = 0, il = length - position; i < il; ++i) {\n        tmp = dataArray[position + i];\n        lz77buf[pos++] = tmp;\n        ++freqsLitLen[tmp];\n      }\n      break;\n    }\n\n    // マッチ候補から最長のものを探す\n    if (matchList.length > 0) {\n      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\n\n      if (prevMatch) {\n        // 現在のマッチの方が前回のマッチよりも長い\n        if (prevMatch.length < longestMatch.length) {\n          // write previous literal\n          tmp = dataArray[position - 1];\n          lz77buf[pos++] = tmp;\n          ++freqsLitLen[tmp];\n\n          // write current match\n          writeMatch(longestMatch, 0);\n        } else {\n          // write previous match\n          writeMatch(prevMatch, -1);\n        }\n      } else if (longestMatch.length < lazy) {\n        prevMatch = longestMatch;\n      } else {\n        writeMatch(longestMatch, 0);\n      }\n    // 前回マッチしていて今回マッチがなかったら前回のを採用\n    } else if (prevMatch) {\n      writeMatch(prevMatch, -1);\n    } else {\n      tmp = dataArray[position];\n      lz77buf[pos++] = tmp;\n      ++freqsLitLen[tmp];\n    }\n\n    matchList.push(position); // マッチテーブルに現在の位置を保存\n  }\n\n  // 終端処理\n  lz77buf[pos++] = 256;\n  freqsLitLen[256]++;\n  this.freqsLitLen = freqsLitLen;\n  this.freqsDist = freqsDist;\n\n  return /** @type {!(Uint16Array|Array.<number>)} */ (\n      lz77buf.subarray(0, pos) \n  );\n};\n\n/**\n * マッチした候補の中から最長一致を探す\n * @param {!Object} data plain data byte array.\n * @param {!number} position plain data byte array position.\n * @param {!Array.<number>} matchList 候補となる位置の配列.\n * @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.\n * @private\n */\nZlib.RawDeflate.prototype.searchLongestMatch_ =\nfunction(data, position, matchList) {\n  var match,\n      currentMatch,\n      matchMax = 0, matchLength,\n      i, j, l, dl = data.length;\n\n  // 候補を後ろから 1 つずつ絞り込んでゆく\n  permatch:\n  for (i = 0, l = matchList.length; i < l; i++) {\n    match = matchList[l - i - 1];\n    matchLength = Zlib.RawDeflate.Lz77MinLength;\n\n    // 前回までの最長一致を末尾から一致検索する\n    if (matchMax > Zlib.RawDeflate.Lz77MinLength) {\n      for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {\n        if (data[match + j - 1] !== data[position + j - 1]) {\n          continue permatch;\n        }\n      }\n      matchLength = matchMax;\n    }\n\n    // 最長一致探索\n    while (matchLength < Zlib.RawDeflate.Lz77MaxLength &&\n           position + matchLength < dl &&\n           data[match + matchLength] === data[position + matchLength]) {\n      ++matchLength;\n    }\n\n    // マッチ長が同じ場合は後方を優先\n    if (matchLength > matchMax) {\n      currentMatch = match;\n      matchMax = matchLength;\n    }\n\n    // 最長が確定したら後の処理は省略\n    if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {\n      break;\n    }\n  }\n\n  return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);\n};\n\n/**\n * Tree-Transmit Symbols の算出\n * reference: PuTTY Deflate implementation\n * @param {number} hlit HLIT.\n * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.\n * @param {number} hdist HDIST.\n * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.\n * @return {{\n *   codes: !(Array.<number>|Uint32Array),\n *   freqs: !(Array.<number>|Uint8Array)\n * }} Tree-Transmit Symbols.\n */\nZlib.RawDeflate.prototype.getTreeSymbols_ =\nfunction(hlit, litlenLengths, hdist, distLengths) {\n  var src = new ( Uint32Array )(hlit + hdist),\n      i, j, runLength, l,\n      result = new ( Uint32Array )(286 + 30),\n      nResult,\n      rpt,\n      freqs = new ( Uint8Array )(19);\n\n  j = 0;\n  for (i = 0; i < hlit; i++) {\n    src[j++] = litlenLengths[i];\n  }\n  for (i = 0; i < hdist; i++) {\n    src[j++] = distLengths[i];\n  }\n\n  // 符号化\n  nResult = 0;\n  for (i = 0, l = src.length; i < l; i += j) {\n    // Run Length Encoding\n    for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\n\n    runLength = j;\n\n    if (src[i] === 0) {\n      // 0 の繰り返しが 3 回未満ならばそのまま\n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = 0;\n          freqs[0]++;\n        }\n      } else {\n        while (runLength > 0) {\n          // 繰り返しは最大 138 までなので切り詰める\n          rpt = (runLength < 138 ? runLength : 138);\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          // 3-10 回 -> 17\n          if (rpt <= 10) {\n            result[nResult++] = 17;\n            result[nResult++] = rpt - 3;\n            freqs[17]++;\n          // 11-138 回 -> 18\n          } else {\n            result[nResult++] = 18;\n            result[nResult++] = rpt - 11;\n            freqs[18]++;\n          }\n\n          runLength -= rpt;\n        }\n      }\n    } else {\n      result[nResult++] = src[i];\n      freqs[src[i]]++;\n      runLength--;\n\n      // 繰り返し回数が3回未満ならばランレングス符号は要らない\n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = src[i];\n          freqs[src[i]]++;\n        }\n      // 3 回以上ならばランレングス符号化\n      } else {\n        while (runLength > 0) {\n          // runLengthを 3-6 で分割\n          rpt = (runLength < 6 ? runLength : 6);\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          result[nResult++] = 16;\n          result[nResult++] = rpt - 3;\n          freqs[16]++;\n\n          runLength -= rpt;\n        }\n      }\n    }\n  }\n\n  return {\n    codes:\n       result.subarray(0, nResult) ,\n    freqs: freqs\n  };\n};\n\n/**\n * ハフマン符号の長さを取得する\n * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.\n * @param {number} limit 符号長の制限.\n * @return {!(Array.<number>|Uint8Array)} 符号長配列.\n * @private\n */\nZlib.RawDeflate.prototype.getLengths_ = function(freqs, limit) {\n  /** @type {number} */\n  var nSymbols = freqs.length;\n  /** @type {Zlib.Heap} */\n  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var length = new ( Uint8Array )(nSymbols);\n  /** @type {Array} */\n  var nodes;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var values;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // ヒープの構築\n  for (i = 0; i < nSymbols; ++i) {\n    if (freqs[i] > 0) {\n      heap.push(i, freqs[i]);\n    }\n  }\n  nodes = new Array(heap.length / 2);\n  values = new ( Uint32Array )(heap.length / 2);\n\n  // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了\n  if (nodes.length === 1) {\n    length[heap.pop().index] = 1;\n    return length;\n  }\n\n  // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定\n  for (i = 0, il = heap.length / 2; i < il; ++i) {\n    nodes[i] = heap.pop();\n    values[i] = nodes[i].value;\n  }\n  codeLength = this.reversePackageMerge_(values, values.length, limit);\n\n  for (i = 0, il = nodes.length; i < il; ++i) {\n    length[nodes[i].index] = codeLength[i];\n  }\n\n  return length;\n};\n\n/**\n * Reverse Package Merge Algorithm.\n * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\n * @param {number} symbols number of symbols.\n * @param {number} limit code length limit.\n * @return {!(Array.<number>|Uint8Array)} code lengths.\n */\nZlib.RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var minimumCost = new ( Uint16Array )(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var flag = new ( Uint8Array )(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength = new ( Uint8Array )(symbols);\n  /** @type {Array} */\n  var value = new Array(limit);\n  /** @type {Array} */\n  var type  = new Array(limit);\n  /** @type {Array.<number>} */\n  var currentPosition = new Array(limit);\n  /** @type {number} */\n  var excess = (1 << limit) - symbols;\n  /** @type {number} */\n  var half = (1 << (limit - 1));\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var t;\n  /** @type {number} */\n  var weight;\n  /** @type {number} */\n  var next;\n\n  /**\n   * @param {number} j\n   */\n  function takePackage(j) {\n    /** @type {number} */\n    var x = type[j][currentPosition[j]];\n\n    if (x === symbols) {\n      takePackage(j+1);\n      takePackage(j+1);\n    } else {\n      --codeLength[x];\n    }\n\n    ++currentPosition[j];\n  }\n\n  minimumCost[limit-1] = symbols;\n\n  for (j = 0; j < limit; ++j) {\n    if (excess < half) {\n      flag[j] = 0;\n    } else {\n      flag[j] = 1;\n      excess -= half;\n    }\n    excess <<= 1;\n    minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\n  }\n  minimumCost[0] = flag[0];\n\n  value[0] = new Array(minimumCost[0]);\n  type[0]  = new Array(minimumCost[0]);\n  for (j = 1; j < limit; ++j) {\n    if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\n      minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\n    }\n    value[j] = new Array(minimumCost[j]);\n    type[j]  = new Array(minimumCost[j]);\n  }\n\n  for (i = 0; i < symbols; ++i) {\n    codeLength[i] = limit;\n  }\n\n  for (t = 0; t < minimumCost[limit-1]; ++t) {\n    value[limit-1][t] = freqs[t];\n    type[limit-1][t]  = t;\n  }\n\n  for (i = 0; i < limit; ++i) {\n    currentPosition[i] = 0;\n  }\n  if (flag[limit-1] === 1) {\n    --codeLength[0];\n    ++currentPosition[limit-1];\n  }\n\n  for (j = limit-2; j >= 0; --j) {\n    i = 0;\n    weight = 0;\n    next = currentPosition[j+1];\n\n    for (t = 0; t < minimumCost[j]; t++) {\n      weight = value[j+1][next] + value[j+1][next+1];\n\n      if (weight > freqs[i]) {\n        value[j][t] = weight;\n        type[j][t] = symbols;\n        next += 2;\n      } else {\n        value[j][t] = freqs[i];\n        type[j][t] = i;\n        ++i;\n      }\n    }\n\n    currentPosition[j] = 0;\n    if (flag[j] === 1) {\n      takePackage(j);\n    }\n  }\n\n  return codeLength;\n};\n\n/**\n * 符号長配列からハフマン符号を取得する\n * reference: PuTTY Deflate implementation\n * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.\n * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.\n * @private\n */\nZlib.RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {\n  var codes = new ( Uint16Array )(lengths.length),\n      count = [],\n      startCode = [],\n      code = 0, i, il, j, m;\n\n  // Count the codes of each length.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    count[lengths[i]] = (count[lengths[i]] | 0) + 1;\n  }\n\n  // Determine the starting code for each length block.\n  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {\n    startCode[i] = code;\n    code += count[i] | 0;\n    code <<= 1;\n  }\n\n  // Determine the code for each symbol. Mirrored, of course.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    code = startCode[lengths[i]];\n    startCode[lengths[i]] += 1;\n    codes[i] = 0;\n\n    for (j = 0, m = lengths[i]; j < m; j++) {\n      codes[i] = (codes[i] << 1) | (code & 1);\n      code >>>= 1;\n    }\n  }\n\n  return codes;\n};\n\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Unzip = function(input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input =\n    ( (input instanceof Array)) ?\n    new Uint8Array(input) : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {number} */\n  this.eocdrOffset;\n  /** @type {number} */\n  this.numberOfThisDisk;\n  /** @type {number} */\n  this.startDisk;\n  /** @type {number} */\n  this.totalEntriesThisDisk;\n  /** @type {number} */\n  this.totalEntries;\n  /** @type {number} */\n  this.centralDirectorySize;\n  /** @type {number} */\n  this.centralDirectoryOffset;\n  /** @type {number} */\n  this.commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  this.fileHeaderList;\n  /** @type {Object.<string, number>} */\n  this.filenameToIndex;\n  /** @type {boolean} */\n  this.verify = opt_params['verify'] || false;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password = opt_params['password'];\n};\n\nZlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.FileHeader = function(input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.version;\n  /** @type {number} */\n  this.os;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {number} */\n  this.fileCommentLength;\n  /** @type {number} */\n  this.diskNumberStart;\n  /** @type {number} */\n  this.internalFileAttributes;\n  /** @type {number} */\n  this.externalFileAttributes;\n  /** @type {number} */\n  this.relativeOffset;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.comment;\n};\n\nZlib.Unzip.FileHeader.prototype.parse = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // central file header signature\n  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {\n    throw new Error('invalid file header signature');\n  }\n\n  // version made by\n  this.version = input[ip++];\n  this.os = input[ip++];\n\n  // version needed to extract\n  this.needVersion = input[ip++] | (input[ip++] << 8);\n\n  // general purpose bit flag\n  this.flags = input[ip++] | (input[ip++] << 8);\n\n  // compression method\n  this.compression = input[ip++] | (input[ip++] << 8);\n\n  // last mod file time\n  this.time = input[ip++] | (input[ip++] << 8);\n\n  //last mod file date\n  this.date = input[ip++] | (input[ip++] << 8);\n\n  // crc-32\n  this.crc32 = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // compressed size\n  this.compressedSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n  // file comment length\n  this.fileCommentLength = input[ip++] | (input[ip++] << 8);\n\n  // disk number start\n  this.diskNumberStart = input[ip++] | (input[ip++] << 8);\n\n  // internal file attributes\n  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);\n\n  // external file attributes\n  this.externalFileAttributes =\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24);\n\n  // relative offset of local header\n  this.relativeOffset = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, \n    input.subarray(ip, ip += this.fileNameLength) \n  );\n\n  // extra field\n  this.extraField = \n    input.subarray(ip, ip += this.extraFieldLength) ;\n\n  // file comment\n  this.comment = \n    input.subarray(ip, ip + this.fileCommentLength) ;\n\n  this.length = ip - this.offset;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.LocalFileHeader = function(input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n};\n\nZlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;\n\nZlib.Unzip.LocalFileHeader.prototype.parse = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // local file header signature\n  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {\n    throw new Error('invalid local file header signature');\n  }\n\n  // version needed to extract\n  this.needVersion = input[ip++] | (input[ip++] << 8);\n\n  // general purpose bit flag\n  this.flags = input[ip++] | (input[ip++] << 8);\n\n  // compression method\n  this.compression = input[ip++] | (input[ip++] << 8);\n\n  // last mod file time\n  this.time = input[ip++] | (input[ip++] << 8);\n\n  //last mod file date\n  this.date = input[ip++] | (input[ip++] << 8);\n\n  // crc-32\n  this.crc32 = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // compressed size\n  this.compressedSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, \n    input.subarray(ip, ip += this.fileNameLength) \n  );\n\n  // extra field\n  this.extraField = \n    input.subarray(ip, ip += this.extraFieldLength) ;\n\n  this.length = ip - this.offset;\n};\n\n\nZlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  for (ip = input.length - 12; ip > 0; --ip) {\n    if (input[ip  ] === Zlib.Unzip.CentralDirectorySignature[0] &&\n        input[ip+1] === Zlib.Unzip.CentralDirectorySignature[1] &&\n        input[ip+2] === Zlib.Unzip.CentralDirectorySignature[2] &&\n        input[ip+3] === Zlib.Unzip.CentralDirectorySignature[3]) {\n      this.eocdrOffset = ip;\n      return;\n    }\n  }\n\n  throw new Error('End of Central Directory Record not found');\n};\n\nZlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  if (!this.eocdrOffset) {\n    this.searchEndOfCentralDirectoryRecord();\n  }\n  ip = this.eocdrOffset;\n\n  // signature\n  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {\n    throw new Error('invalid signature');\n  }\n\n  // number of this disk\n  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);\n\n  // number of the disk with the start of the central directory\n  this.startDisk = input[ip++] | (input[ip++] << 8);\n\n  // total number of entries in the central directory on this disk\n  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);\n\n  // total number of entries in the central directory\n  this.totalEntries = input[ip++] | (input[ip++] << 8);\n\n  // size of the central directory\n  this.centralDirectorySize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // offset of start of central directory with respect to the starting disk number\n  this.centralDirectoryOffset = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // .ZIP file comment length\n  this.commentLength = input[ip++] | (input[ip++] << 8);\n\n  // .ZIP file comment\n  this.comment = \n    input.subarray(ip, ip + this.commentLength) ;\n};\n\nZlib.Unzip.prototype.parseFileHeader = function() {\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var filelist = [];\n  /** @type {Object.<string, number>} */\n  var filetable = {};\n  /** @type {number} */\n  var ip;\n  /** @type {Zlib.Unzip.FileHeader} */\n  var fileHeader;\n  /*: @type {number} */\n  var i;\n  /*: @type {number} */\n  var il;\n\n  if (this.fileHeaderList) {\n    return;\n  }\n\n  if (this.centralDirectoryOffset === void 0) {\n    this.parseEndOfCentralDirectoryRecord();\n  }\n  ip = this.centralDirectoryOffset;\n\n  for (i = 0, il = this.totalEntries; i < il; ++i) {\n    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);\n    fileHeader.parse();\n    ip += fileHeader.length;\n    filelist[i] = fileHeader;\n    filetable[fileHeader.filename] = i;\n  }\n\n  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {\n    throw new Error('invalid file header size');\n  }\n\n  this.fileHeaderList = filelist;\n  this.filenameToIndex = filetable;\n};\n\n/**\n * @param {number} index file header index.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} file data.\n */\nZlib.Unzip.prototype.getFileData = function(index, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList = this.fileHeaderList;\n  /** @type {Zlib.Unzip.LocalFileHeader} */\n  var localFileHeader;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var length;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {number} */\n  var crc32;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  if (!fileHeaderList) {\n    this.parseFileHeader();\n  }\n\n  if (fileHeaderList[index] === void 0) {\n    throw new Error('wrong index');\n  }\n\n  offset = fileHeaderList[index].relativeOffset;\n  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);\n  localFileHeader.parse();\n  offset += localFileHeader.length;\n  length = localFileHeader.compressedSize;\n\n  // decryption\n  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {\n    if (!(opt_params['password'] || this.password)) {\n      throw new Error('please set password');\n    }\n    key =  this.createDecryptionKey(opt_params['password'] || this.password);\n\n    // encryption header\n    for(i = offset, il = offset + 12; i < il; ++i) {\n      this.decode(key, input[i]);\n    }\n    offset += 12;\n    length -= 12;\n\n    // decryption\n    for (i = offset, il = offset + length; i < il; ++i) {\n      input[i] = this.decode(key, input[i]);\n    }\n  }\n\n  switch (localFileHeader.compression) {\n    case Zlib.Unzip.CompressionMethod.STORE:\n      buffer = \n        this.input.subarray(offset, offset + length) ;\n      break;\n    case Zlib.Unzip.CompressionMethod.DEFLATE:\n      buffer = new Zlib.RawInflate(this.input, {\n        'index': offset,\n        'bufferSize': localFileHeader.plainSize\n      }).decompress();\n      break;\n    default:\n      throw new Error('unknown compression type');\n  }\n\n  if (this.verify) {\n    crc32 = Zlib.CRC32.calc(buffer);\n    if (localFileHeader.crc32 !== crc32) {\n      throw new Error(\n        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +\n        ', data=0x' + crc32.toString(16)\n      );\n    }\n  }\n\n  return buffer;\n};\n\n/**\n * @return {Array.<string>}\n */\nZlib.Unzip.prototype.getFilenames = function() {\n  /** @type {Array.<string>} */\n  var filenameList = [];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList;\n\n  if (!this.fileHeaderList) {\n    this.parseFileHeader();\n  }\n  fileHeaderList = this.fileHeaderList;\n\n  for (i = 0, il = fileHeaderList.length; i < il; ++i) {\n    filenameList[i] = fileHeaderList[i].filename;\n  }\n\n  return filenameList;\n};\n\n/**\n * @param {string} filename extract filename.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} decompressed data.\n */\nZlib.Unzip.prototype.decompress = function(filename, opt_params) {\n  /** @type {number} */\n  var index;\n\n  if (!this.filenameToIndex) {\n    this.parseFileHeader();\n  }\n  index = this.filenameToIndex[filename];\n\n  if (index === void 0) {\n    throw new Error(filename + ' not found');\n  }\n\n  return this.getFileData(index, opt_params);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Unzip.prototype.setPassword = function(password) {\n  this.password = password;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Unzip.prototype.decode = function(key, n) {\n  n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n  return n;\n};\n\n// common method\nZlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;\nZlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;\nZlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;\n\n/**\n * @fileoverview 雑多な関数群をまとめたモジュール実装.\n */\n\n\n/**\n * Byte String から Byte Array に変換.\n * @param {!string} str byte string.\n * @return {!Array.<number>} byte array.\n */\nZlib.Util.stringToByteArray = function(str) {\n  /** @type {!Array.<(string|number)>} */\n  var tmp = str.split('');\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  for (i = 0, il = tmp.length; i < il; i++) {\n    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;\n  }\n\n  return tmp;\n};\n\n\n/**\n * @fileoverview Adler32 checksum 実装.\n */\n\n\n/**\n * Adler32 ハッシュ値の作成\n * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.\n * @return {number} Adler32 ハッシュ値.\n */\nZlib.Adler32 = function(array) {\n  if (typeof(array) === 'string') {\n    array = Zlib.Util.stringToByteArray(array);\n  }\n  return Zlib.Adler32.update(1, array);\n};\n\n/**\n * Adler32 ハッシュ値の更新\n * @param {number} adler 現在のハッシュ値.\n * @param {!(Array|Uint8Array)} array 更新に使用する byte array.\n * @return {number} Adler32 ハッシュ値.\n */\nZlib.Adler32.update = function(adler, array) {\n  /** @type {number} */\n  var s1 = adler & 0xffff;\n  /** @type {number} */\n  var s2 = (adler >>> 16) & 0xffff;\n  /** @type {number} array length */\n  var len = array.length;\n  /** @type {number} loop length (don't overflow) */\n  var tlen;\n  /** @type {number} array index */\n  var i = 0;\n\n  while (len > 0) {\n    tlen = len > Zlib.Adler32.OptimizationParameter ?\n      Zlib.Adler32.OptimizationParameter : len;\n    len -= tlen;\n    do {\n      s1 += array[i++];\n      s2 += s1;\n    } while (--tlen);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return ((s2 << 16) | s1) >>> 0;\n};\n\n/**\n * Adler32 最適化パラメータ\n * 現状では 1024 程度が最適.\n * @see http://jsperf.com/adler-32-simple-vs-optimized/3\n * @define {number}\n */\nZlib.Adler32.OptimizationParameter = 1024;\n\n\n\n\n/**\n * ビットストリーム\n * @constructor\n * @param {!(Array|Uint8Array)=} buffer output buffer.\n * @param {number=} bufferPosition start buffer pointer.\n */\nZlib.BitStream = function(buffer, bufferPosition) {\n  /** @type {number} buffer index. */\n  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\n  /** @type {number} bit index. */\n  this.bitindex = 0;\n  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\n  this.buffer = buffer instanceof ( Uint8Array ) ?\n    buffer :\n    new ( Uint8Array )(Zlib.BitStream.DefaultBlockSize);\n\n  // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする\n  if (this.buffer.length * 2 <= this.index) {\n    throw new Error(\"invalid index\");\n  } else if (this.buffer.length <= this.index) {\n    this.expandBuffer();\n  }\n};\n\n/**\n * デフォルトブロックサイズ.\n * @const\n * @type {number}\n */\nZlib.BitStream.DefaultBlockSize = 0x8000;\n\n/**\n * expand buffer.\n * @return {!(Array|Uint8Array)} new buffer.\n */\nZlib.BitStream.prototype.expandBuffer = function() {\n  /** @type {!(Array|Uint8Array)} old buffer. */\n  var oldbuf = this.buffer;\n  /** @type {number} loop limiter. */\n  var il = oldbuf.length;\n  /** @type {!(Array|Uint8Array)} new buffer. */\n  var buffer =\n    new ( Uint8Array )(il << 1);\n\n  // copy buffer\n  {\n    buffer.set(oldbuf);\n  }\n\n  return (this.buffer = buffer);\n};\n\n\n/**\n * 数値をビットで指定した数だけ書き込む.\n * @param {number} number 書き込む数値.\n * @param {number} n 書き込むビット数.\n * @param {boolean=} reverse 逆順に書き込むならば true.\n */\nZlib.BitStream.prototype.writeBits = function(number, n, reverse) {\n  var buffer = this.buffer;\n  var index = this.index;\n  var bitindex = this.bitindex;\n\n  /** @type {number} current octet. */\n  var current = buffer[index];\n  /** @type {number} loop counter. */\n  var i;\n\n  /**\n   * 32-bit 整数のビット順を逆にする\n   * @param {number} n 32-bit integer.\n   * @return {number} reversed 32-bit integer.\n   * @private\n   */\n  function rev32_(n) {\n    return (Zlib.BitStream.ReverseTable[n & 0xFF] << 24) |\n      (Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |\n      (Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |\n      Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];\n  }\n\n  if (reverse && n > 1) {\n    number = n > 8 ?\n      rev32_(number) >> (32 - n) :\n      Zlib.BitStream.ReverseTable[number] >> (8 - n);\n  }\n\n  // Byte 境界を超えないとき\n  if (n + bitindex < 8) {\n    current = (current << n) | number;\n    bitindex += n;\n  // Byte 境界を超えるとき\n  } else {\n    for (i = 0; i < n; ++i) {\n      current = (current << 1) | ((number >> n - i - 1) & 1);\n\n      // next byte\n      if (++bitindex === 8) {\n        bitindex = 0;\n        buffer[index++] = Zlib.BitStream.ReverseTable[current];\n        current = 0;\n\n        // expand\n        if (index === buffer.length) {\n          buffer = this.expandBuffer();\n        }\n      }\n    }\n  }\n  buffer[index] = current;\n\n  this.buffer = buffer;\n  this.bitindex = bitindex;\n  this.index = index;\n};\n\n\n/**\n * ストリームの終端処理を行う\n * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.\n */\nZlib.BitStream.prototype.finish = function() {\n  var buffer = this.buffer;\n  var index = this.index;\n\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output;\n\n  // bitindex が 0 の時は余分に index が進んでいる状態\n  if (this.bitindex > 0) {\n    buffer[index] <<= 8 - this.bitindex;\n    buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];\n    index++;\n  }\n\n  // array truncation\n  {\n    output = buffer.subarray(0, index);\n  }\n\n  return output;\n};\n\n/**\n * 0-255 のビット順を反転したテーブル\n * @const\n * @type {!(Uint8Array|Array.<number>)}\n */\nZlib.BitStream.ReverseTable = (function(table) {\n  return table;\n})((function() {\n  /** @type {!(Array|Uint8Array)} reverse table. */\n  var table = new ( Uint8Array )(256);\n  /** @type {number} loop counter. */\n  var i;\n\n  // generate\n  for (i = 0; i < 256; ++i) {\n    table[i] = (function(n) {\n      var r = n;\n      var s = 7;\n\n      for (n >>>= 1; n; n >>>= 1) {\n        r <<= 1;\n        r |= n & 1;\n        --s;\n      }\n\n      return (r << s & 0xff) >>> 0;\n    })(i);\n  }\n\n  return table;\n})());\n\n/**\n * CRC32 ハッシュ値を取得\n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.calc = function(data, pos, length) {\n  return Zlib.CRC32.update(data, 0, pos, length);\n};\n\n/**\n * CRC32ハッシュ値を更新\n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number} crc CRC32.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.update = function(data, crc, pos, length) {\n  var table = Zlib.CRC32.Table;\n  var i = (typeof pos === 'number') ? pos : (pos = 0);\n  var il = (typeof length === 'number') ? length : data.length;\n\n  crc ^= 0xffffffff;\n\n  // loop unrolling for performance\n  for (i = il & 7; i--; ++pos) {\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];\n  }\n  for (i = il >> 3; i--; pos += 8) {\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];\n  }\n\n  return (crc ^ 0xffffffff) >>> 0;\n};\n\n/**\n * @param {number} num\n * @param {number} crc\n * @returns {number}\n */\nZlib.CRC32.single = function(num, crc) {\n  return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;\n};\n\n/**\n * @type {Array.<number>}\n * @const\n * @private\n */\nZlib.CRC32.Table_ = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n];\n\n/**\n * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.\n * @const\n */\nZlib.CRC32.Table =   new Uint32Array(Zlib.CRC32.Table_) ;\n\n/**\n * @fileoverview Deflate (RFC1951) 実装.\n * Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.\n */\n\n/**\n * Zlib Deflate\n * @constructor\n * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Deflate = function(input, opt_params) {\n  /** @type {!(Array|Uint8Array)} */\n  this.input = input;\n  /** @type {!(Array|Uint8Array)} */\n  this.output =\n    new ( Uint8Array )(Zlib.Deflate.DefaultBufferSize);\n  /** @type {Zlib.Deflate.CompressionType} */\n  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;\n  /** @type {Zlib.RawDeflate} */\n  this.rawDeflate;\n  /** @type {Object} */\n  var rawDeflateOption = {};\n  /** @type {string} */\n  var prop;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n  }\n\n  // copy options\n  for (prop in opt_params) {\n    rawDeflateOption[prop] = opt_params[prop];\n  }\n\n  // set raw-deflate output buffer\n  rawDeflateOption['outputBuffer'] = this.output;\n\n  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);\n};\n\n/**\n * @const\n * @type {number} デフォルトバッファサイズ.\n */\nZlib.Deflate.DefaultBufferSize = 0x8000;\n\n/**\n * @enum {number}\n */\nZlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;\n\n/**\n * 直接圧縮に掛ける.\n * @param {!(Array|Uint8Array)} input target buffer.\n * @param {Object=} opt_params option parameters.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.compress = function(input, opt_params) {\n  return (new Zlib.Deflate(input, opt_params)).compress();\n};\n\n/**\n * Deflate Compression.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.prototype.compress = function() {\n  /** @type {Zlib.CompressionMethod} */\n  var cm;\n  /** @type {number} */\n  var cinfo;\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n  /** @type {number} */\n  var fcheck;\n  /** @type {number} */\n  var fdict;\n  /** @type {number} */\n  var flevel;\n  /** @type {number} */\n  var adler;\n  /** @type {!(Array|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var pos = 0;\n\n  output = this.output;\n\n  // Compression Method and Flags\n  cm = Zlib.CompressionMethod.DEFLATE;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  cmf = (cinfo << 4) | cm;\n  output[pos++] = cmf;\n\n  // Flags\n  fdict = 0;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      switch (this.compressionType) {\n        case Zlib.Deflate.CompressionType.NONE: flevel = 0; break;\n        case Zlib.Deflate.CompressionType.FIXED: flevel = 1; break;\n        case Zlib.Deflate.CompressionType.DYNAMIC: flevel = 2; break;\n        default: throw new Error('unsupported compression type');\n      }\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  flg = (flevel << 6) | (fdict << 5);\n  fcheck = 31 - (cmf * 256 + flg) % 31;\n  flg |= fcheck;\n  output[pos++] = flg;\n\n  // Adler-32 checksum\n  adler = Zlib.Adler32(this.input);\n\n  this.rawDeflate.op = pos;\n  output = this.rawDeflate.compress();\n  pos = output.length;\n\n  {\n    // subarray 分を元にもどす\n    output = new Uint8Array(output.buffer);\n    // expand buffer\n    if (output.length <= pos + 4) {\n      this.output = new Uint8Array(output.length + 4);\n      this.output.set(output);\n      output = this.output;\n    }\n    output = output.subarray(0, pos + 4);\n  }\n\n  // adler32\n  output[pos++] = (adler >> 24) & 0xff;\n  output[pos++] = (adler >> 16) & 0xff;\n  output[pos++] = (adler >>  8) & 0xff;\n  output[pos++] = (adler      ) & 0xff;\n\n  return output;\n};\n\nconst isNode =\n    typeof process !== 'undefined' &&\n    process.versions != null &&\n    process.versions.node != null;\n\n\nconst crossFetch = isNode ? require(\"node-fetch\") : fetch;\n\nclass BrowserLocalFile {\n\n    constructor(blob) {\n        this.file = blob;\n    }\n\n    async read(position, length) {\n\n        const file = this.file;\n\n        return new Promise(function (fullfill, reject) {\n\n            const fileReader = new FileReader();\n\n            fileReader.onload = function (e) {\n                fullfill(fileReader.result);\n            };\n\n            fileReader.onerror = function (e) {\n                console.err(\"Error reading local file \" + file.name);\n                reject(null, fileReader);\n            };\n\n            if (position !== undefined) {\n                const blob = file.slice(position, position + length);\n                fileReader.readAsArrayBuffer(blob);\n\n            } else {\n                fileReader.readAsArrayBuffer(file);\n\n            }\n\n        });\n    }\n}\n\nconst isNode$1 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\nlet fs;\nlet fsOpen;\nlet fsRead;\n\nif (isNode$1) {\n    const util = require('util');\n    fs = require('fs');\n    fsOpen = fs && util.promisify(fs.open);\n    fsRead = fs && util.promisify(fs.read);\n}\n\nclass NodeLocalFile {\n\n    constructor(args) {\n        this.path = args.path;\n    }\n\n\n    async read(position, length) {\n\n        const buffer = Buffer.alloc(length);\n        const fd = await fsOpen(this.path, 'r');\n        const result = await fsRead(fd, buffer, 0, length, position);\n\n        fs.close(fd, function (error) {\n            // TODO Do something with error\n        });\n\n        //TODO -- compare result.bytesRead with length\n        const b = result.buffer;\n        const arrayBuffer = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);\n        return arrayBuffer\n    }\n}\n\nconst  isNode$2 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\nclass RemoteFile {\n\n    constructor(args) {\n        this.config = args;\n        this.url = mapUrl(args.path || args.url);\n    }\n\n\n    async read(position, length) {\n\n        length = Math.ceil(length);\n        const headers = this.config.headers || {};\n        const rangeString = \"bytes=\" + position + \"-\" + (position + length - 1);\n        headers['Range'] = rangeString;\n\n        let url = this.url.slice();    // slice => copy\n        if (isNode$2) {\n            headers['User-Agent'] = 'straw';\n        } else {\n            if (this.config.oauthToken) {\n                const token = resolveToken(this.config.oauthToken);\n                headers['Authorization'] = `Bearer ${token}`;\n            }\n            const isSafari = navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent);\n            const isChrome = navigator.userAgent.indexOf('Chrome') > -1;\n            const isAmazonV4Signed = this.url.indexOf(\"X-Amz-Signature\") > -1;\n\n            if (isChrome && !isAmazonV4Signed) {\n                url = addParameter(url, \"randomSeed\", Math.random().toString(36));\n            }\n        }\n\n        if (this.config.apiKey) {\n            url = addParameter(url, \"key\", this.config.apiKey);\n        }\n\n        const response = await crossFetch(url, {\n            method: 'GET',\n            headers: headers,\n            redirect: 'follow',\n            mode: 'cors',\n\n        });\n\n        const status = response.status;\n\n        if (status >= 400) {\n            console.error(`${status}  ${this.config.url}`);\n            const err = Error(response.statusText);\n            err.code = status;\n            throw err\n        } else {\n            return response.arrayBuffer();\n        }\n\n        /**\n         * token can be a string, a function that returns a string, or a function that returns a Promise for a string\n         * @param token\n         * @returns {Promise<*>}\n         */\n        async function resolveToken(token) {\n            if (typeof token === 'function') {\n                return await Promise.resolve(token())    // Normalize the result to a promise, since we don't know what the function returns\n            } else {\n                return token\n            }\n        }\n\n    }\n}\n\n\nfunction mapUrl(url) {\n\n    if (url.includes(\"//www.dropbox.com\")) {\n        return url.replace(\"//www.dropbox.com\", \"//dl.dropboxusercontent.com\");\n    } else if (url.startsWith(\"ftp://ftp.ncbi.nlm.nih.gov\")) {\n        return url.replace(\"ftp://\", \"https://\")\n    } else {\n        return url\n    }\n}\n\n\nfunction addParameter(url, name, value) {\n    const paramSeparator = url.includes(\"?\") ? \"&\" : \"?\";\n    return url + paramSeparator + name + \"=\" + value;\n}\n\nclass ThrottledFile {\n\n    constructor(file, rateLimiter) {\n        this.file = file;\n        this.rateLimiter = rateLimiter;\n    }\n\n\n    async read(position, length) {\n\n        const file = this.file;\n        const rateLimiter = this.rateLimiter;\n\n        return new Promise(function (fulfill, reject) {\n            rateLimiter.limiter(async function (f) {\n                try {\n                    const result = await f.read(position, length);\n                    fulfill(result);\n                } catch (e) {\n                    reject(e);\n                }\n            })(file);\n        })\n    }\n}\n\nclass RateLimiter {\n\n    constructor(wait) {\n        this.wait = wait === undefined ? 100 : wait;\n\n        this.isCalled = false;\n        this.calls = [];\n    }\n\n\n    limiter(fn) {\n\n        const self = this;\n\n        let caller = function () {\n\n            if (self.calls.length && !self.isCalled) {\n                self.isCalled = true;\n                self.calls.shift().call();\n                setTimeout(function () {\n                    self.isCalled = false;\n                    caller();\n                }, self.wait);\n            }\n        };\n\n        return function () {\n            self.calls.push(fn.bind(this, ...arguments));\n            caller();\n        };\n    }\n\n}\n\nclass BufferedFile {\n\n    constructor(args) {\n        this.file = args.file;\n        this.size = args.size || 64000;\n        this.position = 0;\n        this.bufferStart = 0;\n        this.bufferLength = 0;\n        this.buffer = undefined;\n    }\n\n\n    async read(position, length) {\n\n        const start = position;\n        const end = position + length;\n        const bufferStart = this.bufferStart;\n        const bufferEnd = this.bufferStart + this.bufferLength;\n\n\n        if (length > this.size) {\n            // Request larger than max buffer size,  pass through to underlying file\n            //console.log(\"0\")\n            this.buffer = undefined;\n            this.bufferStart = 0;\n            this.bufferLength = 0;\n            return this.file.read(position, length)\n        }\n\n        if (start >= bufferStart && end <= bufferEnd) {\n            // Request within buffer bounds\n            //console.log(\"1\")\n            const sliceStart = start - bufferStart;\n            const sliceEnd = sliceStart + length;\n            return this.buffer.slice(sliceStart, sliceEnd)\n        }\n\n        else if (start < bufferStart && end > bufferStart) {\n            // Overlap left, here for completness but this is an unexpected case in straw.  We don't adjust the buffer.\n            //console.log(\"2\")\n            const l1 = bufferStart - start;\n            const a1 = await this.file.read(position, l1);\n            const l2 = length - l1;\n            if (l2 > 0) {\n                //this.buffer = await this.file.read(bufferStart, this.size)\n                const a2 = this.buffer.slice(0, l2);\n                return concatBuffers(a1, a2)\n            } else {\n                return a1\n            }\n\n        }\n\n        else if (start < bufferEnd && end > bufferEnd) {\n            // Overlap right\n            // console.log(\"3\")\n            const l1 = bufferEnd - start;\n            const sliceStart = this.bufferLength - l1;\n            const a1 = this.buffer.slice(sliceStart, this.bufferLength);\n\n            const l2 = length - l1;\n            if (l2 > 0) {\n                try {\n                    this.buffer = await this.file.read(bufferEnd, this.size);\n                    this.bufferStart = bufferEnd;\n                    this.bufferLength = this.buffer.byteLength;\n                    const a2 = this.buffer.slice(0, l2);\n                    return concatBuffers(a1, a2)\n                } catch (e) {\n                    // A \"unsatisfiable range\" error is expected here if we overlap past the end of file\n                    if (e.code && e.code === 416) {\n                        return a1\n                    }\n                    else {\n                        throw e\n                    }\n                }\n\n            } else {\n                return a1\n            }\n\n        }\n\n        else {\n            // No overlap with buffer\n            // console.log(\"4\")\n            this.buffer = await this.file.read(position, this.size);\n            this.bufferStart = position;\n            this.bufferLength = this.buffer.byteLength;\n            return this.buffer.slice(0, length)\n        }\n\n    }\n\n}\n\n/**\n * concatenates 2 array buffers.\n * Credit: https://gist.github.com/72lions/4528834\n *\n * @private\n * @param {ArrayBuffers} buffer1 The first buffer.\n * @param {ArrayBuffers} buffer2 The second buffer.\n * @return {ArrayBuffers} The new ArrayBuffer created out of the two.\n */\nvar concatBuffers = function (buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n};\n\n// TODO -- big endian\n\nconst BinaryParser = function (dataView, littleEndian) {\n\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n    this.position = 0;\n    this.view = dataView;\n    this.length = dataView.byteLength;\n};\n\nBinaryParser.prototype.available = function () {\n    return this.length - this.position;\n};\n\nBinaryParser.prototype.remLength = function () {\n    return this.length - this.position;\n};\n\nBinaryParser.prototype.hasNext = function () {\n    return this.position < this.length - 1;\n};\n\nBinaryParser.prototype.getByte = function () {\n    var retValue = this.view.getUint8(this.position, this.littleEndian);\n    this.position++;\n    return retValue;\n};\n\nBinaryParser.prototype.getShort = function () {\n\n    var retValue = this.view.getInt16(this.position, this.littleEndian);\n    this.position += 2;\n    return retValue;\n};\n\nBinaryParser.prototype.getUShort = function () {\n\n    // var byte1 = this.getByte(),\n    //     byte2 = this.getByte(),\n    //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\n    //     return retValue;\n\n    //\n    var retValue = this.view.getUint16(this.position, this.littleEndian);\n    this.position += 2;\n    return retValue;\n};\n\n\nBinaryParser.prototype.getInt = function () {\n\n    var retValue = this.view.getInt32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n};\n\n\nBinaryParser.prototype.getUInt = function () {\n    var retValue = this.view.getUint32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n};\n\nBinaryParser.prototype.getLong = function () {\n\n    // DataView doesn't support long. So we'll try manually\n\n    var b = [];\n    b[0] = this.view.getUint8(this.position);\n    b[1] = this.view.getUint8(this.position + 1);\n    b[2] = this.view.getUint8(this.position + 2);\n    b[3] = this.view.getUint8(this.position + 3);\n    b[4] = this.view.getUint8(this.position + 4);\n    b[5] = this.view.getUint8(this.position + 5);\n    b[6] = this.view.getUint8(this.position + 6);\n    b[7] = this.view.getUint8(this.position + 7);\n\n    var value = 0;\n    if (this.littleEndian) {\n        for (var i = b.length - 1; i >= 0; i--) {\n            value = (value * 256) + b[i];\n        }\n    } else {\n        for (var i = 0; i < b.length; i++) {\n            value = (value * 256) + b[i];\n        }\n    }\n\n\n    this.position += 8;\n    return value;\n};\n\nBinaryParser.prototype.getString = function (len) {\n\n    var s = \"\";\n    var c;\n    while ((c = this.view.getUint8(this.position++)) != 0) {\n        s += String.fromCharCode(c);\n        if (len && s.length == len) break;\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFixedLengthString = function (len) {\n\n    var s = \"\";\n    var i;\n    var c;\n    for (i = 0; i < len; i++) {\n        c = this.view.getUint8(this.position++);\n        if (c > 0) {\n            s += String.fromCharCode(c);\n        }\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFixedLengthTrimmedString = function (len) {\n\n    var s = \"\";\n    var i;\n    var c;\n    for (i = 0; i < len; i++) {\n        c = this.view.getUint8(this.position++);\n        if (c > 32) {\n            s += String.fromCharCode(c);\n        }\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFloat = function () {\n\n    var retValue = this.view.getFloat32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n\n\n};\n\nBinaryParser.prototype.getDouble = function () {\n\n    var retValue = this.view.getFloat64(this.position, this.littleEndian);\n    this.position += 8;\n    return retValue;\n};\n\nBinaryParser.prototype.skip = function (n) {\n\n    this.position += n;\n    return this.position;\n};\n\n\n/**\n * Return a bgzip (bam and tabix) virtual pointer\n * TODO -- why isn't 8th byte used ?\n * @returns {*}\n */\nBinaryParser.prototype.getVPointer = function () {\n\n    var position = this.position,\n        offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),\n        byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),\n        byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),\n        byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),\n        byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),\n        byte2 = ((this.view.getUint8(position + 2) & 0xff)),\n        block = byte6 + byte5 + byte4 + byte3 + byte2;\n    this.position += 8;\n\n    //       if (block == 0 && offset == 0) {\n    //           return null;\n    //       } else {\n    return new VPointer(block, offset);\n    //       }\n};\n\n\nfunction VPointer(block, offset) {\n    this.block = block;\n    this.offset = offset;\n}\n\nVPointer.prototype.isLessThan = function (vp) {\n    return this.block < vp.block ||\n        (this.block === vp.block && this.offset < vp.offset);\n};\n\nVPointer.prototype.isGreaterThan = function (vp) {\n    return this.block > vp.block ||\n        (this.block === vp.block && this.offset > vp.offset);\n};\n\nVPointer.prototype.print = function () {\n    return \"\" + this.block + \":\" + this.offset;\n};\n\nclass MatrixZoomData {\n\n    constructor(chr1, chr2) {\n\n        this.chr1 = chr1;    // chromosome index\n        this.chr2 = chr2;\n    }\n\n    getKey () {\n        return this.chr1.name + \"_\" + this.chr2.name + \"_\" + this.zoom.unit + \"_\" + this.zoom.binSize;\n    }\n\n    getBlockNumbers(region1, region2, version) {\n\n        // Verify region chromosomes and swap if neccessary\n        if(region1.chr == this.chr2 && region2.chr === this.chr1) {\n            const tmp = region1;\n            region1 = region2;\n            region2 = tmp;\n        }\n\n        const sameChr = this.chr1 === this.chr2;\n        const binsize = this.zoom.binSize;\n        const blockBinCount = this.blockBinCount;\n        const blockColumnCount = this.blockColumnCount;\n        return (version < 9 || !sameChr) ? getBlockNumbersV8() : getBlockNumbersV9();\n\n        function getBlockNumbersV8()\n        {\n            const x1 = region1.start / binsize;\n            const x2 = region1.end / binsize;\n            const y1 = region2.start / binsize;\n            const y2 = region2.end / binsize;\n\n            const col1 = Math.floor(x1 / blockBinCount);\n            const col2 = Math.floor((x2 - 1) / blockBinCount);\n            const row1 = Math.floor(y1 / blockBinCount);\n            const row2 = Math.floor((y2 - 1) / blockBinCount);\n\n            const blockNumbers = [];\n            for (let row = row1; row <= row2; row++) {\n                for (let column = col1; column <= col2; column++) {\n                    let blockNumber;\n                    if (sameChr && row < column) {\n                        blockNumber = column * blockColumnCount + row;\n                    } else {\n                        blockNumber = row * blockColumnCount + column;\n                    }\n                    if (!blockNumbers.includes(blockNumber)) {  // possible from transposition\n                        blockNumbers.push(blockNumber);\n                    }\n                }\n            }\n            return blockNumbers\n        }\n\n        function getBlockNumbersV9()\n        {\n\n            const binX1 = region1.start / binsize;\n            const binX2 = region1.end / binsize;\n            const binY1 = region2.start / binsize;\n            const binY2 = region2.end / binsize;\n\n            // PAD = positionAlongDiagonal (~projected)\n            // Depth is axis perpendicular to diagonal; nearer means closer to diagonal\n            const translatedLowerPAD = Math.floor((binX1 + binY1) / 2 / blockBinCount);\n            const translatedHigherPAD = Math.floor((binX2 + binY2) / 2 / blockBinCount);\n            const translatedNearerDepth = Math.floor(Math.log2(1 + Math.abs(binX1 - binY2) / Math.sqrt(2) / blockBinCount));\n            const translatedFurtherDepth = Math.floor(Math.log2(1 + Math.abs(binX2 - binY1) / Math.sqrt(2) / blockBinCount));\n\n            // because code above assume above diagonal; but we could be below diagonal\n            const containsDiagonal = (binX2 - binY1) * (binX1 - binY2) < 0;   // i.e. sign of (x-y) opposite on 2 corners\n            const nearerDepth = containsDiagonal ? 0 : Math.min(translatedNearerDepth, translatedFurtherDepth);\n            const furtherDepth = Math.max(translatedNearerDepth, translatedFurtherDepth);\n\n            const blockNumbers = [];\n            for (let depth = nearerDepth; depth <= furtherDepth; depth++) {\n                for (let pad = translatedLowerPAD; pad <= translatedHigherPAD; pad++) {\n                    const block_number = depth * blockColumnCount + pad;\n                    blockNumbers.push(block_number);\n                }\n            }\n            return blockNumbers\n        }\n    }\n\n    static parseMatrixZoomData(chr1, chr2, dis) {\n\n        const zd = new MatrixZoomData(chr1, chr2);\n\n        const unit = dis.getString();\n        const zoomIndex = dis.getInt();\n        const sumCounts = dis.getFloat();\n        const occupiedCellCount = dis.getFloat();\n        const stdDev = dis.getFloat();\n        const percent95 = dis.getFloat();\n        const binSize = dis.getInt();\n        zd. blockBinCount = dis.getInt();\n        zd. blockColumnCount = dis.getInt();\n        const nBlocks = dis.getInt();\n\n        zd. zoom = {index: zoomIndex, unit: unit, binSize: binSize};\n\n        zd.blockIndex = new StaticBlockIndex(nBlocks, dis);\n\n        const nBins1 = (chr1.size / binSize);\n        const nBins2 = (chr2.size / binSize);\n        const avgCount = (sumCounts / nBins1) / nBins2;   // <= trying to avoid overflows\n\n        zd.averageCount = avgCount;\n        zd.sumCounts = sumCounts;\n        zd.stdDev = stdDev;\n        zd.occupiedCellCount = occupiedCellCount;\n        zd.percent95 = percent95;\n\n        return zd;\n    }\n}\n\n\nclass StaticBlockIndex {\n\n    constructor(nBlocks, dis) {\n        this.blockIndex = {};\n        while (nBlocks-- > 0) {\n            const blockNumber = dis.getInt();\n            const filePosition = dis.getLong();\n            const size = dis.getInt();\n            this.blockIndex[blockNumber] = {filePosition, size};\n        }\n    }\n\n    getBlockIndexEntry(blockNumber) {\n        return this.blockIndex[blockNumber];\n    }\n}\n\nclass Matrix {\n\n    constructor(chr1, chr2, zoomDataList) {\n        this.chr1 = chr1;\n        this.chr2 = chr2;\n        this.bpZoomData = [];\n        this.fragZoomData = [];\n        for (let zd of zoomDataList) {\n            if (zd.zoom.unit === \"BP\") {\n                this.bpZoomData.push(zd);\n            } else {\n                this.fragZoomData.push(zd);\n            }\n        }\n    }\n\n    /**\n     * Find the best zoom level for the given bin size\n     * @param binSize\n     * @param unit\n     * @returns {number}\n     */\n    findZoomForResolution(binSize, unit) {\n        const zdArray = \"FRAG\" === unit ? this.fragZoomData : this.bpZoomData;\n        for (let i = 1; i < zdArray.length; i++) {\n            var zd = zdArray[i];\n            if (zd.zoom.binSize < binSize) {\n                return i - 1\n            }\n        }\n        return zdArray.length - 1\n    }\n\n    /**\n     * Fetch zoom data by bin size.  If no matching level exists return undefined.\n     *\n     * @param unit\n     * @param binSize\n     * @param zoom\n     * @returns {undefined|*}\n     */\n    getZoomData(binSize, unit) {\n        unit = unit || \"BP\";\n        const zdArray = unit === \"BP\" ? this.bpZoomData : this.fragZoomData;\n        for (let i = 0; i < zdArray.length; i++) {\n            var zd = zdArray[i];\n            if (binSize === zd.zoom.binSize) {\n                return zd\n            }\n        }\n        return undefined\n    }\n\n    /**\n     * Return zoom data by resolution index.\n     * @param index\n     * @param unit\n     * @returns {*}\n     */\n    getZoomDataByIndex(index, unit) {\n        const zdArray = \"FRAG\" === unit ? this.fragZoomData : this.bpZoomData;\n        return zdArray[index]\n    }\n\n    static getKey(chrIdx1, chrIdx2) {\n        if (chrIdx1 > chrIdx2) {\n            const tmp = chrIdx1;\n            chrIdx1 = chrIdx2;\n            chrIdx2 = tmp;\n        }\n        return `${chrIdx1}_${chrIdx2}`;\n    }\n\n    static parseMatrix(data, chromosomes) {\n\n        const dis = new BinaryParser(new DataView(data));\n        const c1 = dis.getInt();     // Should equal chrIdx1\n        const c2 = dis.getInt();     // Should equal chrIdx2\n\n        // TODO validate this\n        const chr1 = chromosomes[c1];\n        const chr2 = chromosomes[c2];\n\n        // # of resolution levels (bp and frags)\n        let nResolutions = dis.getInt();\n        const zdList = [];\n\n        while (nResolutions-- > 0) {\n            const zd = MatrixZoomData.parseMatrixZoomData(chr1, chr2, dis);\n            zdList.push(zd);\n        }\n        return new Matrix(c1, c2, zdList);\n    }\n\n}\n\nclass ContactRecord {\n\n    constructor(bin1, bin2, counts) {\n        this.bin1 = bin1;\n        this.bin2 = bin2;\n        this.counts = counts;\n    };\n\n    getKey() {\n        return \"\" + this.bin1 + \"_\" + this.bin2;\n    }\n}\n\nclass LRU {\n    constructor(max = 10) {\n        this.max = max;\n        this.map = new Map();\n    }\n\n    get(key) {\n        let item = this.map.get(key);\n        if (item) {\n            // refresh key\n            this.map.delete(key);\n            this.map.set(key, item);\n        }\n        return item;\n    }\n\n    set(key, val) {\n        // refresh key\n        if (this.map.has(key)) this.map.delete(key);\n        // evict oldest\n        else if (this.map.size === this.max) {\n            this.map.delete(this.first());\n        }\n        this.map.set(key, val);\n    }\n\n    has(key) {\n        return this.map.has(key);\n    }\n\n    clear() {\n        this.map.clear();\n    }\n\n    first() {\n        return this.map.keys().next().value;\n    }\n}\n\n/*\n *  The MIT License (MIT)\n *\n * Copyright (c) 2016-2017 The Regents of the University of California\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n * associated documentation files (the \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\nconst DOUBLE = 8;\n\nclass NormalizationVector {\n\n    constructor(file, filePosition, nValues, dataType) {\n        this.file = file;\n        this.filePosition = filePosition;\n        this.nValues = nValues;\n        this.dataType = dataType;\n        this.cache = undefined;\n    }\n\n    async getValues(start, end) {\n\n        if(!this.cache || start < this.cache.start || end > this.cache.end) {\n            const adjustedStart = Math.max(0, start - 1000);\n            const adjustedEnd = Math.min(this.nValues, end + 1000);\n            const startPosition = this.filePosition + adjustedStart * this.dataType;\n            const n = adjustedEnd - adjustedStart;\n            const sizeInBytes = n  * this.dataType;\n            const data = await this.file.read(startPosition, sizeInBytes);\n            if (!data) {\n                return undefined;\n            }\n            const parser = new BinaryParser(new DataView(data));\n\n            const values = [];\n            for (let i = 0; i < n; i++) {\n                values[i] = this.dataType === DOUBLE ? parser.getDouble() : parser.getFloat();\n\n            }\n            this.cache = {\n                start: adjustedStart,\n                end: adjustedEnd,\n                values: values\n            };\n        }\n\n        const sliceStart = start - this.cache.start;\n        const sliceEnd = sliceStart + (end - start);\n        return this.cache.values.slice(sliceStart, sliceEnd);\n    }\n\n    getKey() {\n        return NormalizationVector.getKey(this.type, this.chrIdx, this.unit, this.resolution);\n    }\n\n\n    static getNormalizationVectorKey(type, chrIdx, unit, resolution) {\n        return type + \"_\" + chrIdx + \"_\" + unit + \"_\" + resolution;\n    }\n}\n\nconst isNode$3 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\nconst Short_MIN_VALUE = -32768;\nconst DOUBLE$1 = 8;\nconst FLOAT = 4;\nconst INT = 4;\nconst GoogleRateLimiter = new RateLimiter(100);\n\n\nclass HicFile {\n\n    constructor(args) {\n\n        this.config = args;\n\n        this.loadFragData = args.loadFragData;\n        this.fragmentSitesCache = {};\n        this.normVectorCache = new LRU(10);\n        this.normalizationTypes = ['NONE'];\n        this.matrixCache = new LRU(10);\n        this.blockCache = new BlockCache();\n\n        // args may specify an io.File object, a local path (Node only), or a url\n        if (args.file) {\n            this.file = args.file;\n        } else if (args.blob) {\n            this.file = new BrowserLocalFile(args.blob);\n        } else if (args.url || (args.path && !isNode$3)) {\n            this.url = args.url || this.path;\n            this.remote = true;\n\n            // Google drive must be rate limited.  Perhaps all remote files should be rate limited?\n            const remoteFile = new RemoteFile(args);\n            if (isGoogleDrive(this.url)) {\n                this.file = new ThrottledFile(remoteFile, GoogleRateLimiter);\n            } else {\n                this.file = remoteFile;\n            }\n        } else if (args.path) {\n            // path argument, assumed local file\n            this.file = new NodeLocalFile({path: args.path});\n\n        } else {\n            throw Error(\"Arguments must include file, blob, url, or path\")\n        }\n    }\n\n\n    async init() {\n\n        if (this.initialized) {\n            return;\n        } else {\n            await this.readHeaderAndFooter();\n            // Footer is read with header\n            //await this.readFooter()\n            this.initialized = true;\n        }\n    }\n\n    async getVersion() {\n        if (this.version === undefined) {\n            const data = await this.file.read(0, 128);\n            if (!data) {\n                return undefined;\n            }\n            const binaryParser = new BinaryParser(new DataView(data));\n            this.magic = binaryParser.getString();\n            this.version = binaryParser.getInt();\n            return this.version\n        } else {\n            return this.version\n        }\n    }\n\n    async getMetaData() {\n        await this.init();\n        return this.meta\n    }\n\n    async readHeaderAndFooter() {\n\n        // Read initial fields magic, version, and footer position\n        let data = await this.file.read(0, 16);\n        if (!data || data.byteLength === 0) {\n            throw Error(\"File content is empty\")\n        }\n        let binaryParser = new BinaryParser(new DataView(data));\n        this.magic = binaryParser.getString();\n        this.version = binaryParser.getInt();\n        if (this.version < 5) {\n            throw Error(\"Unsupported hic version: \" + this.version)\n        }\n        this.footerPosition = binaryParser.getLong();\n\n        // Read footer and determine file position for body section (i.e. end of header)\n\n        await this.readFooter();\n\n        const bodyPostion = Object.values(this.masterIndex).reduce((min, currentValue) => {\n            return Math.min(min, currentValue.start)\n        }, Number.MAX_VALUE);\n\n        const remainingSize = bodyPostion - 16;\n        data = await this.file.read(16, remainingSize);\n        binaryParser = new BinaryParser(new DataView(data));\n\n        this.genomeId = binaryParser.getString();\n\n        if (this.version >= 9) {\n            this.normVectorIndexPosition = binaryParser.getLong();\n            this.normVectorIndexSize = binaryParser.getLong();\n        }\n\n        this.attributes = {};\n        let nAttributes = binaryParser.getInt();\n        while (nAttributes-- > 0) {\n            this.attributes[binaryParser.getString()] = binaryParser.getString();\n        }\n\n        this.chromosomes = [];\n        this.chromosomeIndexMap = {};\n        let nChrs = binaryParser.getInt();\n        let i = 0;\n        while (nChrs-- > 0) {\n            const chr = {\n                index: i,\n                name: binaryParser.getString(),\n                size: this.version < 9 ? binaryParser.getInt() : binaryParser.getLong()\n            };\n            if (chr.name.toLowerCase() === \"all\") {\n                this.wholeGenomeChromosome = chr;\n                this.wholeGenomeResolution = Math.round(chr.size * (1000 / 500));    // Hardcoded in juicer\n            }\n            this.chromosomes.push(chr);\n            this.chromosomeIndexMap[chr.name] = chr.index;\n            i++;\n        }\n\n        this.bpResolutions = [];\n        let nBpResolutions = binaryParser.getInt();\n        while (nBpResolutions-- > 0) {\n            this.bpResolutions.push(binaryParser.getInt());\n        }\n\n        if (this.loadFragData) {\n            this.fragResolutions = [];\n            let nFragResolutions = binaryParser.getInt();\n            if (nFragResolutions > 0) {\n                while (nFragResolutions-- > 0) {\n                    this.fragResolutions.push(binaryParser.getInt());\n                }\n\n                // this.sites = [];\n                // for(let i=0; i<this.chromosomes.length - 1; i++) {\n                //     const chrSites = [];\n                //     this.sites.push(chrSites);\n                //     let nSites = binaryParser.getInt();\n                //     console.log(nSites);\n                //     for(let s=0; s<nSites; s++) {\n                //         chrSites.push(binaryParser.getInt());\n                //     }\n                // }\n            }\n        }\n\n        // Build lookup table for well-known chr aliases\n        this.chrAliasTable = {};\n        for (let chrName of Object.keys(this.chromosomeIndexMap)) {\n\n            if (chrName.startsWith(\"chr\")) {\n                this.chrAliasTable[chrName.substr(3)] = chrName;\n            } else if (chrName === \"MT\") {\n                this.chrAliasTable[\"chrM\"] = chrName;\n            } else {\n                this.chrAliasTable[\"chr\" + chrName] = chrName;\n            }\n        }\n\n\n        // Meta data for the API\n        this.meta = {\n            \"version\": this.version,\n            \"genome\": this.genomeId,\n            \"chromosomes\": this.chromosomes,\n            \"resolutions\": this.bpResolutions,\n        };\n\n\n    }\n\n    async readFooter() {\n\n\n        const skip = this.version < 9 ? 8 : 12;\n        let data = await this.file.read(this.footerPosition, skip);\n        if (!data) {\n            return null;\n        }\n\n        let binaryParser = new BinaryParser(new DataView(data));\n        const nBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();  // Total size, master index + expected values\n        let nEntries = binaryParser.getInt();\n\n        // Estimate the size of the master index. String length of key is unknown, be conservative (100 bytes)\n\n        const miSize = nEntries * (100 + 64 + 32);\n        data = await this.file.read(this.footerPosition + skip, Math.min(miSize, nBytes));\n\n        binaryParser = new BinaryParser(new DataView(data));\n\n        this.masterIndex = {};\n        while (nEntries-- > 0) {\n            const key = binaryParser.getString();\n            const pos = binaryParser.getLong();\n            const size = binaryParser.getInt();\n            this.masterIndex[key] = {start: pos, size: size};\n        }\n\n        this.expectedValueVectors = {};\n\n        // Expected values\n        // const nExpValues = binaryParser.readInt();\n        // while (nExpValues-- > 0) {\n        //     type = \"NONE\";\n        //     unit = binaryParser.getString();\n        //     binSize = binaryParser.getInt();\n        //     nValues = binaryParser.getInt();\n        //     values = [];\n        //     while (nValues-- > 0) {\n        //         values.push(binaryParser.getDouble());\n        //     }\n        //\n        //     nChrScaleFactors = binaryParser.getInt();\n        //     normFactors = {};\n        //     while (nChrScaleFactors-- > 0) {\n        //         normFactors[binaryParser.getInt()] = binaryParser.getDouble();\n        //     }\n        //\n        //     // key = unit + \"_\" + binSize + \"_\" + type;\n        //     //  NOT USED YET SO DON'T STORE\n        //     //  dataset.expectedValueVectors[key] =\n        //     //      new ExpectedValueFunction(type, unit, binSize, values, normFactors);\n        // }\n\n        // normalized expected values start after expected value.  Add 4 for\n        if (this.version > 5) {\n            const skip = this.version < 9 ? 4 : 8;\n            this.normExpectedValueVectorsPosition = this.footerPosition + skip + nBytes;\n        }\n        return this;\n    };\n\n    async printIndexStats() {\n\n        let totalSize = 0;\n        let maxSize = 0;\n        await await this.init();\n        for (let key of Object.keys(this.masterIndex)) {\n            const entry = this.masterIndex[key];\n            //  console.log(`${key}\\t${entry.start}\\t${entry.size}`)\n            totalSize += entry.size;\n            if (entry.size > maxSize) {\n                maxSize = entry.size;\n            }\n        }\n        // console.log(`Total size  = ${totalSize}`);\n    }\n\n    async getMatrix(chrIdx1, chrIdx2) {\n        const key = Matrix.getKey(chrIdx1, chrIdx2);\n        if (this.matrixCache.has(key)) {\n            return this.matrixCache.get(key);\n        } else {\n            const matrix = await this.readMatrix(chrIdx1, chrIdx2);\n            this.matrixCache.set(key, matrix);\n            return matrix;\n        }\n    }\n\n    async readMatrix(chrIdx1, chrIdx2) {\n\n        await this.init();\n\n        if (chrIdx1 > chrIdx2) {\n            const tmp = chrIdx1;\n            chrIdx1 = chrIdx2;\n            chrIdx2 = tmp;\n        }\n\n        const key = Matrix.getKey(chrIdx1 , chrIdx2);\n        const idx = this.masterIndex[key];\n        if (!idx) {\n            return undefined\n        }\n        const data = await this.file.read(idx.start, idx.size);\n        if (!data) {\n            return undefined\n        }\n\n        return Matrix.parseMatrix(data, this.chromosomes);\n\n    }\n\n    async getContactRecords(normalization, region1, region2, units, binsize, allRecords = false) {\n\n        await this.init();\n\n        const idx1 = this.chromosomeIndexMap[this.getFileChrName(region1.chr)];\n        const idx2 = this.chromosomeIndexMap[this.getFileChrName(region2.chr)];\n\n        const transpose = (idx1 > idx2) || (idx1 === idx2 && region1.start >= region2.end);\n        if (transpose) {\n            const tmp = region1;\n            region1 = region2;\n            region2 = tmp;\n        }\n\n        const blocks = await this.getBlocks(region1, region2, units, binsize);\n        if (!blocks || blocks.length === 0) {\n            return []\n        }\n\n        const contactRecords = [];\n        const x1 = region1.start / binsize;\n        const x2 = region1.end / binsize;\n        const y1 = region2.start / binsize;\n        const y2 = region2.end / binsize;\n        const nvX1 = Math.floor(x1);\n        const nvX2 = Math.ceil(x2);\n        const nvY1 = Math.floor(y1);\n        const nvY2 = Math.ceil(y2);\n        for (let block of blocks) {\n            if (block) { // An undefined block is most likely caused by a base pair range outside the chromosome\n                let normVector1;\n                let normVector2;\n                let isNorm = normalization && normalization !== \"NONE\";\n                const chr1 = this.getFileChrName(region1.chr);\n                const chr2 = this.getFileChrName(region2.chr);\n                if (isNorm) {\n                    const nv1 = await this.getNormalizationVector(normalization, chr1, units, binsize);\n                    const nv2 = (chr1 === chr2) ? nv1 : await this.getNormalizationVector(normalization, chr2, units, binsize);\n\n                    if (nv1 && nv2) {\n                        normVector1 = await nv1.getValues(nvX1, nvX2);\n                        normVector2 = await nv2.getValues(nvY1, nvY2);\n                    } else {\n                        isNorm = false;\n                        // Raise message and switch pulldown\n                    }\n                }\n\n                for (let rec of block.records) {\n                    if (allRecords || (rec.bin1 >= x1 && rec.bin1 < x2 && rec.bin2 >= y1 && rec.bin2 < y2)) {\n                        if (isNorm) {\n                            const x = rec.bin1;\n                            const y = rec.bin2;\n                            const nvnv = normVector1[x - nvX1] * normVector2[y - nvY1];\n                            if (nvnv !== 0 && !isNaN(nvnv)) {\n                                const counts = rec.counts / nvnv;\n                                contactRecords.push(new ContactRecord(x, y, counts));\n                            }\n                        } else {\n                            contactRecords.push(rec);\n                        }\n                    }\n                }\n            }\n        }\n\n        return contactRecords;\n    }\n\n    async getBlocks(region1, region2, unit, binSize) {\n\n        await this.init();\n        const chr1 = this.getFileChrName(region1.chr);\n        const chr2 = this.getFileChrName(region2.chr);\n        const idx1 = this.chromosomeIndexMap[chr1];\n        const idx2 = this.chromosomeIndexMap[chr2];\n\n        if (idx1 === undefined) {\n            return []\n        }\n        if (idx2 === undefined) {\n            return []\n        }\n\n        const matrix = await this.getMatrix(idx1, idx2);\n        if (!matrix) {\n            return []\n        }\n\n        const zd = matrix.getZoomData(binSize, unit);\n        if (!zd) {\n            let msg = `No data avalailble for resolution: ${binSize}  for map ${region1.chr}-${region2.chr}`;\n            throw new Error(msg)\n        }\n\n        const blockNumbers = zd.getBlockNumbers(region1, region2, this.version);\n\n        const blocks = [];\n        const blockNumbersToQuery = [];\n        for (let num of blockNumbers) {\n            if (this.blockCache.has(binSize, num)) {\n                blocks.push(this.blockCache.get(binSize, num));\n            } else {\n                blockNumbersToQuery.push(num);\n            }\n        }\n\n        const promises = blockNumbersToQuery.map(blockNumber => this.readBlock(blockNumber, zd));\n        const newBlocks = await Promise.all(promises);\n        for (let block of newBlocks) {\n            if (block) {\n                this.blockCache.set(binSize, block.blockNumber, block);\n            }\n        }\n        return blocks.concat(newBlocks);\n    }\n\n    async readBlock(blockNumber, zd) {\n\n        const idx = await zd.blockIndex.getBlockIndexEntry(blockNumber);\n\n        if (!idx) {\n            return undefined\n        } else {\n            let data = await this.file.read(idx.filePosition, idx.size);\n            if (!data) {\n                return undefined;\n            }\n\n            const inflate = new Zlib.Inflate(new Uint8Array(data));\n            const plain = inflate.decompress();\n            //var plain = zlib.inflateSync(Buffer.from(data))   //.decompress();\n            data = plain.buffer;\n\n            const parser = new BinaryParser(new DataView(data));\n            const nRecords = parser.getInt();\n            const records = [];\n\n            if (this.version < 7) {\n                for (let i = 0; i < nRecords; i++) {\n                    const binX = parser.getInt();\n                    const binY = parser.getInt();\n                    const counts = parser.getFloat();\n                    records.push(new ContactRecord(binX, binY, counts));\n                }\n            } else {\n\n                const binXOffset = parser.getInt();\n                const binYOffset = parser.getInt();\n\n                const useFloatContact = parser.getByte() === 1;\n                const useIntXPos = this.version < 9 ? false : parser.getByte() == 1;\n                const useIntYPos = this.version < 9 ? false : parser.getByte() == 1;\n                const type = parser.getByte();\n\n                if (type === 1) {\n                    // List-of-rows representation\n                    const rowCount = useIntYPos ? parser.getInt() : parser.getShort();\n                    for (let i = 0; i < rowCount; i++) {\n                        const dy = useIntYPos ? parser.getInt() : parser.getShort();\n                        const binY = binYOffset + dy;\n                        const colCount = useIntXPos ? parser.getInt() : parser.getShort();\n                        for (let j = 0; j < colCount; j++) {\n                            const dx = useIntXPos ? parser.getInt() : parser.getShort();\n                            const binX = binXOffset + dx;\n                            const counts = useFloatContact ? parser.getFloat() : parser.getShort();\n                            records.push(new ContactRecord(binX, binY, counts));\n                        }\n                    }\n                } else if (type == 2) {\n\n                    const nPts = parser.getInt();\n                    const w = parser.getShort();\n\n                    for (let i = 0; i < nPts; i++) {\n                        //int idx = (p.y - binOffset2) * w + (p.x - binOffset1);\n                        const row = Math.floor(i / w);\n                        const col = i - row * w;\n                        const bin1 = binXOffset + col;\n                        const bin2 = binYOffset + row;\n\n                        if (useFloatContact) {\n                            const counts = parser.getFloat();\n                            if (!isNaN(counts)) {\n                                records.push(new ContactRecord(bin1, bin2, counts));\n                            }\n                        } else {\n                            const counts = parser.getShort();\n                            if (counts != Short_MIN_VALUE) {\n                                records.push(new ContactRecord(bin1, bin2, counts));\n                            }\n                        }\n                    }\n                } else {\n                    throw new Error(\"Unknown block type: \" + type);\n                }\n\n            }\n\n            return new Block(blockNumber, zd, records, idx);\n\n\n        }\n    };\n\n    async hasNormalizationVector(type, chr, unit, binSize) {\n        await this.init();\n        let chrIdx;\n        if (Number.isInteger(chr)) {\n            chrIdx = chr;\n        } else {\n            const canonicalName = this.getFileChrName(chr);\n            chrIdx = this.chromosomeIndexMap[canonicalName];\n        }\n        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);\n        const normVectorIndex = await this.getNormVectorIndex();\n        return normVectorIndex && normVectorIndex[key];\n    }\n\n    async getNormalizationVector(type, chr, unit, binSize) {\n\n        await this.init();\n\n        let chrIdx;\n        if (Number.isInteger(chr)) {\n            chrIdx = chr;\n        } else {\n            const canonicalName = this.getFileChrName(chr);\n            chrIdx = this.chromosomeIndexMap[canonicalName];\n        }\n\n        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);\n\n        if (this.normVectorCache.has(key)) {\n            return this.normVectorCache.get(key);\n        }\n\n        const normVectorIndex = await this.getNormVectorIndex();\n\n        if (!normVectorIndex) {\n            return undefined\n        }\n\n        const idx = normVectorIndex[key];\n        if (!idx) {\n            // TODO -- alert in browsers\n            return undefined;\n        }\n\n        const data = await this.file.read(idx.filePosition, 8);\n\n        if (!data) {\n            return undefined;\n        }\n\n        const parser = new BinaryParser(new DataView(data));\n        const nValues = this.version < 9 ? parser.getInt() : parser.getLong();\n        const dataType = this.version < 9 ? DOUBLE$1 : FLOAT;\n        const filePosition = this.version < 9 ? idx.filePosition + 4 : idx.filePosition + 8;\n        const nv = new NormalizationVector(this.file, filePosition, nValues, dataType);\n        this.normVectorCache.set(key, nv);\n        return nv;\n\n    }\n\n    async getNormVectorIndex() {\n\n        if (this.version < 6) {\n            return undefined;\n        }\n\n        if (!this.normVectorIndex) {\n\n            // If nvi is not supplied, try reading from remote lambda service\n            if (!this.config.nvi && this.remote && this.url) {\n                const url = new URL(this.url);\n                const key = encodeURIComponent(url.hostname + url.pathname);\n                const nviResponse = await crossFetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);\n                if (nviResponse.status === 200) {\n                    const nvi = await nviResponse.text();\n                    if (nvi) {\n                        this.config.nvi = nvi;\n                    }\n                }\n            }\n\n            if (this.config.nvi) {\n                const nviArray = decodeURIComponent(this.config.nvi).split(\",\");\n                const range = {start: parseInt(nviArray[0]), size: parseInt(nviArray[1])};\n                return this.readNormVectorIndex(range)\n            } else {\n                try {\n                    await this.readNormExpectedValuesAndNormVectorIndex();\n                    return this.normVectorIndex\n                } catch (e) {\n                    if (e.code === \"416\" || e.code === 416) {\n                        // This is expected if file does not contain norm vectors\n                        this.normExpectedValueVectorsPosition = undefined;\n                    } else {\n                        console.error(e);\n                    }\n                }\n            }\n        }\n\n        return this.normVectorIndex\n    }\n\n    async getNormalizationOptions() {\n        // Normalization options are computed as a side effect of loading the index.  A bit\n        // ugly but alternatives are worse.\n        await this.getNormVectorIndex();\n        return this.normalizationTypes;\n    }\n\n    /**\n     * Return a promise to load the normalization vector index\n     *\n     * @param dataset\n     * @param range  -- file range {position, size}\n     * @returns Promise for the normalization vector index\n     */\n    async readNormVectorIndex(range) {\n\n        await this.init();\n\n        this.normalizationVectorIndexRange = range;\n\n        const data = await this.file.read(range.start, range.size);\n\n        const binaryParser = new BinaryParser(new DataView(data));\n\n        this.normVectorIndex = {};\n\n        let nEntries = binaryParser.getInt();\n        while (nEntries-- > 0) {\n            this.parseNormVectorEntry(binaryParser);\n        }\n\n        return this.normVectorIndex;\n\n    }\n\n    /**\n     * This function is used when the position of the norm vector index is unknown.  We must read through the expected\n     * values to find the index\n     *\n     * @param dataset\n     * @returns {Promise}\n     */\n    async readNormExpectedValuesAndNormVectorIndex() {\n\n        await this.init();\n\n        if (this.normExpectedValueVectorsPosition === undefined) {\n            return;\n        }\n\n        const nviStart = await this.skipExpectedValues(this.normExpectedValueVectorsPosition);\n        let byteCount = INT;\n\n        let data = await this.file.read(nviStart, INT);\n        if (data.byteLength === 0) {\n            // This is possible if there are no norm vectors.  Its a legal v8 file, though uncommon\n            return;\n        }\n        const binaryParser = new BinaryParser(new DataView(data));\n        const nEntries = binaryParser.getInt();\n        const sizeEstimate = nEntries * 30;\n        const range = {start: nviStart + byteCount, size: sizeEstimate};\n\n        data = await this.file.read(range.start, range.size);\n        this.normalizedExpectedValueVectors = {};\n        this.normVectorIndex = {};\n\n        // Recursively process entries\n        await processEntries.call(this, nEntries, data);\n\n        this.config.nvi = nviStart.toString() + \",\" + byteCount;\n\n        async function processEntries(nEntries, data) {\n\n            const binaryParser = new BinaryParser(new DataView(data));\n\n            while (nEntries-- > 0) {\n\n                if (binaryParser.available() < 100) {\n\n                    nEntries++;   // Reset counter as entry is not processed\n\n                    byteCount += binaryParser.position;\n                    const sizeEstimate = Math.max(1000, nEntries * 30);\n                    const range = {start: nviStart + byteCount, size: sizeEstimate};\n                    const data = await this.file.read(range.start, range.size);\n                    return processEntries.call(this, nEntries, data);\n                }\n\n                this.parseNormVectorEntry(binaryParser);\n\n            }\n            byteCount += binaryParser.position;\n        }\n    }\n\n    /**\n     * This function is used when the position of the norm vector index is unknown.  We must read through the\n     * normalized expected values to find the index\n     *\n     * @param dataset\n     * @returns {Promise}\n     */\n    async skipExpectedValues(start) {\n\n        const version = this.version;\n        const file = new BufferedFile({file: this.file, size: 256000});\n        const range = {start: start, size: INT};\n        const data = await file.read(range.start, range.size);\n        const binaryParser = new BinaryParser(new DataView(data));\n        const nEntries = binaryParser.getInt();   // Total # of expected value chunks\n        if (nEntries === 0) {\n            return start + INT;\n        } else {\n            return parseNext(start + INT, nEntries);\n        }     // Skip 4 bytes for int\n\n\n        async function parseNext(start, nEntries) {\n\n            let range = {start: start, size: 500};\n            let chunkSize = 0;\n            let p0 = start;\n\n            let data = await file.read(range.start, range.size);\n            let binaryParser = new BinaryParser(new DataView(data));\n            const type = binaryParser.getString(); // type\n            const unit = binaryParser.getString(); // unit\n            const binSize = binaryParser.getInt(); // binSize\n            const nValues = version < 9 ? binaryParser.getInt() : binaryParser.getLong();\n\n            chunkSize += binaryParser.position + nValues * (version < 9 ? DOUBLE$1 : FLOAT);\n\n            range = {start: start + chunkSize, size: INT};\n            data = await file.read(range.start, range.size);\n            binaryParser = new BinaryParser(new DataView(data));\n            const nChrScaleFactors = binaryParser.getInt();\n            chunkSize += (INT + nChrScaleFactors * (INT + (version < 9 ? DOUBLE$1 : FLOAT)));\n\n\n            nEntries--;\n            if (nEntries === 0) {\n                return p0 + chunkSize;\n            } else {\n                return parseNext(p0 + chunkSize, nEntries);\n            }\n        }\n    }\n\n    getZoomIndexForBinSize(binSize, unit) {\n\n        unit = unit || \"BP\";\n\n        let resolutionArray;\n        if (unit === \"BP\") {\n            resolutionArray = this.bpResolutions;\n        } else if (unit === \"FRAG\") {\n            resolutionArray = this.fragResolutions;\n        } else {\n            throw new Error(\"Invalid unit: \" + unit);\n        }\n\n        for (let i = 0; i < resolutionArray.length; i++) {\n            if (resolutionArray[i] === binSize) return i;\n        }\n\n        return -1;\n    }\n\n    parseNormVectorEntry(binaryParser) {\n        const type = binaryParser.getString();      //15\n        const chrIdx = binaryParser.getInt();       //4\n        const unit = binaryParser.getString();      //3\n        const binSize = binaryParser.getInt();      //4\n        const filePosition = binaryParser.getLong();  //8\n        const sizeInBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();     //4:8\n        const key = type + \"_\" + chrIdx + \"_\" + unit + \"_\" + binSize;\n        // TODO -- why does this not work?  NormalizationVector.getNormalizationVectorKey(type, chrIdx, unit, binSize);\n\n        if (!this.normalizationTypes.includes(type)) {\n            this.normalizationTypes.push(type);\n        }\n        this.normVectorIndex[key] = {filePosition: filePosition, size: sizeInBytes};\n    }\n\n    getFileChrName(chrAlias) {\n        if (this.chrAliasTable.hasOwnProperty(chrAlias)) {\n            return this.chrAliasTable[chrAlias]\n        } else {\n            return chrAlias\n        }\n    }\n\n\n    // NOTE sties are not currently used\n    // async getSites(chrName) {\n    //     let sites = this.fragmentSitesCache[chrName];\n    //     if (!sites) {\n    //         if (this.fragmentSitesIndex) {\n    //             const entry = self.fragmentSitesIndex[chrName];\n    //             if (entry && entry.nSites > 0) {\n    //                 sites = await this.readSites(entry.position, entry.nSites)\n    //                 this.fragmentSitesCache[chrName] = sites;\n    //             }\n    //         }\n    //     }\n    //     return sites;\n    // }\n    //\n\n}\n\n\nfunction getNormalizationVectorKey(type, chrIdx, unit, resolution) {\n    return type + \"_\" + chrIdx + \"_\" + unit + \"_\" + resolution;\n}\n\nfunction isGoogleDrive(url) {\n    return url.indexOf(\"drive.google.com\") >= 0 || url.indexOf(\"www.googleapis.com/drive\") > 0\n}\n\nclass Block {\n    constructor(blockNumber, zoomData, records, idx) {\n        this.blockNumber = blockNumber;\n        this.zoomData = zoomData;\n        this.records = records;\n        this.idx = idx;\n    }\n}\n\n\nclass BlockCache {\n\n    constructor() {\n        this.resolution = undefined;\n        this.map = new LRU(6);\n    }\n\n    set(resolution, key, value) {\n        if (this.resolution !== resolution) {\n            this.map.clear();\n        }\n        this.resolution = resolution;\n        this.map.set(key, value);\n    }\n\n    get(resolution, key) {\n        return this.resolution === resolution ? this.map.get(key) : undefined;\n    }\n\n    has(resolution, key) {\n        return this.resolution === resolution && this.map.has(key);\n    }\n}\n\nclass Straw {\n\n    constructor(config) {\n        this.config = config;\n        this.hicFile = new HicFile(config);\n    }\n\n    async getMetaData() {\n        return await this.hicFile.getMetaData()\n    }\n\n    //straw <NONE/VC/VC_SQRT/KR> <ile> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>\n    async getContactRecords(normalization, region1, region2, units, binsize) {\n        return this.hicFile.getContactRecords(normalization, region1, region2, units, binsize);\n    }\n\n    async getNormalizationOptions() {\n        return this.hicFile.getNormalizationOptions()\n    }\n\n    async getNVI() {\n        await this.hicFile.getNormVectorIndex();\n        return this.hicFile.config.nvi;\n    }\n\n    async printIndexStats() {\n        await this.hicFile.printIndexStats();\n    }\n\n    getFileChrName(chrAlias) {\n        if (this.hicFile.chrAliasTable.hasOwnProperty(chrAlias)) {\n            return this.hicFile.chrAliasTable[chrAlias]\n        } else {\n            return chrAlias\n        }\n    }\n}\n\nexport default Straw;\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;"],"sourceRoot":""}