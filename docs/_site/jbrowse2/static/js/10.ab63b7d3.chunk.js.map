{"version":3,"sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"names":["bufferToString","buffer","TextDecoder","fatal","decode","parseWith","options","csv","noheader","output","fromString","guessColumnType","rowSet","columnNumber","isValidRefName","parsedLoc","text","rows","cells","guessedType","parseLocString","error","refName","start","test","dataToSpreadsheetSnapshot","hasColumnNameLine","columnNameLineNumber","maxCols","isLoaded","map","row","rowNumber","id","length","String","columnNames","undefined","splice","colNamesRow","forEach","cell","columns","columnDisplayOrder","push","extendedData","name","dataType","type","hasColumnNames","assemblyName","selectedAssemblyName","parseCsvBuffer","a","parseTsvBuffer","delimiter"],"mappings":"gVAIO,SAASA,EAAeC,GAC7B,OAAO,IAAIC,YAAY,QAAS,CAAEC,OAAO,IAAQC,OAAOH,GAG1D,SAASI,EAAUJ,GAA8B,IAAdK,EAAc,uDAAJ,GAC3C,OAAOC,IAAI,aAAEC,UAAU,EAAMC,OAAQ,OAAUH,IAAWI,WACxDV,EAAeC,IAkCnB,SAASU,EACPC,EACAC,EACAC,GAEA,IAIIC,EAJEC,EAAOJ,EAAOK,KAAK,GAAGC,MAAML,GAAcG,MAAQ,GAEpDG,EAAc,OAGlB,IACEJ,EAAYK,yBAAeJ,EAAMF,GACjC,MAAOO,IAYT,OATIN,GAAaA,EAAUO,SAAsC,kBAApBP,EAAUQ,MACrDJ,EAAc,YACL,gBAAgBK,KAAKR,KAC9BG,EAAc,UAMTA,EAGT,SAASM,EACPR,GAMA,IALAX,EAKA,uDALwB,CACtBoB,mBAAmB,EACnBC,qBAAsB,EACtBb,eAAgB,kBAAM,IAKpBc,EAAU,EACRhB,EAAiB,CACrBiB,UAAU,EACVZ,KAAMA,EAAKa,KAAI,SAACC,EAAKC,GACnB,IAAMC,EAAKD,GAAa1B,EAAQoB,kBAAoB,EAAI,GAExD,OADIK,EAAIG,OAASN,IAASA,EAAUG,EAAIG,QACjC,CACLD,GAAIE,OAAOF,GACXf,MAAOa,EAAID,KAAI,SAACd,EAAMH,GACpB,MAAO,CAAEA,eAAcG,gBAOzBoB,EAAsC,GAC5C,GAAI9B,EAAQoB,wBAAsDW,IAAjC/B,EAAQqB,qBAAoC,OACrDf,EAAOK,KAAKqB,OAChChC,EAAQqB,qBAAuB,EAC/B,GAHyE,mBACpEY,EADoE,KAMvEA,GACFA,EAAYrB,MAAMsB,SAAQ,SAACC,EAAM5B,GAC/BuB,EAAYvB,GAAgB4B,EAAKzB,MAAQ,MAQ/C,IAFA,IAAM0B,EAAoB,GACpBC,EAAqB,GAnC3B,WAoCS9B,GACP8B,EAAmBC,KAAK/B,GACxB,IAAMM,EAAcR,EAClBC,EACAC,EACAP,EAAQQ,gBAIU,cAAhBK,GACFP,EAAOK,KAAKuB,SAAQ,SAAAT,GAClB,IAAMU,EAAOV,EAAIb,MAAML,GACvB4B,EAAKI,aAAezB,yBAAeqB,EAAKzB,KAAMV,EAAQQ,mBAI1D4B,EAAQ7B,GAAgB,CACtBiC,KAAMV,EAAYvB,GAClBkC,SAAU,CACRC,KAAM7B,KAnBHN,EAAe,EAAGA,EAAee,EAASf,GAAgB,EAAG,EAA7DA,GAwBT,MAAO,CACLD,SACA+B,qBACAM,iBAAkB3C,EAAQoB,kBAC1BgB,UACAQ,aAAc5C,EAAQ6C,sBAInB,SAAeC,EAAtB,kC,4CAAO,WACLnD,GADK,6BAAAoD,EAAA,6DAEL/C,EAFK,+BAEmB,CACtBoB,mBAAmB,EACnBC,qBAAsB,EACtBb,eAAgB,kBAAM,IALnB,SAQcT,EAAUJ,GARxB,cAQCgB,EARD,yBASEQ,EAA0BR,EAAMX,IATlC,4C,sBAYA,SAAegD,EAAtB,kC,4CAAO,WACLrD,GADK,6BAAAoD,EAAA,6DAEL/C,EAFK,+BAEmB,CACtBoB,mBAAmB,EACnBC,qBAAsB,EACtBb,eAAgB,kBAAM,IALnB,SAQcT,EAAUJ,EAAQ,CAAEsD,UAAW,OAR7C,cAQCtC,EARD,yBASEQ,EAA0BR,EAAMX,IATlC,4C","file":"static/js/10.ab63b7d3.chunk.js","sourcesContent":["import csv from 'csvtojson'\n\nimport { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nfunction parseWith(buffer: Buffer, options = {}) {\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) maxCols = row.length\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"sourceRoot":""}