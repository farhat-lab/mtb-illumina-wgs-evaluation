{"version":3,"sources":["../../../node_modules/@gmod/vcf/dist/index.js","../../../node_modules/@gmod/vcf/dist/parse.js","../../../node_modules/@gmod/vcf/dist/vcfReserved.js","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/VcfImport.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"names":["VCF","require","module","exports","_interopRequireDefault","_slicedToArray2","_classCallCheck2","_createClass2","_vcfReserved","Breakend","default","this","key","value","char","MateDirection","Join","concat","MatePosition","Replacement","args","_this","header","length","Error","headerLines","split","filter","line","strict","undefined","metadata","INFO","InfoFields","FORMAT","GenotypeFields","ALT","AltTypes","FILTER","FilterTypes","forEach","startsWith","_parseMetadata","fields","thisHeader","slice","correctHeader","every","index","samples","_line$trim$match$slic","trim","match","_line$trim$match$slic2","metaKey","metaVal","_this$_parseStructure","_parseStructuredMetaVal","_this$_parseStructure2","id","keyVals","_parseKeyValue","replace","ID","Number","isNaN","filteredMetadata","_len","arguments","Array","_key","i","str","pairSeparator","data","currKey","currValue","state","decodeTable","decodedStr","encodedIdx","indexOf","encodedChar","decodedChar","_this2","currChar","currField","substr","rest","variant","CHROM","POS","REF","QUAL","parseFloat","info","Object","keys","items","map","val","_percentDecode","itemType","getMetadata","console","warn","SVTYPE","_parseBreakend","bind","that","defineProperty","Variant","prototype","get","_parseGenotypes","stuff","assign","breakendString","tokens","parsed","includes","tok","formatKeys","_this3","genotypes","sample","formatValue","formatIndex","thisValue","valueType","AA","Type","Description","AC","AD","ADF","ADR","AF","AN","BQ","CIGAR","DB","DP","END","H2","H3","MQ","MQ0","NS","SB","SOMATIC","VALIDATED","IMPRECISE","NOVEL","SVLEN","CIPOS","CIEND","HOMLEN","HOMSEQ","BKPTID","MEINFO","METRANS","DGVID","DBVARID","DBRIPID","MATEID","PARID","EVENT","CILEN","DPADJ","CN","CNADJ","CICN","CICNADJ","EC","FT","GL","GP","GQ","GT","HQ","PL","PQ","PS","DEL","INS","DUP","INV","CNV","NON_REF","PASS","vcfCoreColumns","name","type","vcfRecordToRow","vcfParser","lineNumber","vcfVariant","parseLine","vcfFeature","VcfFeature","parser","d","push","String","extendedData","toJSON","cells","text","columnNumber","parseVcfBuffer","buffer","options","hasColumnNameLine","columnNameLineNumber","isValidRefName","splitVcfFileHeaderAndBody","bufferToString","body","rows","test","rowSet","isLoaded","columnDisplayOrder","columns","dataType","oi","unshift","isDerived","derivationFunctionText","hasColumnNames","assemblyName","selectedAssemblyName","wholeFile","prevChar","headerEndIndex","c","TextDecoder","fatal","decode","parseWith","csv","noheader","output","fromString","guessColumnType","parsedLoc","guessedType","parseLocString","error","refName","start","dataToSpreadsheetSnapshot","maxCols","row","rowNumber","columnNames","splice","colNamesRow","cell","parseCsvBuffer","a","parseTsvBuffer","delimiter"],"mappings":"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","file":"static/js/23.36aca132.chunk.js","sourcesContent":["\"use strict\"; /** @module VCF */\nvar VCF = require('./parse');\n\nmodule.exports = VCF;","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _vcfReserved = _interopRequireDefault(require(\"./vcfReserved\"));var\n\nBreakend = /*#__PURE__*/function () {function Breakend() {(0, _classCallCheck2.default)(this, Breakend);}(0, _createClass2.default)(Breakend, [{ key: \"toString\", value: function toString()\n    {\n      var char = this.MateDirection === 'left' ? ']' : '[';\n      if (this.Join === 'left') {\n        return \"\".concat(char).concat(this.MatePosition).concat(char).concat(this.Replacement);\n      }\n      return \"\".concat(this.Replacement).concat(char).concat(this.MatePosition).concat(char);\n    } }]);return Breakend;}();\n\n\n/**\n                                * Class representing a VCF parser, instantiated with the VCF header.\n                                * @param {object} args\n                                * @param {string} args.header - The VCF header. Supports both LF and CRLF\n                                * newlines.\n                                * @param {boolean} args.strict - Whether to parse in strict mode or not (default true)\n                                */var\nVCF = /*#__PURE__*/function () {\n  function VCF(args) {var _this = this;(0, _classCallCheck2.default)(this, VCF);\n    if (!args || !args.header || !args.header.length) {\n      throw new Error('empty header received');\n    }\n    var headerLines = args.header.split(/[\\r\\n]+/).filter(function (line) {return line;});\n    if (!headerLines.length) {\n      throw new Error('no non-empty header lines specified');\n    }\n\n    // allow access to the Breakend class in case anybody wants to use it for checking\n    this.Breakend = Breakend;\n    this.strict = args.strict !== undefined ? args.strict : true; // true by default\n    this.metadata = {\n      INFO: _vcfReserved.default.InfoFields,\n      FORMAT: _vcfReserved.default.GenotypeFields,\n      ALT: _vcfReserved.default.AltTypes,\n      FILTER: _vcfReserved.default.FilterTypes };\n\n    headerLines.forEach(function (line) {\n      if (!line.startsWith('#')) {\n        throw new Error(\"Bad line in header:\\n\".concat(line));\n      }\n      if (line.startsWith('##')) {\n        _this._parseMetadata(line);\n      } else if (line) {\n        var fields = line.split('\\t');\n        var thisHeader = fields.slice(0, 8);\n        var correctHeader = [\n        '#CHROM',\n        'POS',\n        'ID',\n        'REF',\n        'ALT',\n        'QUAL',\n        'FILTER',\n        'INFO'];\n\n        if (fields.length < 8) {\n          throw new Error(\"VCF header missing columns:\\n\".concat(line));\n        } else if (fields.length === 9) {\n          throw new Error(\"VCF header has FORMAT but no samples:\\n\".concat(line));\n        } else if (\n        thisHeader.length !== correctHeader.length ||\n        !thisHeader.every(function (value, index) {return value === correctHeader[index];}))\n        {\n          throw new Error(\"VCF column headers not correct:\\n\".concat(line));\n        }\n        _this.samples = fields.slice(9);\n      }\n    });\n    if (!this.samples) throw new Error('VCF does not have a header line');\n  }\n\n  /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */(0, _createClass2.default)(VCF, [{ key: \"_parseMetadata\", value: function _parseMetadata(\n    line) {var _line$trim$match$slic =\n      line.\n      trim().\n      match(/^##(.+?)=(.*)/).\n      slice(1, 3),_line$trim$match$slic2 = (0, _slicedToArray2.default)(_line$trim$match$slic, 2),metaKey = _line$trim$match$slic2[0],metaVal = _line$trim$match$slic2[1];\n      if (metaVal.startsWith('<')) {\n        if (!(metaKey in this.metadata)) {\n          this.metadata[metaKey] = {};\n        }var _this$_parseStructure =\n        this._parseStructuredMetaVal(metaVal),_this$_parseStructure2 = (0, _slicedToArray2.default)(_this$_parseStructure, 2),id = _this$_parseStructure2[0],keyVals = _this$_parseStructure2[1];\n        this.metadata[metaKey][id] = keyVals;\n      } else {\n        this.metadata[metaKey] = metaVal;\n      }\n    }\n\n    /**\n       * Parse a VCF header structured meta string (i.e. a meta value that starts\n       * with \"<ID=...\")\n       * @param {string} metaVal - The VCF metadata value\n       *\n       * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n       * and 2) an object with the other key-value pairs in the metadata\n       */ }, { key: \"_parseStructuredMetaVal\", value: function _parseStructuredMetaVal(\n    metaVal) {\n      var keyVals = this._parseKeyValue(metaVal.replace(/^<|>$/g, ''), ',');\n      var id = keyVals.ID;\n      delete keyVals.ID;\n      if ('Number' in keyVals) {\n        if (!Number.isNaN(Number(keyVals.Number))) {\n          keyVals.Number = Number(keyVals.Number);\n        }\n      }\n      return [id, keyVals];\n    }\n\n    /**\n       * Get metadata filtered by the elements in args. For example, can pass\n       * ('INFO', 'DP') to only get info on an metadata tag that was like\n       * \"##INFO=<ID=DP,...>\"\n       * @param  {...string} args - List of metadata filter strings.\n       *\n       * @returns {any} An object, string, or number, depending on the filtering\n       */ }, { key: \"getMetadata\", value: function getMetadata()\n    {\n      var filteredMetadata = this.metadata;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      for (var i = 0; i < args.length; i += 1) {\n        filteredMetadata = filteredMetadata[args[i]];\n        if (!filteredMetadata) return filteredMetadata;\n      }\n      return filteredMetadata;\n    }\n\n    /**\n       * Sometimes VCFs have key-value strings that allow the separator within\n       * the value if it's in quotes, like:\n       * 'ID=DB,Number=0,Type=Flag,Description=\"dbSNP membership, build 129\"'\n       *\n       * Parse this at a low level since we can't just split at \",\" (or whatever\n       * separator). Above line would be parsed to:\n       * {ID: 'DB', Number: '0', Type: 'Flag', Description: 'dbSNP membership, build 129'}\n       * @param {string} str - Key-value pairs in a string\n       * @param {string} [pairSeparator] - A string that separates sets of key-value\n       * pairs\n       *\n       * @returns {object} An object containing the key-value pairs\n       */ }, { key: \"_parseKeyValue\", value: function _parseKeyValue(\n    str) {var pairSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ';';\n      var data = {};\n      var currKey = '';\n      var currValue = '';\n      var state = 1; // states: 1: read key to = or pair sep, 2: read value to sep or quote, 3: read value to quote\n      for (var i = 0; i < str.length; i += 1) {\n        if (state === 1) {\n          // read key to = or pair sep\n          if (str[i] === '=') {\n            state = 2;\n          } else if (str[i] !== pairSeparator) {\n            currKey += str[i];\n          } else if (currValue === '') {\n            data[currKey] = null;\n            currKey = '';\n          }\n        } else if (state === 2) {\n          // read value to pair sep or quote\n          if (str[i] === pairSeparator) {\n            data[currKey] = currValue;\n            currKey = '';\n            currValue = '';\n            state = 1;\n          } else if (str[i] === '\"') {\n            state = 3;\n          } else currValue += str[i];\n        } else if (state === 3) {\n          // read value to quote\n          if (str[i] !== '\"') currValue += str[i];else\n          state = 2;\n        }\n      }\n      if (state === 2 || state === 3) {\n        data[currKey] = currValue;\n      } else if (state === 1) {\n        data[currKey] = null;\n      }\n      return data;\n    }\n\n    /**\n       * Decode any of the eight percent-encoded values allowed in a string by the\n       * VCF spec.\n       * @param {string} str - A string that may contain percent-encoded characters\n       *\n       * @returns {string} A string with any percent-encoded characters decoded\n       */ }, { key: \"_percentDecode\", value: function _percentDecode(\n    str) {\n      var decodeTable = {\n        '%3A': ':',\n        '%3B': ';',\n        '%3D': '=',\n        '%25': '%',\n        '%2C': ',',\n        '%0D': '\\r',\n        '%0A': '\\n',\n        '%09': '\\t' };\n\n      var decodedStr = str;\n      var encodedIdx = decodedStr.indexOf('%');\n      while (encodedIdx !== -1) {\n        var encodedChar = decodedStr.slice(encodedIdx, encodedIdx + 3);\n        var decodedChar = decodeTable[encodedChar];\n        if (!decodedChar)\n        throw new Error(\"Invalid percent-encoded character: \".concat(encodedChar));\n        decodedStr =\n        decodedStr.slice(0, encodedIdx) +\n        decodedChar +\n        decodedStr.slice(encodedIdx + 3);\n        encodedIdx = decodedStr.indexOf('%');\n      }\n      return decodedStr;\n    }\n\n    /**\n       * Parse a VCF line into an object like { CHROM POS ID REF ALT QUAL FILTER\n       * INFO } with SAMPLES optionally included if present in the VCF\n       * @param {string} line - A string of a line from a VCF. Supports both LF and\n       * CRLF newlines.\n       */ }, { key: \"parseLine\", value: function parseLine(\n    line) {var _this2 = this;\n      // eslint-disable-next-line no-param-reassign\n      line = line.trim();\n      if (!line.length) return undefined;\n      var currChar = 0;\n      for (var currField = 0; currChar < line.length; currChar += 1) {\n        if (line[currChar] === '\\t') {\n          currField += 1;\n        }\n        if (currField === 9) {\n          // reached genotypes, rest of fields are evaluated lazily\n          break;\n        }\n      }\n      var fields = line.substr(0, currChar).split('\\t');\n      var rest = line.substr(currChar + 1);\n      var variant = {\n        CHROM: fields[0],\n        POS: Number(fields[1]),\n        ID: fields[2] === '.' ? null : fields[2].split(';'),\n        REF: fields[3],\n        ALT: fields[4] === '.' ? null : fields[4].split(','),\n        QUAL: fields[5] === '.' ? null : parseFloat(fields[5]) };\n\n      if (fields[6] === '.') {\n        variant.FILTER = null;\n      } else if (fields[6] === 'PASS') {\n        variant.FILTER = 'PASS';\n      } else {\n        variant.FILTER = fields[6].split(';');\n      }\n      if (this.strict && fields[7] === undefined) {\n        throw new Error(\n        \"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n\n      }\n      var info =\n      fields[7] === undefined || fields[7] === '.' ?\n      {} :\n      this._parseKeyValue(fields[7]);\n      Object.keys(info).forEach(function (key) {\n        var items;\n        if (info[key]) {\n          items = info[key].split(',');\n          items = items.map(function (val) {\n            if (val === '.') return null;\n            return _this2._percentDecode(val);\n          });\n        } else items = info[key];\n        var itemType = _this2.getMetadata('INFO', key, 'Type');\n        if (itemType) {\n          if (itemType === 'Integer' || itemType === 'Float') {\n            items = items.map(function (val) {\n              if (val === null) return null;\n              return Number(val);\n            });\n          } else if (itemType === 'Flag') {\n            if (info[key])\n              // eslint-disable-next-line no-console\n              console.warn(\"Info field \".concat(\n              key, \" is a Flag and should not have a value (got value \").concat(info[key], \")\"));else\n\n            items = true;\n          }\n        }\n        info[key] = items;\n      });\n      variant.INFO = info;\n\n      // if this has SVTYPE=BND, parse ALTS for breakend descriptions\n      if (variant.ALT && info && info.SVTYPE && info.SVTYPE[0] === 'BND') {\n        variant.ALT = variant.ALT.map(this._parseBreakend.bind(this));\n      }\n\n      // This creates a closure that allows us to attach \"SAMPLES\" as a lazy\n      // attribute\n\n      function Variant(stuff) {\n        Object.assign(this, stuff);\n      }\n\n      var that = this;\n\n      Object.defineProperty(Variant.prototype, 'SAMPLES', {\n        get: function get() {\n          var samples = that._parseGenotypes(fields[8], rest);\n\n          Object.defineProperty(this, 'SAMPLES', {\n            value: samples });\n\n\n          return samples;\n        } });\n\n\n      return new Variant(variant);\n    } }, { key: \"_parseBreakend\", value: function _parseBreakend(\n\n    breakendString) {\n      var tokens = breakendString.split(/[[\\]]/);\n      if (tokens.length > 1) {\n        var parsed = new Breakend();\n        parsed.MateDirection = breakendString.includes('[') ? 'right' : 'left';\n        for (var i = 0; i < tokens.length; i += 1) {\n          var tok = tokens[i];\n          if (tok) {\n            if (tok.includes(':')) {\n              // this is the remote location\n              parsed.MatePosition = tok;\n              parsed.Join = parsed.Replacement ? 'right' : 'left';\n            } else {\n              // this is the local alteration\n              parsed.Replacement = tok;\n            }\n          }\n        }\n        return parsed;\n      }\n      // if there is not more than one token, there are no [ or ] characters,\n      // so just return it unmodified\n      return breakendString;\n    } }, { key: \"_parseGenotypes\", value: function _parseGenotypes(\n\n    formatKeys, rest) {var _this3 = this;\n      // eslint-disable-next-line no-param-reassign\n      rest = rest.split('\\t');\n      var genotypes = {};\n      // eslint-disable-next-line no-param-reassign\n      formatKeys = formatKeys && formatKeys.split(':');\n      this.samples.forEach(function (sample, index) {\n        genotypes[sample] = {};\n        formatKeys.forEach(function (key) {\n          genotypes[sample][key] = null;\n        });\n        rest[index].split(':').forEach(function (formatValue, formatIndex) {\n          var thisValue;\n          if (\n          formatValue === '' ||\n          formatValue === '.' ||\n          formatValue === undefined)\n          {\n            thisValue = null;\n          } else {\n            thisValue = _this3._percentDecode(formatValue).split(',');\n            thisValue = thisValue.map(function (val) {\n              if (val === '.') return null;\n              return val;\n            });\n            var valueType = _this3.getMetadata(\n            'FORMAT',\n            formatKeys[formatIndex],\n            'Type');\n\n            if ((valueType === 'Integer' || valueType === 'Float') && thisValue) {\n              thisValue = thisValue.map(function (val) {\n                if (!val) return null;\n                return Number(val);\n              });\n            }\n          }\n          genotypes[sample][formatKeys[formatIndex]] = thisValue;\n        }, {});\n      });\n      return genotypes;\n    } }]);return VCF;}();\n\n\nmodule.exports = VCF;","\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;var _default = {\n  // INFO fields\n  InfoFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n    AC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description:\n      'Allele count in genotypes, for each ALT allele, in the same order as listed' },\n\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Total read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    AF: {\n      Number: 'A',\n      Type: 'Float',\n      Description:\n      'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)' },\n\n    AN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Total number of alleles in called genotypes' },\n\n    BQ: {\n      Number: 1,\n      Type: 'Float',\n      Description: 'RMS base quality' },\n\n    CIGAR: {\n      Number: 1,\n      Type: 'Float',\n      Description:\n      'Cigar string describing how to align an alternate allele to the reference allele' },\n\n    DB: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'dbSNP membership' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'combined depth across samples' },\n\n    END: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'End position (for use with symbolic alleles)' },\n\n    H2: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap2 membership' },\n\n    H3: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap3 membership' },\n\n    MQ: {\n      Number: 1,\n      Type: null,\n      Description: 'RMS mapping quality' },\n\n    MQ0: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of MAPQ == 0 reads' },\n\n    NS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of samples with data' },\n\n    SB: {\n      Number: 4,\n      Type: 'Integer',\n      Description: 'Strand bias' },\n\n    SOMATIC: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Somatic mutation (for cancer genomics)' },\n\n    VALIDATED: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Validated by follow-up experiment' },\n\n    '1000G': {\n      Number: 0,\n      Type: 'Flag',\n      Description: '1000 Genomes membership' },\n\n    // specifically for structural variants\n    IMPRECISE: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Imprecise structural variation' },\n\n    NOVEL: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Indicates a novel structural variation' },\n\n    // For precise variants, END is POS + length of REF allele - 1,\n    // and the for imprecise variants the corresponding best estimate.\n    SVTYPE: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Type of structural variant' },\n\n    // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n    // be derived from the REF/ALT fields but is useful for filtering.\n    SVLEN: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Difference in length between REF and ALT alleles' },\n\n    // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n    // have positive values, shorter ALT alleles (e.g. deletions)\n    // have negative values.\n    CIPOS: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around POS for imprecise variants' },\n\n    CIEND: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around END for imprecise variants' },\n\n    HOMLEN: {\n      Type: 'Integer',\n      Description:\n      'Length of base pair identical micro-homology at event breakpoints' },\n\n    HOMSEQ: {\n      Type: 'String',\n      Description:\n      'Sequence of base pair identical micro-homology at event breakpoints' },\n\n    BKPTID: {\n      Type: 'String',\n      Description: 'ID of the assembled alternate allele in the assembly file' },\n\n    // For precise variants, the consensus sequence the alternate allele assembly\n    // is derivable from the REF and ALT fields. However, the alternate allele\n    // assembly file may contain additional information about the characteristics\n    // of the alt allele contigs.\n    MEINFO: {\n      Number: 4,\n      Type: 'String',\n      Description: 'Mobile element info of the form NAME,START,END,POLARITY' },\n\n    METRANS: {\n      Number: 4,\n      Type: 'String',\n      Description:\n      'Mobile element transduction info of the form CHR,START,END,POLARITY' },\n\n    DGVID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in Database of Genomic Variation' },\n\n    DBVARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBVAR' },\n\n    DBRIPID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBRIP' },\n\n    MATEID: {\n      Number: null,\n      Type: 'String',\n      Description: 'ID of mate breakends' },\n\n    PARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of partner breakend' },\n\n    EVENT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of event associated to breakend' },\n\n    CILEN: {\n      Number: 2,\n      Type: 'Integer',\n      Description:\n      'Confidence interval around the inserted material between breakend' },\n\n    DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n    CN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Copy number of segment containing breakend' },\n\n    CNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Copy number of adjacency' },\n\n    CICN: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the segment' },\n\n    CICNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the adjacency' } },\n\n\n\n  // FORMAT fields\n  GenotypeFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Read depth' },\n\n    EC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description: 'Expected alternate allele counts' },\n\n    FT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Filter indicating if this genotype was \"called\"' },\n\n    GL: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype likelihoods' },\n\n    GP: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype posterior probabilities' },\n\n    GQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Conditional genotype quality' },\n\n    GT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Genotype' },\n\n    HQ: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Haplotype quality' },\n\n    MQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'RMS mapping quality' },\n\n    PL: {\n      Number: 'G',\n      Type: 'Integer',\n      Description:\n      'Phred-scaled genotype likelihoods rounded to the closest integer' },\n\n    PQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phasing quality' },\n\n    PS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phase set' } },\n\n\n\n  // ALT fields\n  AltTypes: {\n    DEL: {\n      Description: 'Deletion relative to the reference' },\n\n    INS: {\n      Description: 'Insertion of novel sequence relative to the reference' },\n\n    DUP: {\n      Description: 'Region of elevated copy number relative to the reference' },\n\n    INV: {\n      Description: 'Inversion of reference sequence' },\n\n    CNV: {\n      Description:\n      'Copy number variable region (may be both deletion and duplication)' },\n\n    'DUP:TANDEM': {\n      Description: 'Tandem duplication' },\n\n    'DEL:ME': {\n      Description: 'Deletion of mobile element relative to the reference' },\n\n    'INS:ME': {\n      Description: 'Insertion of a mobile element relative to the reference' },\n\n    NON_REF: {\n      Description:\n      'Represents any possible alternative allele at this location' },\n\n    '*': {\n      Description:\n      'Represents any possible alternative allele at this location' } },\n\n\n\n  // FILTER fields\n  FilterTypes: {\n    PASS: {\n      Description: 'Passed all filters' } } };exports.default = _default;","import VCF from '@gmod/vcf'\nimport { VcfFeature } from '@jbrowse/plugin-variants'\nimport {\n  bufferToString,\n  Row,\n  RowSet,\n  Column,\n  ParseOptions,\n} from './ImportUtils'\n\nconst vcfCoreColumns: { name: string; type: string }[] = [\n  { name: 'CHROM', type: 'Text' }, // 0\n  { name: 'POS', type: 'Number' }, // 1\n  { name: 'ID', type: 'Text' }, // 2\n  { name: 'REF', type: 'Text' }, // 3\n  { name: 'ALT', type: 'Text' }, // 4\n  { name: 'QUAL', type: 'Number' }, // 5\n  { name: 'FILTER', type: 'Text' }, // 6\n  { name: 'INFO', type: 'Text' }, // 7\n  { name: 'FORMAT', type: 'Text' }, // 8\n]\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction vcfRecordToRow(vcfParser: any, line: string, lineNumber: number): Row {\n  const vcfVariant = vcfParser.parseLine(line)\n  const vcfFeature = new VcfFeature({\n    variant: vcfVariant,\n    parser: vcfParser,\n    id: `vcf-${lineNumber}`,\n  })\n\n  const data = line.split('\\t').map(d => (d === '.' ? '' : d))\n  // no format column, add blank\n  if (data.length === 8) {\n    data.push('')\n  }\n  const row: Row = {\n    id: String(lineNumber + 1),\n    extendedData: { vcfFeature: vcfFeature.toJSON() },\n    cells: data.map((text, columnNumber) => {\n      return {\n        columnNumber,\n        text,\n      }\n    }),\n  }\n  return row\n}\n\nexport function parseVcfBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 0,\n    isValidRefName: () => false,\n  },\n) {\n  let { header, body } = splitVcfFileHeaderAndBody(bufferToString(buffer))\n  const rows: Row[] = []\n  const vcfParser = new VCF({ header })\n  header = '' // garbage collect\n  body.split('\\n').forEach((line: string, lineNumber) => {\n    if (/\\S/.test(line)) {\n      rows.push(vcfRecordToRow(vcfParser, line, lineNumber))\n    }\n  })\n  body = '' // garbage collect\n\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows,\n  }\n\n  const columnDisplayOrder: number[] = []\n  const columns: Column[] = []\n  for (let i = 0; i < vcfCoreColumns.length; i += 1) {\n    columnDisplayOrder.push(i)\n    columns[i] = {\n      name: vcfCoreColumns[i].name,\n      dataType: { type: vcfCoreColumns[i].type },\n    }\n  }\n  for (let i = 0; i < vcfParser.samples.length; i += 1) {\n    const oi = vcfCoreColumns.length + i\n    columnDisplayOrder.push(oi)\n    columns[oi] = { name: vcfParser.samples[i], dataType: { type: 'Text' } }\n  }\n\n  columnDisplayOrder.push(columnDisplayOrder.length)\n  columns.unshift({\n    name: 'Location',\n    dataType: { type: 'LocString' },\n    isDerived: true,\n    derivationFunctionText: `jexl:{text:row.extendedData.vcfFeature.refName+':'\\n\n    +row.extendedData.vcfFeature.start+'..'+row.extendedData.vcfFeature.end, extendedData:\\n\n    {refName:row.extendedData.vcfFeature.refName,start:row.extendedData.vcfFeature.start,end:row.extendedData.vcfFeature.end}}`,\n  })\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: true,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport function splitVcfFileHeaderAndBody(wholeFile: string) {\n  // split into header and the rest of the file\n  let headerEndIndex = 0\n  let prevChar\n  for (; headerEndIndex < wholeFile.length; headerEndIndex += 1) {\n    const c = wholeFile[headerEndIndex]\n    if (prevChar === '\\n' && c !== '#') break\n    prevChar = c\n  }\n\n  return {\n    header: wholeFile.substr(0, headerEndIndex),\n    body: wholeFile.substr(headerEndIndex),\n  }\n}\n","import csv from 'csvtojson'\n\nimport { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nfunction parseWith(buffer: Buffer, options = {}) {\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) maxCols = row.length\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"sourceRoot":""}