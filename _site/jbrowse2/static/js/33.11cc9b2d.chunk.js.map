{"version":3,"sources":["../../../node_modules/hic-straw/dist/hic-straw.esm.js","../../../node_modules/node-fetch/browser.js"],"names":["Zlib","Huffman","Util","CRC32","DEFLATE","RESERVED","opt_params","this","files","comment","password","Zip","CompressionMethod","STORE","OperatingSystem","MSDOS","UNIX","MACINTOSH","Flags","ENCRYPT","DESCRIPTOR","UTF8","FileHeaderSignature","LocalFileHeaderSignature","CentralDirectorySignature","prototype","addFile","input","compressed","size","length","crc32","Array","Uint8Array","calc","deflateWithOption","Error","push","buffer","option","encrypted","setPassword","compress","file","output","op1","op2","op3","endOfCentralDirectorySize","offset","flags","compressionMethod","date","plainSize","filenameLength","extraFieldLength","commentLength","filename","extraField","tmp","key","i","il","j","jl","localFileSize","centralDirectorySize","createEncryptionKey","set","encode","Math","random","needVersion","Date","getMinutes","getSeconds","getHours","getMonth","getDate","getFullYear","RawDeflate","getByte","n","updateKeys","single","Uint32Array","buildHuffmanTable","lengths","table","bitLength","code","skip","reversed","rtemp","value","listSize","maxCodeLength","minCodeLength","Number","POSITIVE_INFINITY","RawInflate","blocks","bufferSize","totalpos","ip","bitsbuf","bitsbuflen","op","bfinal","bufferType","BufferType","ADAPTIVE","resize","BLOCK","MaxBackwardLength","MaxCopyLength","decompress","parseBlock","concatBufferBlock","concatBufferDynamic","Order","Uint16Array","LengthCodeTable","LengthExtraTable","DistCodeTable","DistExtraTable","FixedLiteralLengthTable","FixedDistanceTable","hdr","readBits","parseUncompressedBlock","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","octet","readCodeByTable","codeWithLength","codeLength","inputLength","codeTable","len","preCopy","olength","subarray","expandBufferBlock","expandBufferAdaptive","fixRatio","decodeHuffmanAdaptive","decodeHuffmanBlock","codeLengthsTable","litlenTable","distTable","lengthTable","prev","repeat","hlit","hdist","hclen","codeLengths","litlen","dist","currentLitlenTable","ti","codeDist","lengthCodeTable","lengthExtraTable","distCodeTable","distExtraTable","opt_param","backward","newSize","maxInflateSize","ratio","addRatio","block","pos","limit","RawInflateStream","opt_buffersize","ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE","blockLength","sp","status","Status","INITIALIZED","ip_","bitsbuflen_","bitsbuf_","BlockType","UNCOMPRESSED","FIXED","DYNAMIC","BLOCK_HEADER_START","BLOCK_HEADER_END","BLOCK_BODY_START","BLOCK_BODY_END","DECODE_BLOCK_START","DECODE_BLOCK_END","newInput","stop","readBlockHeader","currentBlockType","readUncompressedBlockHeader","decodeHuffman","concatBuffer","save_","restore_","expandBuffer","bits","call","e","Inflate","cmf","flg","rawinflate","verify","method","Adler32","InflateStream","readHeader","Gunzip","member","decompressed","getMembers","slice","decodeMember","concatMember","isize","inflated","inflen","c","ci","str","mtime","GunzipMember","id1","id2","cm","xfl","os","Gzip","FlagsMask","FEXTRA","xlen","decodeSubField","FNAME","String","fromCharCode","name","join","FCOMMENT","FHCRC","crc16","data","toString","p","getName","getData","getMtime","deflateOptions","DefaultBufferSize","rawdeflate","now","UNKNOWN","charCodeAt","byteLength","FAT","AMIGA","VMS","VM_CMS","ATARI_TOS","HPFS","Z_SYSTEM","CP_M","TOPS_20","NTFS","QDOS","ACORN_RISCOS","FTEXT","Heap","getParent","index","getChild","current","parent","swap","heap","pop","compressionType","CompressionType","lazy","freqsLitLen","freqsDist","NONE","Lz77MinLength","Lz77MaxLength","WindowSize","MaxCodeLength","HUFMAX","FixedHuffmanTable","blockArray","position","makeNocompressBlock","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","btype","nlen","stream","BitStream","writeBits","lz77","fixedHuffman","finish","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","bitlen","hclenOrder","transLengths","getLengths_","getCodesFromLengths_","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","literal","apply","Lz77Match","backwardDistance","getDistanceCode_","r","toLz77Array","codeArray","matchKey","matchList","longestMatch","prevMatch","windowSize","lz77buf","skipLength","writeMatch","match","lz77Array","shift","searchLongestMatch_","currentMatch","matchLength","l","matchMax","dl","permatch","litlenLengths","runLength","nResult","rpt","src","result","nodes","values","nSymbols","reversePackageMerge_","symbols","t","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","m","count","startCode","Unzip","eocdrOffset","numberOfThisDisk","startDisk","totalEntriesThisDisk","totalEntries","centralDirectoryOffset","fileHeaderList","filenameToIndex","FileHeader","version","compression","time","compressedSize","fileNameLength","fileCommentLength","diskNumberStart","internalFileAttributes","externalFileAttributes","relativeOffset","parse","LocalFileHeader","searchEndOfCentralDirectoryRecord","parseEndOfCentralDirectoryRecord","parseFileHeader","fileHeader","filelist","filetable","getFileData","localFileHeader","createDecryptionKey","decode","getFilenames","filenameList","stringToByteArray","split","array","update","adler","tlen","s1","s2","OptimizationParameter","bufferPosition","bitindex","DefaultBlockSize","oldbuf","number","reverse","ReverseTable","rev32_","s","crc","Table","num","Table_","Deflate","rawDeflate","prop","rawDeflateOption","cinfo","flevel","LOG2E","log","fdict","fs","fsOpen","fsRead","crossFetch","process","versions","node","require","fetch","BrowserLocalFile","blob","Promise","fullfill","reject","fileReader","FileReader","onload","onerror","console","err","undefined","readAsArrayBuffer","util","promisify","open","read","NodeLocalFile","args","path","Buffer","alloc","fd","close","error","b","arrayBuffer","byteOffset","isNode$2","RemoteFile","url","config","includes","replace","startsWith","resolveToken","token","a","resolve","ceil","headers","rangeString","oauthToken","navigator","vendor","indexOf","test","userAgent","isChrome","isAmazonV4Signed","addParameter","apiKey","redirect","mode","response","statusText","paramSeparator","ThrottledFile","rateLimiter","fulfill","limiter","f","RateLimiter","wait","isCalled","calls","fn","self","caller","setTimeout","bind","arguments","BufferedFile","bufferStart","bufferLength","start","end","bufferEnd","sliceEnd","sliceStart","l1","a1","l2","a2","concatBuffers","buffer1","buffer2","BinaryParser","dataView","littleEndian","view","VPointer","available","remLength","hasNext","retValue","getUint8","getShort","getInt16","getUShort","getUint16","getInt","getInt32","getUInt","getUint32","getLong","getString","getFixedLengthString","getFixedLengthTrimmedString","getFloat","getFloat32","getDouble","getFloat64","getVPointer","isLessThan","vp","isGreaterThan","print","MatrixZoomData","chr1","chr2","zoom","unit","binSize","region1","region2","chr","sameChr","binsize","blockBinCount","blockColumnCount","x1","x2","y1","y2","col1","floor","col2","row1","row2","blockNumbers","row","column","blockNumber","getBlockNumbersV8","binX1","binX2","binY1","binY2","translatedLowerPAD","translatedHigherPAD","translatedNearerDepth","log2","abs","sqrt","translatedFurtherDepth","nearerDepth","min","furtherDepth","max","depth","pad","block_number","getBlockNumbersV9","dis","zd","zoomIndex","sumCounts","occupiedCellCount","stdDev","percent95","nBlocks","blockIndex","StaticBlockIndex","avgCount","averageCount","filePosition","Matrix","zoomDataList","bpZoomData","fragZoomData","zdArray","chrIdx1","chrIdx2","chromosomes","DataView","c1","c2","nResolutions","zdList","parseMatrixZoomData","ContactRecord","bin1","bin2","counts","LRU","map","Map","item","get","delete","val","has","first","clear","keys","NormalizationVector","nValues","dataType","cache","adjustedStart","adjustedEnd","startPosition","sizeInBytes","parser","getKey","chrIdx","resolution","isNode$3","GoogleRateLimiter","HicFile","loadFragData","fragmentSitesCache","normVectorCache","normalizationTypes","matrixCache","blockCache","BlockCache","remote","remoteFile","initialized","readHeaderAndFooter","binaryParser","magic","init","meta","footerPosition","readFooter","bodyPostion","Object","masterIndex","reduce","currentValue","MAX_VALUE","remainingSize","genomeId","normVectorIndexPosition","normVectorIndexSize","attributes","nAttributes","chromosomeIndexMap","nChrs","toLowerCase","wholeGenomeChromosome","wholeGenomeResolution","round","bpResolutions","nBpResolutions","fragResolutions","nFragResolutions","chrAliasTable","chrName","substr","nBytes","nEntries","miSize","expectedValueVectors","normExpectedValueVectorsPosition","maxSize","entry","readMatrix","matrix","idx","parseMatrix","normalization","units","allRecords","idx1","getFileChrName","idx2","getBlocks","contactRecords","nvX1","nvX2","nvY1","nvY2","normVector1","normVector2","isNorm","getNormalizationVector","nv1","nv2","getValues","records","rec","y","nvnv","isNaN","getMatrix","getZoomData","msg","getBlockNumbers","blockNumbersToQuery","promises","readBlock","all","newBlocks","concat","getBlockIndexEntry","inflate","plain","nRecords","binX","binY","binXOffset","binYOffset","useFloatContact","useIntXPos","useIntYPos","rowCount","dy","colCount","dx","nPts","w","Block","isInteger","canonicalName","getNormalizationVectorKey","getNormVectorIndex","normVectorIndex","nv","nvi","URL","encodeURIComponent","hostname","pathname","nviResponse","text","nviArray","decodeURIComponent","range","parseInt","readNormVectorIndex","readNormExpectedValuesAndNormVectorIndex","normalizationVectorIndexRange","parseNormVectorEntry","processEntries","byteCount","sizeEstimate","nviStart","skipExpectedValues","normalizedExpectedValueVectors","parseNext","chunkSize","p0","nChrScaleFactors","resolutionArray","chrAlias","hasOwnProperty","zoomData","Straw","hicFile","getMetaData","getContactRecords","getNormalizationOptions","printIndexStats","global","window","getGlobal","module","exports","default","Headers","Request","Response"],"mappings":"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","file":"static/js/33.11cc9b2d.chunk.js","sourcesContent":["// from https://github.com/imaya/zlib.js\n\nvar Zlib = {\n  Huffman: {},\n  Util: {},\n  CRC32: {}\n};\n\n\n/**\n * Compression Method\n * @enum {number}\n */\nZlib.CompressionMethod = {\n  DEFLATE: 8,\n  RESERVED: 15\n};\n\n\n\n\n/**\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Zip = function(opt_params) {\n  opt_params = opt_params || {};\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  this.files = [];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment = opt_params['comment'];\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password;\n};\n\n\n/**\n * @enum {number}\n */\nZlib.Zip.CompressionMethod = {\n  STORE: 0,\n  DEFLATE: 8\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.OperatingSystem = {\n  MSDOS: 0,\n  UNIX: 3,\n  MACINTOSH: 7\n};\n\n/**\n * @enum {number}\n */\nZlib.Zip.Flags = {\n  ENCRYPT:    0x0001,\n  DESCRIPTOR: 0x0008,\n  UTF8:       0x0800\n};\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\n\n/**\n * @param {Array.<number>|Uint8Array} input\n * @param {Object=} opt_params options.\n */\nZlib.Zip.prototype.addFile = function(input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {string} */\n  var filename =  opt_params['filename'];\n  /** @type {boolean} */\n  var compressed;\n  /** @type {number} */\n  var size = input.length;\n  /** @type {number} */\n  var crc32 = 0;\n\n  if ( input instanceof Array) {\n    input = new Uint8Array(input);\n  }\n\n  // default\n  if (typeof opt_params['compressionMethod'] !== 'number') {\n    opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;\n  }\n\n  // \n  if (opt_params['compress']) {\n    switch (opt_params['compressionMethod']) {\n      case Zlib.Zip.CompressionMethod.STORE:\n        break;\n      case Zlib.Zip.CompressionMethod.DEFLATE:\n        crc32 = Zlib.CRC32.calc(input);\n        input = this.deflateWithOption(input, opt_params);\n        compressed = true;\n        break;\n      default:\n        throw new Error('unknown compression method:' + opt_params['compressionMethod']);\n    }\n  }\n\n  this.files.push({\n    buffer: input,\n    option: opt_params,\n    compressed: compressed,\n    encrypted: false,\n    size: size,\n    crc32: crc32\n  });\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Zip.prototype.setPassword = function(password) {\n  this.password = password;\n};\n\nZlib.Zip.prototype.compress = function() {\n  /** @type {Array.<{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }>} */\n  var files = this.files;\n  /** @type {{\n   *   buffer: !(Array.<number>|Uint8Array),\n   *   option: Object,\n   *   compressed: boolean,\n   *   encrypted: boolean,\n   *   size: number,\n   *   crc32: number\n   * }} */\n  var file;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var op1;\n  /** @type {number} */\n  var op2;\n  /** @type {number} */\n  var op3;\n  /** @type {number} */\n  var localFileSize = 0;\n  /** @type {number} */\n  var centralDirectorySize = 0;\n  /** @type {number} */\n  var endOfCentralDirectorySize;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var needVersion;\n  /** @type {number} */\n  var flags;\n  /** @type {Zlib.Zip.CompressionMethod} */\n  var compressionMethod;\n  /** @type {Date} */\n  var date;\n  /** @type {number} */\n  var crc32;\n  /** @type {number} */\n  var size;\n  /** @type {number} */\n  var plainSize;\n  /** @type {number} */\n  var filenameLength;\n  /** @type {number} */\n  var extraFieldLength;\n  /** @type {number} */\n  var commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var filename;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var extraField;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var comment;\n  /** @type {(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {*} */\n  var tmp;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var jl;\n\n  // \n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength =\n      (file.option['filename']) ? file.option['filename'].length : 0;\n    extraFieldLength =\n      (file.option['extraField']) ? file.option['extraField'].length : 0;\n    commentLength =\n      (file.option['comment']) ? file.option['comment'].length : 0;\n\n    // \n    if (!file.compressed) {\n      //  CRC32 \n      file.crc32 = Zlib.CRC32.calc(file.buffer);\n\n      switch (file.option['compressionMethod']) {\n        case Zlib.Zip.CompressionMethod.STORE:\n          break;\n        case Zlib.Zip.CompressionMethod.DEFLATE:\n          file.buffer = this.deflateWithOption(file.buffer, file.option);\n          file.compressed = true;\n          break;\n        default:\n          throw new Error('unknown compression method:' + file.option['compressionMethod']);\n      }\n    }\n\n    // encryption\n    if (file.option['password'] !== void 0|| this.password !== void 0) {\n      // init encryption\n      key = this.createEncryptionKey(file.option['password'] || this.password);\n\n      // add header\n      buffer = file.buffer;\n      {\n        tmp = new Uint8Array(buffer.length + 12);\n        tmp.set(buffer, 12);\n        buffer = tmp;\n      }\n\n      for (j = 0; j < 12; ++j) {\n        buffer[j] = this.encode(\n          key,\n          i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\n        );\n      }\n\n      // data encryption\n      for (jl = buffer.length; j < jl; ++j) {\n        buffer[j] = this.encode(key, buffer[j]);\n      }\n      file.buffer = buffer;\n    }\n\n    // \n    localFileSize +=\n      // local file header\n      30 + filenameLength +\n      // file data\n      file.buffer.length;\n\n    centralDirectorySize +=\n      // file header\n      46 + filenameLength + commentLength;\n  }\n\n  // end of central directory\n  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\n  output = new ( Uint8Array )(\n    localFileSize + centralDirectorySize + endOfCentralDirectorySize\n  );\n  op1 = 0;\n  op2 = localFileSize;\n  op3 = op2 + centralDirectorySize;\n\n  // \n  for (i = 0, il = files.length; i < il; ++i) {\n    file = files[i];\n    filenameLength =\n      file.option['filename'] ? file.option['filename'].length :  0;\n    extraFieldLength = 0; // TODO\n    commentLength =\n      file.option['comment'] ? file.option['comment'].length : 0;\n\n    //-------------------------------------------------------------------------\n    // local file header & file header\n    //-------------------------------------------------------------------------\n\n    offset = op1;\n\n    // signature\n    // local file header\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];\n    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];\n    // file header\n    output[op2++] = Zlib.Zip.FileHeaderSignature[0];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[1];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[2];\n    output[op2++] = Zlib.Zip.FileHeaderSignature[3];\n\n    // compressor info\n    needVersion = 20;\n    output[op2++] = needVersion & 0xff;\n    output[op2++] =\n      /** @type {Zlib.Zip.OperatingSystem} */\n      (file.option['os']) ||\n      Zlib.Zip.OperatingSystem.MSDOS;\n\n    // need version\n    output[op1++] = output[op2++] =  needVersion       & 0xff;\n    output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\n\n    // general purpose bit flag\n    flags = 0;\n    if (file.option['password'] || this.password) {\n      flags |= Zlib.Zip.Flags.ENCRYPT;\n    }\n    output[op1++] = output[op2++] =  flags       & 0xff;\n    output[op1++] = output[op2++] = (flags >> 8) & 0xff;\n\n    // compression method\n    compressionMethod =\n      /** @type {Zlib.Zip.CompressionMethod} */\n      (file.option['compressionMethod']);\n    output[op1++] = output[op2++] =  compressionMethod       & 0xff;\n    output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\n\n    // date\n    date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\n    output[op1++] = output[op2++] =\n      ((date.getMinutes() & 0x7) << 5) |\n      (date.getSeconds() / 2 | 0);\n    output[op1++] = output[op2++] =\n      (date.getHours()   << 3) |\n      (date.getMinutes() >> 3);\n    //\n    output[op1++] = output[op2++] =\n      ((date.getMonth() + 1 & 0x7) << 5) |\n      (date.getDate());\n    output[op1++] = output[op2++] =\n      ((date.getFullYear() - 1980 & 0x7f) << 1) |\n      (date.getMonth() + 1 >> 3);\n\n    // CRC-32\n    crc32 = file.crc32;\n    output[op1++] = output[op2++] =  crc32        & 0xff;\n    output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\n    output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\n    output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\n\n    // compressed size\n    size = file.buffer.length;\n    output[op1++] = output[op2++] =  size        & 0xff;\n    output[op1++] = output[op2++] = (size >>  8) & 0xff;\n    output[op1++] = output[op2++] = (size >> 16) & 0xff;\n    output[op1++] = output[op2++] = (size >> 24) & 0xff;\n\n    // uncompressed size\n    plainSize = file.size;\n    output[op1++] = output[op2++] =  plainSize        & 0xff;\n    output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\n    output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\n    output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\n\n    // filename length\n    output[op1++] = output[op2++] =  filenameLength       & 0xff;\n    output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\n\n    // extra field length\n    output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\n    output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\n\n    // file comment length\n    output[op2++] =  commentLength       & 0xff;\n    output[op2++] = (commentLength >> 8) & 0xff;\n\n    // disk number start\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // internal file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // external file attributes\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n    output[op2++] = 0;\n\n    // relative offset of local header\n    output[op2++] =  offset        & 0xff;\n    output[op2++] = (offset >>  8) & 0xff;\n    output[op2++] = (offset >> 16) & 0xff;\n    output[op2++] = (offset >> 24) & 0xff;\n\n    // filename\n    filename = file.option['filename'];\n    if (filename) {\n      {\n        output.set(filename, op1);\n        output.set(filename, op2);\n        op1 += filenameLength;\n        op2 += filenameLength;\n      }\n    }\n\n    // extra field\n    extraField = file.option['extraField'];\n    if (extraField) {\n      {\n        output.set(extraField, op1);\n        output.set(extraField, op2);\n        op1 += extraFieldLength;\n        op2 += extraFieldLength;\n      }\n    }\n\n    // comment\n    comment = file.option['comment'];\n    if (comment) {\n      {\n        output.set(comment, op2);\n        op2 += commentLength;\n      }\n    }\n\n    //-------------------------------------------------------------------------\n    // file data\n    //-------------------------------------------------------------------------\n\n    {\n      output.set(file.buffer, op1);\n      op1 += file.buffer.length;\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // end of central directory\n  //-------------------------------------------------------------------------\n\n  // signature\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];\n  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];\n\n  // number of this disk\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // number of the disk with the start of the central directory\n  output[op3++] = 0;\n  output[op3++] = 0;\n\n  // total number of entries in the central directory on this disk\n  output[op3++] =  il       & 0xff;\n  output[op3++] = (il >> 8) & 0xff;\n\n  // total number of entries in the central directory\n  output[op3++] =  il       & 0xff;\n  output[op3++] = (il >> 8) & 0xff;\n\n  // size of the central directory\n  output[op3++] =  centralDirectorySize        & 0xff;\n  output[op3++] = (centralDirectorySize >>  8) & 0xff;\n  output[op3++] = (centralDirectorySize >> 16) & 0xff;\n  output[op3++] = (centralDirectorySize >> 24) & 0xff;\n\n  // offset of start of central directory with respect to the starting disk number\n  output[op3++] =  localFileSize        & 0xff;\n  output[op3++] = (localFileSize >>  8) & 0xff;\n  output[op3++] = (localFileSize >> 16) & 0xff;\n  output[op3++] = (localFileSize >> 24) & 0xff;\n\n  // .ZIP file comment length\n  commentLength = this.comment ? this.comment.length : 0;\n  output[op3++] =  commentLength       & 0xff;\n  output[op3++] = (commentLength >> 8) & 0xff;\n\n  // .ZIP file comment\n  if (this.comment) {\n    {\n      output.set(this.comment, op3);\n      op3 += commentLength;\n    }\n  }\n\n  return output;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input\n * @param {Object=} opt_params options.\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Zip.prototype.deflateWithOption = function(input, opt_params) {\n  /** @type {Zlib.RawDeflate} */\n  var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);\n\n  return deflator.compress();\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @return {number}\n */\nZlib.Zip.prototype.getByte = function(key) {\n  /** @type {number} */\n  var tmp = ((key[2] & 0xffff) | 2);\n\n  return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Zip.prototype.encode = function(key, n) {\n  /** @type {number} */\n  var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n\n  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n  return tmp ^ n;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array)} key\n * @param {number} n\n */\nZlib.Zip.prototype.updateKeys = function(key, n) {\n  key[0] = Zlib.CRC32.single(key[0], n);\n  key[1] =\n    (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\n  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n * @return {!(Array.<number>|Uint32Array|Object)}\n */\nZlib.Zip.prototype.createEncryptionKey = function(password) {\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var key = [305419896, 591751049, 878082192];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  {\n    key = new Uint32Array(key);\n  }\n\n  for (i = 0, il = password.length; i < il; ++i) {\n    this.updateKeys(key, password[i] & 0xff);\n  }\n\n  return key;\n};\n\n\n\n/**\n * build huffman table from length list.\n * @param {!(Array.<number>|Uint8Array)} lengths length list.\n * @return {!Array} huffman table.\n */\nZlib.Huffman.buildHuffmanTable = function(lengths) {\n  /** @type {number} length list size. */\n  var listSize = lengths.length;\n  /** @type {number} max code length for table size. */\n  var maxCodeLength = 0;\n  /** @type {number} min code length for table size. */\n  var minCodeLength = Number.POSITIVE_INFINITY;\n  /** @type {number} table size. */\n  var size;\n  /** @type {!(Array|Uint8Array)} huffman code table. */\n  var table;\n  /** @type {number} bit length. */\n  var bitLength;\n  /** @type {number} huffman code. */\n  var code;\n  /**\n   *  2^maxlength .\n   * @type {number} skip length for table filling.\n   */\n  var skip;\n  /** @type {number} reversed code. */\n  var reversed;\n  /** @type {number} reverse temp. */\n  var rtemp;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} table value. */\n  var value;\n\n  // Math.max  for-loop \n  for (i = 0, il = listSize; i < il; ++i) {\n    if (lengths[i] > maxCodeLength) {\n      maxCodeLength = lengths[i];\n    }\n    if (lengths[i] < minCodeLength) {\n      minCodeLength = lengths[i];\n    }\n  }\n\n  size = 1 << maxCodeLength;\n  table = new ( Uint32Array )(size);\n\n  // \n  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\n    for (i = 0; i < listSize; ++i) {\n      if (lengths[i] === bitLength) {\n        // \n        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\n          reversed = (reversed << 1) | (rtemp & 1);\n          rtemp >>= 1;\n        }\n\n        // \n        //  0 / 1 \n        // \n        // \n        value = (bitLength << 16) | i;\n        for (j = reversed; j < size; j += skip) {\n          table[j] = value;\n        }\n\n        ++code;\n      }\n    }\n\n    // \n    ++bitLength;\n    code <<= 1;\n    skip <<= 1;\n  }\n\n  return [table, maxCodeLength, minCodeLength];\n};\n\n\n\n\n//-----------------------------------------------------------------------------\n\n/** @define {number} buffer block size. */\nvar ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\n\n//-----------------------------------------------------------------------------\n\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {Object} opt_params option parameter.\n *\n * opt_params \n *   - index: input buffer  deflate .\n *   - blockSize: .\n *   - bufferType: Zlib.RawInflate.BufferType .\n *   - resize: .\n */\nZlib.RawInflate = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} inflated buffer */\n  this.buffer;\n  /** @type {!Array.<(Array.<number>|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input =  new Uint8Array(input) ;\n  /** @type {!(Uint8Array|Array.<number>)} output buffer. */\n  this.output;\n  /** @type {!number} output buffer pointer. */\n  this.op;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {Zlib.RawInflate.BufferType} buffer management. */\n  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['bufferSize']) {\n      this.bufferSize = opt_params['bufferSize'];\n    }\n    if (opt_params['bufferType']) {\n      this.bufferType = opt_params['bufferType'];\n    }\n    if (opt_params['resize']) {\n      this.resize = opt_params['resize'];\n    }\n  }\n\n  // initialize\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.op = Zlib.RawInflate.MaxBackwardLength;\n      this.output =\n        new ( Uint8Array )(\n          Zlib.RawInflate.MaxBackwardLength +\n          this.bufferSize +\n          Zlib.RawInflate.MaxCopyLength\n        );\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.op = 0;\n      this.output = new ( Uint8Array )(this.bufferSize);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflate.BufferType = {\n  BLOCK: 0,\n  ADAPTIVE: 1\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array.<number>)} inflated buffer.\n */\nZlib.RawInflate.prototype.decompress = function() {\n  while (!this.bfinal) {\n    this.parseBlock();\n  }\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      return this.concatBufferBlock();\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      return this.concatBufferDynamic();\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflate.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflate.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.Order = (function(table) {\n  return  new Uint16Array(table) ;\n})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.LengthCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n  0x00e3, 0x0102, 0x0102, 0x0102\n]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.LengthExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0, 0, 0\n]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflate.DistCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n  0x3001, 0x4001, 0x6001\n]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflate.DistExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13\n]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedLiteralLengthTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] =\n      (i <= 143) ? 8 :\n      (i <= 255) ? 9 :\n      (i <= 279) ? 7 :\n      8;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflate.FixedDistanceTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflate.prototype.parseBlock = function() {\n  /** @type {number} header */\n  var hdr = this.readBits(3);\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    // uncompressed\n    case 0:\n      this.parseUncompressedBlock();\n      break;\n    // fixed huffman\n    case 1:\n      this.parseFixedHuffmanBlock();\n      break;\n    // dynamic huffman\n    case 2:\n      this.parseDynamicHuffmanBlock();\n      break;\n    // reserved or other\n    default:\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflate.prototype.readBits = function(length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // input byte\n  if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {\n    throw new Error('input buffer is broken');\n  }\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflate.prototype.readCodeByTable = function(table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {!(Array.<number>|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (ip >= inputLength) {\n      break;\n    }\n    bitsbuf |= input[ip++] << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflate.prototype.parseUncompressedBlock = function() {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} */\n  var inputLength = input.length;\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n  /** @type {number} output buffer length */\n  var olength = output.length;\n  /** @type {number} copy counter */\n  var preCopy;\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  // len\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: LEN');\n  }\n  len = input[ip++] | (input[ip++] << 8);\n\n  // nlen\n  if (ip + 1 >= inputLength) {\n    throw new Error('invalid uncompressed block header: NLEN');\n  }\n  nlen = input[ip++] | (input[ip++] << 8);\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // check size\n  if (ip + len > input.length) { throw new Error('input buffer is broken'); }\n\n  // expand buffer\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.BLOCK:\n      // pre copy\n      while (op + len > output.length) {\n        preCopy = olength - op;\n        len -= preCopy;\n        {\n          output.set(input.subarray(ip, ip + preCopy), op);\n          op += preCopy;\n          ip += preCopy;\n        }\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      break;\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      while (op + len > output.length) {\n        output = this.expandBufferAdaptive({fixRatio: 2});\n      }\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n\n  // copy\n  {\n    output.set(input.subarray(ip, ip + len), op);\n    op += len;\n    ip += len;\n  }\n\n  this.ip = ip;\n  this.op = op;\n  this.output = output;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(\n        Zlib.RawInflate.FixedLiteralLengthTable,\n        Zlib.RawInflate.FixedDistanceTable\n      );\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(\n        Zlib.RawInflate.FixedLiteralLengthTable,\n        Zlib.RawInflate.FixedDistanceTable\n      );\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {\n  /** @type {number} number of literal and length codes. */\n  var hlit = this.readBits(5) + 257;\n  /** @type {number} number of distance codes. */\n  var hdist = this.readBits(5) + 1;\n  /** @type {number} number of code lengths. */\n  var hclen = this.readBits(4) + 4;\n  /** @type {!(Uint8Array|Array.<number>)} code lengths. */\n  var codeLengths =\n    new ( Uint8Array )(Zlib.RawInflate.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n  /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\n  var litlenTable;\n  /** @type {!(Uint8Array|Array.<number>)} distance code table. */\n  var distTable;\n  /** @type {!(Uint8Array|Array.<number>)} code length table. */\n  var lengthTable;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var prev;\n  /** @type {number} */\n  var repeat;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limit. */\n  var il;\n\n  // decode code lengths\n  for (i = 0; i < hclen; ++i) {\n    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);\n  }\n\n  // decode length table\n  codeLengthsTable = buildHuffmanTable(codeLengths);\n  lengthTable = new ( Uint8Array )(hlit + hdist);\n  for (i = 0, il = hlit + hdist; i < il;) {\n    code = this.readCodeByTable(codeLengthsTable);\n    switch (code) {\n      case 16:\n        repeat = 3 + this.readBits(2);\n        while (repeat--) { lengthTable[i++] = prev; }\n        break;\n      case 17:\n        repeat = 3 + this.readBits(3);\n        while (repeat--) { lengthTable[i++] = 0; }\n        prev = 0;\n        break;\n      case 18:\n        repeat = 11 + this.readBits(7);\n        while (repeat--) { lengthTable[i++] = 0; }\n        prev = 0;\n        break;\n      default:\n        lengthTable[i++] = code;\n        prev = code;\n        break;\n    }\n  }\n\n  litlenTable =  buildHuffmanTable(lengthTable.subarray(0, hlit))\n    ;\n  distTable =  buildHuffmanTable(lengthTable.subarray(hlit))\n    ;\n\n  switch (this.bufferType) {\n    case Zlib.RawInflate.BufferType.ADAPTIVE:\n      this.decodeHuffmanAdaptive(litlenTable, distTable);\n      break;\n    case Zlib.RawInflate.BufferType.BLOCK:\n      this.decodeHuffmanBlock(litlenTable, distTable);\n      break;\n    default:\n      throw new Error('invalid inflate mode');\n  }\n};\n\n/**\n * decode huffman code\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanBlock = function(litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length - Zlib.RawInflate.MaxCopyLength;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        this.op = op;\n        output = this.expandBufferBlock();\n        op = this.op;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op >= olength) {\n      this.op = op;\n      output = this.expandBufferBlock();\n      op = this.op;\n    }\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * decode huffman code (adaptive)\n * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n */\nZlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {\n  var output = this.output;\n  var op = this.op;\n\n  this.currentLitlenTable = litlen;\n\n  /** @type {number} output position limit. */\n  var olength = output.length;\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;\n  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;\n  var distCodeTable = Zlib.RawInflate.DistCodeTable;\n  var distExtraTable = Zlib.RawInflate.DistExtraTable;\n\n  while ((code = this.readCodeByTable(litlen)) !== 256) {\n    // literal\n    if (code < 256) {\n      if (op >= olength) {\n        output = this.expandBufferAdaptive();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = lengthCodeTable[ti];\n    if (lengthExtraTable[ti] > 0) {\n      codeLength += this.readBits(lengthExtraTable[ti]);\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    codeDist = distCodeTable[code];\n    if (distExtraTable[code] > 0) {\n      codeDist += this.readBits(distExtraTable[code]);\n    }\n\n    // lz77 decode\n    if (op + codeLength > olength) {\n      output = this.expandBufferAdaptive();\n      olength = output.length;\n    }\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n  this.op = op;\n};\n\n/**\n * expand output buffer.\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.expandBufferBlock = function(opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer =\n    new ( Uint8Array )(\n        this.op - Zlib.RawInflate.MaxBackwardLength\n    );\n  /** @type {number} backward base point */\n  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;\n\n  var output = this.output;\n\n  // copy to output buffer\n  {\n    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));\n  }\n\n  this.blocks.push(buffer);\n  this.totalpos += buffer.length;\n\n  // copy to backward buffer\n  {\n    output.set(\n      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)\n    );\n  }\n\n  this.op = Zlib.RawInflate.MaxBackwardLength;\n\n  return output;\n};\n\n/**\n * expand output buffer. (adaptive)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array.<number>|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {\n  /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = (this.input.length / this.ip + 1) | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode =\n      (input.length - this.ip) / this.currentLitlenTable[2];\n    maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n    newSize = maxInflateSize < output.length ?\n      output.length + maxInflateSize :\n      output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer.\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferBlock = function() {\n  /** @type {number} buffer pointer. */\n  var pos = 0;\n  /** @type {number} buffer pointer. */\n  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var output = this.output;\n  /** @type {!Array} blocks array. */\n  var blocks = this.blocks;\n  /** @type {!(Array.<number>|Uint8Array)} output block array. */\n  var block;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  var buffer = new ( Uint8Array )(limit);\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {number} loop counter. */\n  var j;\n  /** @type {number} loop limiter. */\n  var jl;\n\n  // single buffer\n  if (blocks.length === 0) {\n    return       this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) ;\n  }\n\n  // copy to buffer\n  for (i = 0, il = blocks.length; i < il; ++i) {\n    block = blocks[i];\n    for (j = 0, jl = block.length; j < jl; ++j) {\n      buffer[pos++] = block[j];\n    }\n  }\n\n  // current buffer\n  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\n    buffer[pos++] = output[i];\n  }\n\n  this.blocks = [];\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array.<number>|Uint8Array)} output buffer.\n */\nZlib.RawInflate.prototype.concatBufferDynamic = function() {\n  /** @type {Array.<number>|Uint8Array} output buffer. */\n  var buffer;\n  var op = this.op;\n\n  {\n    if (this.resize) {\n      buffer = new Uint8Array(op);\n      buffer.set(this.output.subarray(0, op));\n    } else {\n      buffer = this.output.subarray(0, op);\n    }\n  }\n\n  this.buffer = buffer;\n\n  return this.buffer;\n};\n\n\n\n\nvar buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;\n\n/**\n * @param {!(Uint8Array|Array.<number>)} input input buffer.\n * @param {number} ip input buffer pointer.\n * @param {number=} opt_buffersize buffer block size.\n * @constructor\n */\nZlib.RawInflateStream = function(input, ip, opt_buffersize) {\n  /** @type {!Array.<(Array|Uint8Array)>} */\n  this.blocks = [];\n  /** @type {number} block size. */\n  this.bufferSize =\n    opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\n  /** @type {!number} total output buffer pointer. */\n  this.totalpos = 0;\n  /** @type {!number} input buffer pointer. */\n  this.ip = ip === void 0 ? 0 : ip;\n  /** @type {!number} bit stream reader buffer. */\n  this.bitsbuf = 0;\n  /** @type {!number} bit stream reader buffer size. */\n  this.bitsbuflen = 0;\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  this.input =  new Uint8Array(input) ;\n  /** @type {!(Uint8Array|Array)} output buffer. */\n  this.output = new ( Uint8Array )(this.bufferSize);\n  /** @type {!number} output buffer pointer. */\n  this.op = 0;\n  /** @type {boolean} is final block flag. */\n  this.bfinal = false;\n  /** @type {number} uncompressed block length. */\n  this.blockLength;\n  /** @type {boolean} resize flag for memory size optimization. */\n  this.resize = false;\n  /** @type {Array} */\n  this.litlenTable;\n  /** @type {Array} */\n  this.distTable;\n  /** @type {number} */\n  this.sp = 0; // stream pointer\n  /** @type {Zlib.RawInflateStream.Status} */\n  this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n\n  //\n  // backup\n  //\n  /** @type {!number} */\n  this.ip_;\n  /** @type {!number} */\n  this.bitsbuflen_;\n  /** @type {!number} */\n  this.bitsbuf_;\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.BlockType = {\n  UNCOMPRESSED: 0,\n  FIXED: 1,\n  DYNAMIC: 2\n};\n\n/**\n * @enum {number}\n */\nZlib.RawInflateStream.Status = {\n  INITIALIZED: 0,\n  BLOCK_HEADER_START: 1,\n  BLOCK_HEADER_END: 2,\n  BLOCK_BODY_START: 3,\n  BLOCK_BODY_END: 4,\n  DECODE_BLOCK_START: 5,\n  DECODE_BLOCK_END: 6\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.RawInflateStream.prototype.decompress = function(newInput, ip) {\n  /** @type {boolean} */\n  var stop = false;\n\n  if (newInput !== void 0) {\n    this.input = newInput;\n  }\n\n  if (ip !== void 0) {\n    this.ip = ip;\n  }\n\n  // decompress\n  while (!stop) {\n    switch (this.status) {\n      // block header\n      case Zlib.RawInflateStream.Status.INITIALIZED:\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:\n        if (this.readBlockHeader() < 0) {\n          stop = true;\n        }\n        break;\n      // block body\n      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:\n        switch(this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.readUncompressedBlockHeader() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED:\n            if (this.parseFixedHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.parseDynamicHuffmanBlock() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      // decode data\n      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:\n        switch(this.currentBlockType) {\n          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:\n            if (this.parseUncompressedBlock() < 0) {\n              stop = true;\n            }\n            break;\n          case Zlib.RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\n          case Zlib.RawInflateStream.BlockType.DYNAMIC:\n            if (this.decodeHuffman() < 0) {\n              stop = true;\n            }\n            break;\n        }\n        break;\n      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:\n        if (this.bfinal) {\n          stop = true;\n        } else {\n          this.status = Zlib.RawInflateStream.Status.INITIALIZED;\n        }\n        break;\n    }\n  }\n\n  return this.concatBuffer();\n};\n\n/**\n * @const\n * @type {number} max backward length for LZ77.\n */\nZlib.RawInflateStream.MaxBackwardLength = 32768;\n\n/**\n * @const\n * @type {number} max copy length for LZ77.\n */\nZlib.RawInflateStream.MaxCopyLength = 258;\n\n/**\n * huffman order\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.Order = (function(table) {\n  return  new Uint16Array(table) ;\n})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n/**\n * huffman length code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.LengthCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n  0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n  0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n  0x00e3, 0x0102, 0x0102, 0x0102\n]);\n\n/**\n * huffman length extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.LengthExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n  5, 5, 0, 0, 0\n]);\n\n/**\n * huffman dist code table.\n * @const\n * @type {!(Array.<number>|Uint16Array)}\n */\nZlib.RawInflateStream.DistCodeTable = (function(table) {\n  return  new Uint16Array(table) ;\n})([\n  0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n  0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n  0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n  0x3001, 0x4001, 0x6001\n]);\n\n/**\n * huffman dist extra-bits table.\n * @const\n * @type {!(Array.<number>|Uint8Array)}\n */\nZlib.RawInflateStream.DistExtraTable = (function(table) {\n  return  new Uint8Array(table) ;\n})([\n  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n  11, 12, 12, 13, 13\n]);\n\n/**\n * fixed huffman length code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedLiteralLengthTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(288);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] =\n      (i <= 143) ? 8 :\n      (i <= 255) ? 9 :\n      (i <= 279) ? 7 :\n      8;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * fixed huffman distance code table\n * @const\n * @type {!Array}\n */\nZlib.RawInflateStream.FixedDistanceTable = (function(table) {\n  return table;\n})((function() {\n  var lengths = new ( Uint8Array )(30);\n  var i, il;\n\n  for (i = 0, il = lengths.length; i < il; ++i) {\n    lengths[i] = 5;\n  }\n\n  return buildHuffmanTable(lengths);\n})());\n\n/**\n * parse deflated block.\n */\nZlib.RawInflateStream.prototype.readBlockHeader = function() {\n  /** @type {number} header */\n  var hdr;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;\n\n  this.save_();\n  if ((hdr = this.readBits(3)) < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  // BFINAL\n  if (hdr & 0x1) {\n    this.bfinal = true;\n  }\n\n  // BTYPE\n  hdr >>>= 1;\n  switch (hdr) {\n    case 0: // uncompressed\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;\n      break;\n    case 1: // fixed huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;\n      break;\n    case 2: // dynamic huffman\n      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;\n      break;\n    default: // reserved or other\n      throw new Error('unknown BTYPE: ' + hdr);\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;\n};\n\n/**\n * read inflate bits\n * @param {number} length bits length.\n * @return {number} read bits.\n */\nZlib.RawInflateStream.prototype.readBits = function(length) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {number} input and output byte. */\n  var octet;\n\n  // not enough buffer\n  while (bitsbuflen < length) {\n    // input byte\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n\n    // concat octet\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // output byte\n  octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n  bitsbuf >>>= length;\n  bitsbuflen -= length;\n\n  this.bitsbuf = bitsbuf;\n  this.bitsbuflen = bitsbuflen;\n  this.ip = ip;\n\n  return octet;\n};\n\n/**\n * read huffman code using table\n * @param {Array} table huffman code table.\n * @return {number} huffman code.\n */\nZlib.RawInflateStream.prototype.readCodeByTable = function(table) {\n  var bitsbuf = this.bitsbuf;\n  var bitsbuflen = this.bitsbuflen;\n  var input = this.input;\n  var ip = this.ip;\n\n  /** @type {!(Array|Uint8Array)} huffman code table */\n  var codeTable = table[0];\n  /** @type {number} */\n  var maxCodeLength = table[1];\n  /** @type {number} input byte */\n  var octet;\n  /** @type {number} code length & code (16bit, 16bit) */\n  var codeWithLength;\n  /** @type {number} code bits length */\n  var codeLength;\n\n  // not enough buffer\n  while (bitsbuflen < maxCodeLength) {\n    if (input.length <= ip) {\n      return -1;\n    }\n    octet = input[ip++];\n    bitsbuf |= octet << bitsbuflen;\n    bitsbuflen += 8;\n  }\n\n  // read max length\n  codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n  codeLength = codeWithLength >>> 16;\n\n  if (codeLength > bitsbuflen) {\n    throw new Error('invalid code length: ' + codeLength);\n  }\n\n  this.bitsbuf = bitsbuf >> codeLength;\n  this.bitsbuflen = bitsbuflen - codeLength;\n  this.ip = ip;\n\n  return codeWithLength & 0xffff;\n};\n\n/**\n * read uncompressed block header\n */\nZlib.RawInflateStream.prototype.readUncompressedBlockHeader = function() {\n  /** @type {number} block length */\n  var len;\n  /** @type {number} number for check block length */\n  var nlen;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  if (ip + 4 >= input.length) {\n    return -1;\n  }\n\n  len = input[ip++] | (input[ip++] << 8);\n  nlen = input[ip++] | (input[ip++] << 8);\n\n  // check len & nlen\n  if (len === ~nlen) {\n    throw new Error('invalid uncompressed block header: length verify');\n  }\n\n  // skip buffered header bits\n  this.bitsbuf = 0;\n  this.bitsbuflen = 0;\n\n  this.ip = ip;\n  this.blockLength = len;\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n};\n\n/**\n * parse uncompressed block.\n */\nZlib.RawInflateStream.prototype.parseUncompressedBlock = function() {\n  var input = this.input;\n  var ip = this.ip;\n  var output = this.output;\n  var op = this.op;\n  var len = this.blockLength;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  // copy\n  // XXX: \n  while (len--) {\n    if (op === output.length) {\n      output = this.expandBuffer({fixRatio: 2});\n    }\n\n    // not enough input buffer\n    if (ip >= input.length) {\n      this.ip = ip;\n      this.op = op;\n      this.blockLength = len + 1; // \n      return -1;\n    }\n\n    output[op++] = input[ip++];\n  }\n\n  if (len < 0) {\n    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n  }\n\n  this.ip = ip;\n  this.op = op;\n\n  return 0;\n};\n\n/**\n * parse fixed huffman block.\n */\nZlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function() {\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;\n  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * .\n * @private\n */\nZlib.RawInflateStream.prototype.save_ = function() {\n  this.ip_ = this.ip;\n  this.bitsbuflen_ = this.bitsbuflen;\n  this.bitsbuf_ = this.bitsbuf;\n};\n\n/**\n * .\n * @private\n */\nZlib.RawInflateStream.prototype.restore_ = function() {\n  this.ip = this.ip_;\n  this.bitsbuflen = this.bitsbuflen_;\n  this.bitsbuf = this.bitsbuf_;\n};\n\n/**\n * parse dynamic huffman block.\n */\nZlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {\n  /** @type {number} number of literal and length codes. */\n  var hlit;\n  /** @type {number} number of distance codes. */\n  var hdist;\n  /** @type {number} number of code lengths. */\n  var hclen;\n  /** @type {!(Uint8Array|Array)} code lengths. */\n  var codeLengths =\n    new ( Uint8Array )(Zlib.RawInflateStream.Order.length);\n  /** @type {!Array} code lengths table. */\n  var codeLengthsTable;\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;\n\n  this.save_();\n  hlit = this.readBits(5) + 257;\n  hdist = this.readBits(5) + 1;\n  hclen = this.readBits(4) + 4;\n  if (hlit < 0 || hdist < 0 || hclen < 0) {\n    this.restore_();\n    return -1;\n  }\n\n  try {\n    parseDynamicHuffmanBlockImpl.call(this);\n  } catch(e) {\n    this.restore_();\n    return -1;\n  }\n\n  function parseDynamicHuffmanBlockImpl() {\n    /** @type {number} */\n    var bits;\n    var code;\n    var prev = 0;\n    var repeat;\n    /** @type {!(Uint8Array|Array.<number>)} code length table. */\n    var lengthTable;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limit. */\n    var il;\n\n    // decode code lengths\n    for (i = 0; i < hclen; ++i) {\n      if ((bits = this.readBits(3)) < 0) {\n        throw new Error('not enough input');\n      }\n      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;\n    }\n\n    // decode length table\n    codeLengthsTable = buildHuffmanTable(codeLengths);\n    lengthTable = new ( Uint8Array )(hlit + hdist);\n    for (i = 0, il = hlit + hdist; i < il;) {\n      code = this.readCodeByTable(codeLengthsTable);\n      if (code < 0) {\n        throw new Error('not enough input');\n      }\n      switch (code) {\n        case 16:\n          if ((bits = this.readBits(2)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) { lengthTable[i++] = prev; }\n          break;\n        case 17:\n          if ((bits = this.readBits(3)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 3 + bits;\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        case 18:\n          if ((bits = this.readBits(7)) < 0) {\n            throw new Error('not enough input');\n          }\n          repeat = 11 + bits;\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        default:\n          lengthTable[i++] = code;\n          prev = code;\n          break;\n      }\n    }\n\n    this.litlenTable =  buildHuffmanTable(lengthTable.subarray(0, hlit))\n      ;\n    this.distTable =  buildHuffmanTable(lengthTable.subarray(hlit))\n      ;\n  }\n\n  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;\n\n  return 0;\n};\n\n/**\n * decode huffman code (dynamic)\n * @return {(number|undefined)} -1 is error.\n */\nZlib.RawInflateStream.prototype.decodeHuffman = function() {\n  var output = this.output;\n  var op = this.op;\n\n  /** @type {number} huffman code. */\n  var code;\n  /** @type {number} table index. */\n  var ti;\n  /** @type {number} huffman code distination. */\n  var codeDist;\n  /** @type {number} huffman code length. */\n  var codeLength;\n\n  var litlen = this.litlenTable;\n  var dist = this.distTable;\n\n  var olength = output.length;\n  var bits;\n\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;\n\n  while (true) {\n    this.save_();\n\n    code = this.readCodeByTable(litlen);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n\n    if (code === 256) {\n      break;\n    }\n\n    // literal\n    if (code < 256) {\n      if (op === olength) {\n        output = this.expandBuffer();\n        olength = output.length;\n      }\n      output[op++] = code;\n\n      continue;\n    }\n\n    // length code\n    ti = code - 257;\n    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];\n    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeLength += bits;\n    }\n\n    // dist code\n    code = this.readCodeByTable(dist);\n    if (code < 0) {\n      this.op = op;\n      this.restore_();\n      return -1;\n    }\n    codeDist = Zlib.RawInflateStream.DistCodeTable[code];\n    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {\n      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);\n      if (bits < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeDist += bits;\n    }\n\n    // lz77 decode\n    if (op + codeLength >= olength) {\n      output = this.expandBuffer();\n      olength = output.length;\n    }\n\n    while (codeLength--) {\n      output[op] = output[(op++) - codeDist];\n    }\n\n    // break\n    if (this.ip === this.input.length) {\n      this.op = op;\n      return -1;\n    }\n  }\n\n  while (this.bitsbuflen >= 8) {\n    this.bitsbuflen -= 8;\n    this.ip--;\n  }\n\n  this.op = op;\n  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;\n};\n\n/**\n * expand output buffer. (dynamic)\n * @param {Object=} opt_param option parameters.\n * @return {!(Array|Uint8Array)} output buffer pointer.\n */\nZlib.RawInflateStream.prototype.expandBuffer = function(opt_param) {\n  /** @type {!(Array|Uint8Array)} store buffer. */\n  var buffer;\n  /** @type {number} expantion ratio. */\n  var ratio = (this.input.length / this.ip + 1) | 0;\n  /** @type {number} maximum number of huffman code. */\n  var maxHuffCode;\n  /** @type {number} new output buffer size. */\n  var newSize;\n  /** @type {number} max inflate size. */\n  var maxInflateSize;\n\n  var input = this.input;\n  var output = this.output;\n\n  if (opt_param) {\n    if (typeof opt_param.fixRatio === 'number') {\n      ratio = opt_param.fixRatio;\n    }\n    if (typeof opt_param.addRatio === 'number') {\n      ratio += opt_param.addRatio;\n    }\n  }\n\n  // calculate new buffer size\n  if (ratio < 2) {\n    maxHuffCode =\n      (input.length - this.ip) / this.litlenTable[2];\n    maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n    newSize = maxInflateSize < output.length ?\n      output.length + maxInflateSize :\n      output.length << 1;\n  } else {\n    newSize = output.length * ratio;\n  }\n\n  // buffer expantion\n  {\n    buffer = new Uint8Array(newSize);\n    buffer.set(output);\n  }\n\n  this.output = buffer;\n\n  return this.output;\n};\n\n/**\n * concat output buffer. (dynamic)\n * @return {!(Array|Uint8Array)} output buffer.\n */\nZlib.RawInflateStream.prototype.concatBuffer = function() {\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var buffer;\n  /** @type {number} */\n  var op = this.op;\n  /** @type {Uint8Array} */\n  var tmp;\n\n  if (this.resize) {\n    {\n      buffer = new Uint8Array(this.output.subarray(this.sp, op));\n    }\n  } else {\n    buffer =\n       this.output.subarray(this.sp, op) ;\n  }\n\n  this.sp = op;\n\n  // compaction\n  if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {\n    this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;\n    {\n      tmp = /** @type {Uint8Array} */(this.output);\n      this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);\n      this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));\n    }\n  }\n\n  return buffer;\n};\n\n\n/**\n * @constructor\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @param {Object=} opt_params option parameters.\n *\n * opt_params \n *   - index: input buffer  deflate .\n *   - blockSize: .\n *   - verify:  adler-32 checksum .\n *   - bufferType: Zlib.Inflate.BufferType .\n *       Zlib.Inflate.BufferType  Zlib.RawInflate.BufferType .\n */\nZlib.Inflate = function(input, opt_params) {\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflate} */\n  this.rawinflate;\n  /** @type {(boolean|undefined)} verify flag. */\n  this.verify;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (opt_params['index']) {\n      this.ip = opt_params['index'];\n    }\n    if (opt_params['verify']) {\n      this.verify = opt_params['verify'];\n    }\n  }\n\n  // Compression Method and Flags\n  cmf = input[this.ip++];\n  flg = input[this.ip++];\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  // RawInflate\n  this.rawinflate = new Zlib.RawInflate(input, {\n    'index': this.ip,\n    'bufferSize': opt_params['bufferSize'],\n    'bufferType': opt_params['bufferType'],\n    'resize': opt_params['resize']\n  });\n};\n\n/**\n * @enum {number}\n */\nZlib.Inflate.BufferType = Zlib.RawInflate.BufferType;\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.Inflate.prototype.decompress = function() {\n  /** @type {!(Array|Uint8Array)} input buffer. */\n  var input = this.input;\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n  /** @type {number} adler-32 checksum */\n  var adler32;\n\n  buffer = this.rawinflate.decompress();\n  this.ip = this.rawinflate.ip;\n\n  // verify adler-32\n  if (this.verify) {\n    adler32 = (\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\n      input[this.ip++] << 8 | input[this.ip++]\n    ) >>> 0;\n\n    if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n\n  return buffer;\n};\n\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n\n/**\n * @param {!(Uint8Array|Array)} input deflated buffer.\n * @constructor\n */\nZlib.InflateStream = function(input) {\n  /** @type {!(Uint8Array|Array)} */\n  this.input = input === void 0 ? new ( Uint8Array )() : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {Zlib.RawInflateStream} */\n  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);\n  /** @type {Zlib.CompressionMethod} */\n  this.method;\n  /** @type {!(Array|Uint8Array)} */\n  this.output = this.rawinflate.output;\n};\n\n/**\n * decompress.\n * @return {!(Uint8Array|Array)} inflated buffer.\n */\nZlib.InflateStream.prototype.decompress = function(input) {\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\n  var buffer;\n\n  // \n  // XXX Array, Uint8Array \n  if (input !== void 0) {\n    {\n      var tmp = new Uint8Array(this.input.length + input.length);\n      tmp.set(this.input, 0);\n      tmp.set(input, this.input.length);\n      this.input = tmp;\n    }\n  }\n\n  if (this.method === void 0) {\n    if(this.readHeader() < 0) {\n      return new ( Uint8Array )();\n    }\n  }\n\n  buffer = this.rawinflate.decompress(this.input, this.ip);\n  if (this.rawinflate.ip !== 0) {\n    this.input = \n      this.input.subarray(this.rawinflate.ip) ;\n    this.ip = 0;\n  }\n\n  // verify adler-32\n  /*\n  if (this.verify) {\n    adler32 =\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\n      input[this.ip++] << 8 | input[this.ip++];\n\n    if (adler32 !== Zlib.Adler32(buffer)) {\n      throw new Error('invalid adler-32 checksum');\n    }\n  }\n  */\n\n  return buffer;\n};\n\nZlib.InflateStream.prototype.readHeader = function() {\n  var ip = this.ip;\n  var input = this.input;\n\n  // Compression Method and Flags\n  var cmf = input[ip++];\n  var flg = input[ip++];\n\n  if (cmf === void 0 || flg === void 0) {\n    return -1;\n  }\n\n  // compression method\n  switch (cmf & 0x0f) {\n    case Zlib.CompressionMethod.DEFLATE:\n      this.method = Zlib.CompressionMethod.DEFLATE;\n      break;\n    default:\n      throw new Error('unsupported compression method');\n  }\n\n  // fcheck\n  if (((cmf << 8) + flg) % 31 !== 0) {\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\n  }\n\n  // fdict (not supported)\n  if (flg & 0x20) {\n    throw new Error('fdict flag is not supported');\n  }\n\n  this.ip = ip;\n};\n\n\n/**\n * @fileoverview GZIP (RFC1952) .\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gunzip = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {Array.<Zlib.GunzipMember>} */\n  this.member = [];\n  /** @type {boolean} */\n  this.decompressed = false;\n};\n\n/**\n * @return {Array.<Zlib.GunzipMember>}\n */\nZlib.Gunzip.prototype.getMembers = function() {\n  if (!this.decompressed) {\n    this.decompress();\n  }\n\n  return this.member.slice();\n};\n\n/**\n * inflate gzip data.\n * @return {!(Array.<number>|Uint8Array)} inflated buffer.\n */\nZlib.Gunzip.prototype.decompress = function() {\n  /** @type {number} input length. */\n  var il = this.input.length;\n\n  while (this.ip < il) {\n    this.decodeMember();\n  }\n\n  this.decompressed = true;\n\n  return this.concatMember();\n};\n\n/**\n * decode gzip member.\n */\nZlib.Gunzip.prototype.decodeMember = function() {\n  /** @type {Zlib.GunzipMember} */\n  var member = new Zlib.GunzipMember();\n  /** @type {number} */\n  var isize;\n  /** @type {Zlib.RawInflate} RawInflate implementation. */\n  var rawinflate;\n  /** @type {!(Array.<number>|Uint8Array)} inflated data. */\n  var inflated;\n  /** @type {number} inflate size */\n  var inflen;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} character index in string. */\n  var ci;\n  /** @type {Array.<string>} character array. */\n  var str;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} */\n  var crc32;\n\n  var input = this.input;\n  var ip = this.ip;\n\n  member.id1 = input[ip++];\n  member.id2 = input[ip++];\n\n  // check signature\n  if (member.id1 !== 0x1f || member.id2 !== 0x8b) {\n    throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);\n  }\n\n  // check compression method\n  member.cm = input[ip++];\n  switch (member.cm) {\n    case 8: /* XXX: use Zlib const */\n      break;\n    default:\n      throw new Error('unknown compression method: ' + member.cm);\n  }\n\n  // flags\n  member.flg = input[ip++];\n\n  // modification time\n  mtime = (input[ip++])       |\n          (input[ip++] << 8)  |\n          (input[ip++] << 16) |\n          (input[ip++] << 24);\n  member.mtime = new Date(mtime * 1000);\n\n  // extra flags\n  member.xfl = input[ip++];\n\n  // operating system\n  member.os = input[ip++];\n\n  // extra\n  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {\n    member.xlen = input[ip++] | (input[ip++] << 8);\n    ip = this.decodeSubField(ip, member.xlen);\n  }\n\n  // fname\n  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {\n    for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.name = str.join('');\n  }\n\n  // fcomment\n  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {\n    for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n      str[ci++] = String.fromCharCode(c);\n    }\n    member.comment = str.join('');\n  }\n\n  // fhcrc\n  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {\n    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;\n    if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {\n      throw new Error('invalid header crc16');\n    }\n  }\n\n  // isize \n  // inflate\n  isize = (input[input.length - 4])       | (input[input.length - 3] << 8) |\n          (input[input.length - 2] << 16) | (input[input.length - 1] << 24);\n\n  // isize \n  //  2-bit  1/4 \n  // LZ77   2-Byte  258-Byte \n  // 1/128 \n  //  isize  512 \n  // \n  if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {\n    inflen = isize;\n  }\n\n  // compressed block\n  rawinflate = new Zlib.RawInflate(input, {'index': ip, 'bufferSize': inflen});\n  member.data = inflated = rawinflate.decompress();\n  ip = rawinflate.ip;\n\n  // crc32\n  member.crc32 = crc32 =\n    ((input[ip++])       | (input[ip++] << 8) |\n     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n  if (Zlib.CRC32.calc(inflated) !== crc32) {\n    throw new Error('invalid CRC-32 checksum: 0x' +\n        Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));\n  }\n\n  // input size\n  member.isize = isize =\n    ((input[ip++])       | (input[ip++] << 8) |\n     (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n  if ((inflated.length & 0xffffffff) !== isize) {\n    throw new Error('invalid input size: ' +\n        (inflated.length & 0xffffffff) + ' / ' + isize);\n  }\n\n  this.member.push(member);\n  this.ip = ip;\n};\n\n/**\n * \n * XXX: \n */\nZlib.Gunzip.prototype.decodeSubField = function(ip, length) {\n  return ip + length;\n};\n\n/**\n * @return {!(Array.<number>|Uint8Array)}\n */\nZlib.Gunzip.prototype.concatMember = function() {\n  /** @type {Array.<Zlib.GunzipMember>} */\n  var member = this.member;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {number} */\n  var p = 0;\n  /** @type {number} */\n  var size = 0;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n\n  for (i = 0, il = member.length; i < il; ++i) {\n    size += member[i].data.length;\n  }\n\n  {\n    buffer = new Uint8Array(size);\n    for (i = 0; i < il; ++i) {\n      buffer.set(member[i].data, p);\n      p += member[i].data.length;\n    }\n  }\n\n  return buffer;\n};\n\n\n\n/**\n * @constructor\n */\nZlib.GunzipMember = function() {\n  /** @type {number} signature first byte. */\n  this.id1;\n  /** @type {number} signature second byte. */\n  this.id2;\n  /** @type {number} compression method. */\n  this.cm;\n  /** @type {number} flags. */\n  this.flg;\n  /** @type {Date} modification time. */\n  this.mtime;\n  /** @type {number} extra flags. */\n  this.xfl;\n  /** @type {number} operating system number. */\n  this.os;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  this.crc16;\n  /** @type {number} extra length. */\n  this.xlen;\n  /** @type {number} CRC-32 value for verification. */\n  this.crc32;\n  /** @type {number} input size modulo 32 value. */\n  this.isize;\n  /** @type {string} filename. */\n  this.name;\n  /** @type {string} comment. */\n  this.comment;\n  /** @type {!(Uint8Array|Array.<number>)} */\n  this.data;\n};\n\nZlib.GunzipMember.prototype.getName = function() {\n  return this.name;\n};\n\nZlib.GunzipMember.prototype.getData = function() {\n  return this.data;\n};\n\nZlib.GunzipMember.prototype.getMtime = function() {\n  return this.mtime;\n};\n\n/**\n * @fileoverview GZIP (RFC1952) .\n */\n\n/**\n * @constructor\n * @param {!(Array|Uint8Array)} input input buffer.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Gzip = function(input, opt_params) {\n  /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n  this.input = input;\n  /** @type {number} input buffer pointer. */\n  this.ip = 0;\n  /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n  this.output;\n  /** @type {number} output buffer. */\n  this.op = 0;\n  /** @type {!Object} flags option flags. */\n  this.flags = {};\n  /** @type {!string} filename. */\n  this.filename;\n  /** @type {!string} comment. */\n  this.comment;\n  /** @type {!Object} deflate options. */\n  this.deflateOptions;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['flags']) {\n      this.flags = opt_params['flags'];\n    }\n    if (typeof opt_params['filename'] === 'string') {\n      this.filename = opt_params['filename'];\n    }\n    if (typeof opt_params['comment'] === 'string') {\n      this.comment = opt_params['comment'];\n    }\n    if (opt_params['deflateOptions']) {\n      this.deflateOptions = opt_params['deflateOptions'];\n    }\n  }\n\n  if (!this.deflateOptions) {\n    this.deflateOptions = {};\n  }\n};\n\n/**\n * @type {number}\n * @const\n */\nZlib.Gzip.DefaultBufferSize = 0x8000;\n\n/**\n * encode gzip members.\n * @return {!(Array|Uint8Array)} gzip binary array.\n */\nZlib.Gzip.prototype.compress = function() {\n  /** @type {number} flags. */\n  var flg;\n  /** @type {number} modification time. */\n  var mtime;\n  /** @type {number} CRC-16 value for FHCRC flag. */\n  var crc16;\n  /** @type {number} CRC-32 value for verification. */\n  var crc32;\n  /** @type {!Zlib.RawDeflate} raw deflate object. */\n  var rawdeflate;\n  /** @type {number} character code */\n  var c;\n  /** @type {number} loop counter. */\n  var i;\n  /** @type {number} loop limiter. */\n  var il;\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output =\n    new ( Uint8Array )(Zlib.Gzip.DefaultBufferSize);\n  /** @type {number} output buffer pointer. */\n  var op = 0;\n\n  var input = this.input;\n  var ip = this.ip;\n  var filename = this.filename;\n  var comment = this.comment;\n\n  // check signature\n  output[op++] = 0x1f;\n  output[op++] = 0x8b;\n\n  // check compression method\n  output[op++] = 8; /* XXX: use Zlib const */\n\n  // flags\n  flg = 0;\n  if (this.flags['fname'])    flg |= Zlib.Gzip.FlagsMask.FNAME;\n  if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;\n  if (this.flags['fhcrc'])    flg |= Zlib.Gzip.FlagsMask.FHCRC;\n  // XXX: FTEXT\n  // XXX: FEXTRA\n  output[op++] = flg;\n\n  // modification time\n  mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;\n  output[op++] = mtime        & 0xff;\n  output[op++] = mtime >>>  8 & 0xff;\n  output[op++] = mtime >>> 16 & 0xff;\n  output[op++] = mtime >>> 24 & 0xff;\n\n  // extra flags\n  output[op++] = 0;\n\n  // operating system\n  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;\n\n  // extra\n  /* NOP */\n\n  // fname\n  if (this.flags['fname'] !== void 0) {\n    for (i = 0, il = filename.length; i < il; ++i) {\n      c = filename.charCodeAt(i);\n      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fcomment\n  if (this.flags['comment']) {\n    for (i = 0, il = comment.length; i < il; ++i) {\n      c = comment.charCodeAt(i);\n      if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\n      output[op++] = c & 0xff;\n    }\n    output[op++] = 0; // null termination\n  }\n\n  // fhcrc\n  if (this.flags['fhcrc']) {\n    crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;\n    output[op++] = (crc16      ) & 0xff;\n    output[op++] = (crc16 >>> 8) & 0xff;\n  }\n\n  // add compress option\n  this.deflateOptions['outputBuffer'] = output;\n  this.deflateOptions['outputIndex'] = op;\n\n  // compress\n  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);\n  output = rawdeflate.compress();\n  op = rawdeflate.op;\n\n  // expand buffer\n  {\n    if (op + 8 > output.buffer.byteLength) {\n      this.output = new Uint8Array(op + 8);\n      this.output.set(new Uint8Array(output.buffer));\n      output = this.output;\n    } else {\n      output = new Uint8Array(output.buffer);\n    }\n  }\n\n  // crc32\n  crc32 = Zlib.CRC32.calc(input);\n  output[op++] = (crc32       ) & 0xff;\n  output[op++] = (crc32 >>>  8) & 0xff;\n  output[op++] = (crc32 >>> 16) & 0xff;\n  output[op++] = (crc32 >>> 24) & 0xff;\n\n  // input size\n  il = input.length;\n  output[op++] = (il       ) & 0xff;\n  output[op++] = (il >>>  8) & 0xff;\n  output[op++] = (il >>> 16) & 0xff;\n  output[op++] = (il >>> 24) & 0xff;\n\n  this.ip = ip;\n\n  if ( op < output.length) {\n    this.output = output = output.subarray(0, op);\n  }\n\n  return output;\n};\n\n/** @enum {number} */\nZlib.Gzip.OperatingSystem = {\n  FAT: 0,\n  AMIGA: 1,\n  VMS: 2,\n  UNIX: 3,\n  VM_CMS: 4,\n  ATARI_TOS: 5,\n  HPFS: 6,\n  MACINTOSH: 7,\n  Z_SYSTEM: 8,\n  CP_M: 9,\n  TOPS_20: 10,\n  NTFS: 11,\n  QDOS: 12,\n  ACORN_RISCOS: 13,\n  UNKNOWN: 255\n};\n\n/** @enum {number} */\nZlib.Gzip.FlagsMask = {\n  FTEXT: 0x01,\n  FHCRC: 0x02,\n  FEXTRA: 0x04,\n  FNAME: 0x08,\n  FCOMMENT: 0x10\n};\n\n\n/**\n * @fileoverview Heap Sort . .\n */\n\n/**\n * \n * @param {number} length .\n * @constructor\n */\nZlib.Heap = function(length) {\n  this.buffer = new ( Uint16Array )(length * 2);\n  this.length = 0;\n};\n\n/**\n *  index \n * @param {number} index  index.\n * @return {number}  index.\n *\n */\nZlib.Heap.prototype.getParent = function(index) {\n  return ((index - 2) / 4 | 0) * 2;\n};\n\n/**\n *  index \n * @param {number} index  index.\n * @return {number}  index.\n */\nZlib.Heap.prototype.getChild = function(index) {\n  return 2 * index + 2;\n};\n\n/**\n * Heap \n * @param {number} index  index.\n * @param {number} value .\n * @return {number} .\n */\nZlib.Heap.prototype.push = function(index, value) {\n  var current, parent,\n      heap = this.buffer,\n      swap;\n\n  current = this.length;\n  heap[this.length++] = value;\n  heap[this.length++] = index;\n\n  // \n  while (current > 0) {\n    parent = this.getParent(current);\n\n    // \n    if (heap[current] > heap[parent]) {\n      swap = heap[current];\n      heap[current] = heap[parent];\n      heap[parent] = swap;\n\n      swap = heap[current + 1];\n      heap[current + 1] = heap[parent + 1];\n      heap[parent + 1] = swap;\n\n      current = parent;\n    // \n    } else {\n      break;\n    }\n  }\n\n  return this.length;\n};\n\n/**\n * Heap\n * @return {{index: number, value: number, length: number}} {index: index,\n *     value: , length: }  Object.\n */\nZlib.Heap.prototype.pop = function() {\n  var index, value,\n      heap = this.buffer, swap,\n      current, parent;\n\n  value = heap[0];\n  index = heap[1];\n\n  // \n  this.length -= 2;\n  heap[0] = heap[this.length];\n  heap[1] = heap[this.length + 1];\n\n  parent = 0;\n  // \n  while (true) {\n    current = this.getChild(parent);\n\n    // \n    if (current >= this.length) {\n      break;\n    }\n\n    // \n    if (current + 2 < this.length && heap[current + 2] > heap[current]) {\n      current += 2;\n    }\n\n    // \n    if (heap[current] > heap[parent]) {\n      swap = heap[parent];\n      heap[parent] = heap[current];\n      heap[current] = swap;\n\n      swap = heap[parent + 1];\n      heap[parent + 1] = heap[current + 1];\n      heap[current + 1] = swap;\n    } else {\n      break;\n    }\n\n    parent = current;\n  }\n\n  return {index: index, value: value, length: this.length};\n};\n\n\n/* vim:set expandtab ts=2 sw=2 tw=80: */\n\n/**\n * @fileoverview Deflate (RFC1951) .\n */\n\n\n/**\n * Raw Deflate \n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} input .\n * @param {Object=} opt_params option parameters.\n *\n * typed array outputBuffer  Array  Uint8Array \n * .\n * \n * .\n */\nZlib.RawDeflate = function(input, opt_params) {\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;\n  /** @type {number} */\n  this.lazy = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsLitLen;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  this.freqsDist;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input =\n    ( input instanceof Array) ? new Uint8Array(input) : input;\n  /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\n  this.output;\n  /** @type {number} pos output buffer position. */\n  this.op = 0;\n\n  // option parameters\n  if (opt_params) {\n    if (opt_params['lazy']) {\n      this.lazy = opt_params['lazy'];\n    }\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n    if (opt_params['outputBuffer']) {\n      this.output =\n        ( opt_params['outputBuffer'] instanceof Array) ?\n        new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\n    }\n    if (typeof opt_params['outputIndex'] === 'number') {\n      this.op = opt_params['outputIndex'];\n    }\n  }\n\n  if (!this.output) {\n    this.output = new ( Uint8Array )(0x8000);\n  }\n};\n\n/**\n * @enum {number}\n */\nZlib.RawDeflate.CompressionType = {\n  NONE: 0,\n  FIXED: 1,\n  DYNAMIC: 2,\n  RESERVED: 3\n};\n\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MinLength = 3;\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.Lz77MaxLength = 258;\n\n/**\n * LZ77 \n * @const\n * @type {number}\n */\nZlib.RawDeflate.WindowSize = 0x8000;\n\n/**\n * \n * @const\n * @type {number}\n */\nZlib.RawDeflate.MaxCodeLength = 16;\n\n/**\n * \n * @const\n * @type {number}\n */\nZlib.RawDeflate.HUFMAX = 286;\n\n/**\n * \n * @const\n * @type {Array.<Array.<number, number>>}\n */\nZlib.RawDeflate.FixedHuffmanTable = (function() {\n  var table = [], i;\n\n  for (i = 0; i < 288; i++) {\n    switch (true) {\n      case (i <= 143): table.push([i       + 0x030, 8]); break;\n      case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\n      case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\n      case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\n      default:\n        throw 'invalid literal: ' + i;\n    }\n  }\n\n  return table;\n})();\n\n/**\n * DEFLATE \n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.compress = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var blockArray;\n  /** @type {number} */\n  var position;\n  /** @type {number} */\n  var length;\n\n  var input = this.input;\n\n  // compression\n  switch (this.compressionType) {\n    case Zlib.RawDeflate.CompressionType.NONE:\n      // each 65535-Byte (length header: 16-bit)\n      for (position = 0, length = input.length; position < length;) {\n        blockArray = \n          input.subarray(position, position + 0xffff) ;\n        position += blockArray.length;\n        this.makeNocompressBlock(blockArray, (position === length));\n      }\n      break;\n    case Zlib.RawDeflate.CompressionType.FIXED:\n      this.output = this.makeFixedHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    case Zlib.RawDeflate.CompressionType.DYNAMIC:\n      this.output = this.makeDynamicHuffmanBlock(input, true);\n      this.op = this.output.length;\n      break;\n    default:\n      throw 'invalid compression type';\n  }\n\n  return this.output;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeNocompressBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {number} */\n  var len;\n  /** @type {number} */\n  var nlen;\n\n  var output = this.output;\n  var op = this.op;\n\n  // expand buffer\n  {\n    output = new Uint8Array(this.output.buffer);\n    while (output.length <= op + blockArray.length + 5) {\n      output = new Uint8Array(output.length << 1);\n    }\n    output.set(this.output);\n  }\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.NONE;\n  output[op++] = (bfinal) | (btype << 1);\n\n  // length\n  len = blockArray.length;\n  nlen = (~len + 0x10000) & 0xffff;\n  output[op++] =          len & 0xff;\n  output[op++] =  (len >>> 8) & 0xff;\n  output[op++] =         nlen & 0xff;\n  output[op++] = (nlen >>> 8) & 0xff;\n\n  // copy buffer\n  {\n     output.set(blockArray, op);\n     op += blockArray.length;\n     output = output.subarray(0, op);\n  }\n\n  this.op = op;\n  this.output = output;\n\n  return output;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeFixedHuffmanBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(\n    new Uint8Array(this.output.buffer) , this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.FIXED;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n  this.fixedHuffman(data, stream);\n\n  return stream.finish();\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array)} blockArray  byte array.\n * @param {!boolean} isFinalBlock true.\n * @return {!(Array.<number>|Uint8Array)}  byte array.\n */\nZlib.RawDeflate.prototype.makeDynamicHuffmanBlock =\nfunction(blockArray, isFinalBlock) {\n  /** @type {Zlib.BitStream} */\n  var stream = new Zlib.BitStream(\n    new Uint8Array(this.output.buffer) , this.op);\n  /** @type {number} */\n  var bfinal;\n  /** @type {Zlib.RawDeflate.CompressionType} */\n  var btype;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var data;\n  /** @type {number} */\n  var hlit;\n  /** @type {number} */\n  var hdist;\n  /** @type {number} */\n  var hclen;\n  /** @const @type {Array.<number>} */\n  var hclenOrder =\n        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var litLenLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var litLenCodes;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var distLengths;\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var distCodes;\n  /** @type {{\n   *   codes: !(Array.<number>|Uint32Array),\n   *   freqs: !(Array.<number>|Uint8Array)\n   * }} */\n  var treeSymbols;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var treeLengths;\n  /** @type {Array} */\n  var transLengths = new Array(19);\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var treeCodes;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var bitlen;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // header\n  bfinal = isFinalBlock ? 1 : 0;\n  btype = Zlib.RawDeflate.CompressionType.DYNAMIC;\n\n  stream.writeBits(bfinal, 1, true);\n  stream.writeBits(btype, 2, true);\n\n  data = this.lz77(blockArray);\n\n  // , \n  litLenLengths = this.getLengths_(this.freqsLitLen, 15);\n  litLenCodes = this.getCodesFromLengths_(litLenLengths);\n  distLengths = this.getLengths_(this.freqsDist, 7);\n  distCodes = this.getCodesFromLengths_(distLengths);\n\n  // HLIT, HDIST \n  for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\n  for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\n\n  // HCLEN\n  treeSymbols =\n    this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\n  treeLengths = this.getLengths_(treeSymbols.freqs, 7);\n  for (i = 0; i < 19; i++) {\n    transLengths[i] = treeLengths[hclenOrder[i]];\n  }\n  for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\n\n  treeCodes = this.getCodesFromLengths_(treeLengths);\n\n  // \n  stream.writeBits(hlit - 257, 5, true);\n  stream.writeBits(hdist - 1, 5, true);\n  stream.writeBits(hclen - 4, 4, true);\n  for (i = 0; i < hclen; i++) {\n    stream.writeBits(transLengths[i], 3, true);\n  }\n\n  // \n  for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\n    code = treeSymbols.codes[i];\n\n    stream.writeBits(treeCodes[code], treeLengths[code], true);\n\n    // extra bits\n    if (code >= 16) {\n      i++;\n      switch (code) {\n        case 16: bitlen = 2; break;\n        case 17: bitlen = 3; break;\n        case 18: bitlen = 7; break;\n        default:\n          throw 'invalid code: ' + code;\n      }\n\n      stream.writeBits(treeSymbols.codes[i], bitlen, true);\n    }\n  }\n\n  this.dynamicHuffman(\n    data,\n    [litLenCodes, litLenLengths],\n    [distCodes, distLengths],\n    stream\n  );\n\n  return stream.finish();\n};\n\n\n/**\n * ()\n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77  byte array.\n * @param {!Zlib.BitStream} stream .\n * @return {!Zlib.BitStream} .\n */\nZlib.RawDeflate.prototype.dynamicHuffman =\nfunction(dataArray, litLen, dist, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n  /** @type {number} */\n  var code;\n  /** @type {number} */\n  var litLenCodes;\n  /** @type {number} */\n  var litLenLengths;\n  /** @type {number} */\n  var distCodes;\n  /** @type {number} */\n  var distLengths;\n\n  litLenCodes = litLen[0];\n  litLenLengths = litLen[1];\n  distCodes = dist[0];\n  distLengths = dist[1];\n\n  //  BitStream \n  for (index = 0, length = dataArray.length; index < length; ++index) {\n    literal = dataArray[index];\n\n    // literal or length\n    stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\n\n    // \n    if (literal > 256) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      code = dataArray[++index];\n      stream.writeBits(distCodes[code], distLengths[code], true);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n    // \n    } else if (literal === 256) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint16Array)} dataArray LZ77  byte array.\n * @param {!Zlib.BitStream} stream .\n * @return {!Zlib.BitStream} .\n */\nZlib.RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {\n  /** @type {number} */\n  var index;\n  /** @type {number} */\n  var length;\n  /** @type {number} */\n  var literal;\n\n  //  BitStream \n  for (index = 0, length = dataArray.length; index < length; index++) {\n    literal = dataArray[index];\n\n    // \n    Zlib.BitStream.prototype.writeBits.apply(\n      stream,\n      Zlib.RawDeflate.FixedHuffmanTable[literal]\n    );\n\n    // \n    if (literal > 0x100) {\n      // length extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // distance\n      stream.writeBits(dataArray[++index], 5);\n      // distance extra\n      stream.writeBits(dataArray[++index], dataArray[++index], true);\n    // \n    } else if (literal === 0x100) {\n      break;\n    }\n  }\n\n  return stream;\n};\n\n/**\n * \n * @param {!number} length .\n * @param {!number} backwardDistance .\n * @constructor\n */\nZlib.RawDeflate.Lz77Match = function(length, backwardDistance) {\n  /** @type {number} match length. */\n  this.length = length;\n  /** @type {number} backward distance. */\n  this.backwardDistance = backwardDistance;\n};\n\n/**\n * .\n * [, , ] .\n * @const\n * @type {!(Array.<number>|Uint32Array)}\n */\nZlib.RawDeflate.Lz77Match.LengthCodeTable = (function(table) {\n  return  new Uint32Array(table) ;\n})((function() {\n  /** @type {!Array} */\n  var table = [];\n  /** @type {number} */\n  var i;\n  /** @type {!Array.<number>} */\n  var c;\n\n  for (i = 3; i <= 258; i++) {\n    c = code(i);\n    table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\n  }\n\n  /**\n   * @param {number} length lz77 length.\n   * @return {!Array.<number>} lz77 codes.\n   */\n  function code(length) {\n    switch (true) {\n      case (length === 3): return [257, length - 3, 0];      case (length === 4): return [258, length - 4, 0];      case (length === 5): return [259, length - 5, 0];      case (length === 6): return [260, length - 6, 0];      case (length === 7): return [261, length - 7, 0];      case (length === 8): return [262, length - 8, 0];      case (length === 9): return [263, length - 9, 0];      case (length === 10): return [264, length - 10, 0];      case (length <= 12): return [265, length - 11, 1];      case (length <= 14): return [266, length - 13, 1];      case (length <= 16): return [267, length - 15, 1];      case (length <= 18): return [268, length - 17, 1];      case (length <= 22): return [269, length - 19, 2];      case (length <= 26): return [270, length - 23, 2];      case (length <= 30): return [271, length - 27, 2];      case (length <= 34): return [272, length - 31, 2];      case (length <= 42): return [273, length - 35, 3];      case (length <= 50): return [274, length - 43, 3];      case (length <= 58): return [275, length - 51, 3];      case (length <= 66): return [276, length - 59, 3];      case (length <= 82): return [277, length - 67, 4];      case (length <= 98): return [278, length - 83, 4];      case (length <= 114): return [279, length - 99, 4];      case (length <= 130): return [280, length - 115, 4];      case (length <= 162): return [281, length - 131, 5];      case (length <= 194): return [282, length - 163, 5];      case (length <= 226): return [283, length - 195, 5];      case (length <= 257): return [284, length - 227, 5];      case (length === 258): return [285, length - 258, 0];      default: throw 'invalid length: ' + length;\n    }\n  }\n\n  return table;\n})());\n\n/**\n * \n * @param {!number} dist .\n * @return {!Array.<number>} .\n * @private\n */\nZlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {\n  /** @type {!Array.<number>} distance code table. */\n  var r;\n\n  switch (true) {\n    case (dist === 1): r = [0, dist - 1, 0]; break;\n    case (dist === 2): r = [1, dist - 2, 0]; break;\n    case (dist === 3): r = [2, dist - 3, 0]; break;\n    case (dist === 4): r = [3, dist - 4, 0]; break;\n    case (dist <= 6): r = [4, dist - 5, 1]; break;\n    case (dist <= 8): r = [5, dist - 7, 1]; break;\n    case (dist <= 12): r = [6, dist - 9, 2]; break;\n    case (dist <= 16): r = [7, dist - 13, 2]; break;\n    case (dist <= 24): r = [8, dist - 17, 3]; break;\n    case (dist <= 32): r = [9, dist - 25, 3]; break;\n    case (dist <= 48): r = [10, dist - 33, 4]; break;\n    case (dist <= 64): r = [11, dist - 49, 4]; break;\n    case (dist <= 96): r = [12, dist - 65, 5]; break;\n    case (dist <= 128): r = [13, dist - 97, 5]; break;\n    case (dist <= 192): r = [14, dist - 129, 6]; break;\n    case (dist <= 256): r = [15, dist - 193, 6]; break;\n    case (dist <= 384): r = [16, dist - 257, 7]; break;\n    case (dist <= 512): r = [17, dist - 385, 7]; break;\n    case (dist <= 768): r = [18, dist - 513, 8]; break;\n    case (dist <= 1024): r = [19, dist - 769, 8]; break;\n    case (dist <= 1536): r = [20, dist - 1025, 9]; break;\n    case (dist <= 2048): r = [21, dist - 1537, 9]; break;\n    case (dist <= 3072): r = [22, dist - 2049, 10]; break;\n    case (dist <= 4096): r = [23, dist - 3073, 10]; break;\n    case (dist <= 6144): r = [24, dist - 4097, 11]; break;\n    case (dist <= 8192): r = [25, dist - 6145, 11]; break;\n    case (dist <= 12288): r = [26, dist - 8193, 12]; break;\n    case (dist <= 16384): r = [27, dist - 12289, 12]; break;\n    case (dist <= 24576): r = [28, dist - 16385, 13]; break;\n    case (dist <= 32768): r = [29, dist - 24577, 13]; break;\n    default: throw 'invalid distance';\n  }\n\n  return r;\n};\n\n/**\n *  LZ77 .\n * \n * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\n * @return {!Array.<number>} LZ77  byte array.\n */\nZlib.RawDeflate.Lz77Match.prototype.toLz77Array = function() {\n  /** @type {number} */\n  var length = this.length;\n  /** @type {number} */\n  var dist = this.backwardDistance;\n  /** @type {Array} */\n  var codeArray = [];\n  /** @type {number} */\n  var pos = 0;\n  /** @type {!Array.<number>} */\n  var code;\n\n  // length\n  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];\n  codeArray[pos++] = code & 0xffff;\n  codeArray[pos++] = (code >> 16) & 0xff;\n  codeArray[pos++] = code >> 24;\n\n  // distance\n  code = this.getDistanceCode_(dist);\n  codeArray[pos++] = code[0];\n  codeArray[pos++] = code[1];\n  codeArray[pos++] = code[2];\n\n  return codeArray;\n};\n\n/**\n * LZ77 \n * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 .\n * @return {!(Array.<number>|Uint16Array)} LZ77 .\n */\nZlib.RawDeflate.prototype.lz77 = function(dataArray) {\n  /** @type {number} input position */\n  var position;\n  /** @type {number} input length */\n  var length;\n  /** @type {number} loop counter */\n  var i;\n  /** @type {number} loop limiter */\n  var il;\n  /** @type {number} chained-hash-table key */\n  var matchKey;\n  /** @type {Object.<number, Array.<number>>} chained-hash-table */\n  var table = {};\n  /** @const @type {number} */\n  var windowSize = Zlib.RawDeflate.WindowSize;\n  /** @type {Array.<number>} match list */\n  var matchList;\n  /** @type {Zlib.RawDeflate.Lz77Match} longest match */\n  var longestMatch;\n  /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */\n  var prevMatch;\n  /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\n  var lz77buf = \n    new Uint16Array(dataArray.length * 2) ;\n  /** @type {number} lz77 output buffer pointer */\n  var pos = 0;\n  /** @type {number} lz77 skip length */\n  var skipLength = 0;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsLitLen = new ( Uint32Array )(286);\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var freqsDist = new ( Uint32Array )(30);\n  /** @type {number} */\n  var lazy = this.lazy;\n  /** @type {*} temporary variable */\n  var tmp;\n  freqsLitLen[256] = 1; // EOB  1\n\n  /**\n   * \n   * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.\n   * @param {!number} offset ().\n   * @private\n   */\n  function writeMatch(match, offset) {\n    /** @type {Array.<number>} */\n    var lz77Array = match.toLz77Array();\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    for (i = 0, il = lz77Array.length; i < il; ++i) {\n      lz77buf[pos++] = lz77Array[i];\n    }\n    freqsLitLen[lz77Array[0]]++;\n    freqsDist[lz77Array[3]]++;\n    skipLength = match.length + offset - 1;\n    prevMatch = null;\n  }\n\n  // LZ77 \n  for (position = 0, length = dataArray.length; position < length; ++position) {\n    // \n    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {\n      if (position + i === length) {\n        break;\n      }\n      matchKey = (matchKey << 8) | dataArray[position + i];\n    }\n\n    // \n    if (table[matchKey] === void 0) { table[matchKey] = []; }\n    matchList = table[matchKey];\n\n    // skip\n    if (skipLength-- > 0) {\n      matchList.push(position);\n      continue;\n    }\n\n    //  ()\n    while (matchList.length > 0 && position - matchList[0] > windowSize) {\n      matchList.shift();\n    }\n\n    // \n    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {\n      if (prevMatch) {\n        writeMatch(prevMatch, -1);\n      }\n\n      for (i = 0, il = length - position; i < il; ++i) {\n        tmp = dataArray[position + i];\n        lz77buf[pos++] = tmp;\n        ++freqsLitLen[tmp];\n      }\n      break;\n    }\n\n    // \n    if (matchList.length > 0) {\n      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\n\n      if (prevMatch) {\n        // \n        if (prevMatch.length < longestMatch.length) {\n          // write previous literal\n          tmp = dataArray[position - 1];\n          lz77buf[pos++] = tmp;\n          ++freqsLitLen[tmp];\n\n          // write current match\n          writeMatch(longestMatch, 0);\n        } else {\n          // write previous match\n          writeMatch(prevMatch, -1);\n        }\n      } else if (longestMatch.length < lazy) {\n        prevMatch = longestMatch;\n      } else {\n        writeMatch(longestMatch, 0);\n      }\n    // \n    } else if (prevMatch) {\n      writeMatch(prevMatch, -1);\n    } else {\n      tmp = dataArray[position];\n      lz77buf[pos++] = tmp;\n      ++freqsLitLen[tmp];\n    }\n\n    matchList.push(position); // \n  }\n\n  // \n  lz77buf[pos++] = 256;\n  freqsLitLen[256]++;\n  this.freqsLitLen = freqsLitLen;\n  this.freqsDist = freqsDist;\n\n  return /** @type {!(Uint16Array|Array.<number>)} */ (\n      lz77buf.subarray(0, pos) \n  );\n};\n\n/**\n * \n * @param {!Object} data plain data byte array.\n * @param {!number} position plain data byte array position.\n * @param {!Array.<number>} matchList .\n * @return {!Zlib.RawDeflate.Lz77Match} .\n * @private\n */\nZlib.RawDeflate.prototype.searchLongestMatch_ =\nfunction(data, position, matchList) {\n  var match,\n      currentMatch,\n      matchMax = 0, matchLength,\n      i, j, l, dl = data.length;\n\n  //  1 \n  permatch:\n  for (i = 0, l = matchList.length; i < l; i++) {\n    match = matchList[l - i - 1];\n    matchLength = Zlib.RawDeflate.Lz77MinLength;\n\n    // \n    if (matchMax > Zlib.RawDeflate.Lz77MinLength) {\n      for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {\n        if (data[match + j - 1] !== data[position + j - 1]) {\n          continue permatch;\n        }\n      }\n      matchLength = matchMax;\n    }\n\n    // \n    while (matchLength < Zlib.RawDeflate.Lz77MaxLength &&\n           position + matchLength < dl &&\n           data[match + matchLength] === data[position + matchLength]) {\n      ++matchLength;\n    }\n\n    // \n    if (matchLength > matchMax) {\n      currentMatch = match;\n      matchMax = matchLength;\n    }\n\n    // \n    if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {\n      break;\n    }\n  }\n\n  return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);\n};\n\n/**\n * Tree-Transmit Symbols \n * reference: PuTTY Deflate implementation\n * @param {number} hlit HLIT.\n * @param {!(Array.<number>|Uint8Array)} litlenLengths .\n * @param {number} hdist HDIST.\n * @param {!(Array.<number>|Uint8Array)} distLengths .\n * @return {{\n *   codes: !(Array.<number>|Uint32Array),\n *   freqs: !(Array.<number>|Uint8Array)\n * }} Tree-Transmit Symbols.\n */\nZlib.RawDeflate.prototype.getTreeSymbols_ =\nfunction(hlit, litlenLengths, hdist, distLengths) {\n  var src = new ( Uint32Array )(hlit + hdist),\n      i, j, runLength, l,\n      result = new ( Uint32Array )(286 + 30),\n      nResult,\n      rpt,\n      freqs = new ( Uint8Array )(19);\n\n  j = 0;\n  for (i = 0; i < hlit; i++) {\n    src[j++] = litlenLengths[i];\n  }\n  for (i = 0; i < hdist; i++) {\n    src[j++] = distLengths[i];\n  }\n\n  // \n  nResult = 0;\n  for (i = 0, l = src.length; i < l; i += j) {\n    // Run Length Encoding\n    for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\n\n    runLength = j;\n\n    if (src[i] === 0) {\n      // 0  3 \n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = 0;\n          freqs[0]++;\n        }\n      } else {\n        while (runLength > 0) {\n          //  138 \n          rpt = (runLength < 138 ? runLength : 138);\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          // 3-10  -> 17\n          if (rpt <= 10) {\n            result[nResult++] = 17;\n            result[nResult++] = rpt - 3;\n            freqs[17]++;\n          // 11-138  -> 18\n          } else {\n            result[nResult++] = 18;\n            result[nResult++] = rpt - 11;\n            freqs[18]++;\n          }\n\n          runLength -= rpt;\n        }\n      }\n    } else {\n      result[nResult++] = src[i];\n      freqs[src[i]]++;\n      runLength--;\n\n      // 3\n      if (runLength < 3) {\n        while (runLength-- > 0) {\n          result[nResult++] = src[i];\n          freqs[src[i]]++;\n        }\n      // 3 \n      } else {\n        while (runLength > 0) {\n          // runLength 3-6 \n          rpt = (runLength < 6 ? runLength : 6);\n\n          if (rpt > runLength - 3 && rpt < runLength) {\n            rpt = runLength - 3;\n          }\n\n          result[nResult++] = 16;\n          result[nResult++] = rpt - 3;\n          freqs[16]++;\n\n          runLength -= rpt;\n        }\n      }\n    }\n  }\n\n  return {\n    codes:\n       result.subarray(0, nResult) ,\n    freqs: freqs\n  };\n};\n\n/**\n * \n * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs .\n * @param {number} limit .\n * @return {!(Array.<number>|Uint8Array)} .\n * @private\n */\nZlib.RawDeflate.prototype.getLengths_ = function(freqs, limit) {\n  /** @type {number} */\n  var nSymbols = freqs.length;\n  /** @type {Zlib.Heap} */\n  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var length = new ( Uint8Array )(nSymbols);\n  /** @type {Array} */\n  var nodes;\n  /** @type {!(Array.<number>|Uint32Array)} */\n  var values;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  // \n  for (i = 0; i < nSymbols; ++i) {\n    if (freqs[i] > 0) {\n      heap.push(i, freqs[i]);\n    }\n  }\n  nodes = new Array(heap.length / 2);\n  values = new ( Uint32Array )(heap.length / 2);\n\n  //  0  1 \n  if (nodes.length === 1) {\n    length[heap.pop().index] = 1;\n    return length;\n  }\n\n  // Reverse Package Merge Algorithm  Canonical Huffman Code \n  for (i = 0, il = heap.length / 2; i < il; ++i) {\n    nodes[i] = heap.pop();\n    values[i] = nodes[i].value;\n  }\n  codeLength = this.reversePackageMerge_(values, values.length, limit);\n\n  for (i = 0, il = nodes.length; i < il; ++i) {\n    length[nodes[i].index] = codeLength[i];\n  }\n\n  return length;\n};\n\n/**\n * Reverse Package Merge Algorithm.\n * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\n * @param {number} symbols number of symbols.\n * @param {number} limit code length limit.\n * @return {!(Array.<number>|Uint8Array)} code lengths.\n */\nZlib.RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {\n  /** @type {!(Array.<number>|Uint16Array)} */\n  var minimumCost = new ( Uint16Array )(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var flag = new ( Uint8Array )(limit);\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var codeLength = new ( Uint8Array )(symbols);\n  /** @type {Array} */\n  var value = new Array(limit);\n  /** @type {Array} */\n  var type  = new Array(limit);\n  /** @type {Array.<number>} */\n  var currentPosition = new Array(limit);\n  /** @type {number} */\n  var excess = (1 << limit) - symbols;\n  /** @type {number} */\n  var half = (1 << (limit - 1));\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var j;\n  /** @type {number} */\n  var t;\n  /** @type {number} */\n  var weight;\n  /** @type {number} */\n  var next;\n\n  /**\n   * @param {number} j\n   */\n  function takePackage(j) {\n    /** @type {number} */\n    var x = type[j][currentPosition[j]];\n\n    if (x === symbols) {\n      takePackage(j+1);\n      takePackage(j+1);\n    } else {\n      --codeLength[x];\n    }\n\n    ++currentPosition[j];\n  }\n\n  minimumCost[limit-1] = symbols;\n\n  for (j = 0; j < limit; ++j) {\n    if (excess < half) {\n      flag[j] = 0;\n    } else {\n      flag[j] = 1;\n      excess -= half;\n    }\n    excess <<= 1;\n    minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\n  }\n  minimumCost[0] = flag[0];\n\n  value[0] = new Array(minimumCost[0]);\n  type[0]  = new Array(minimumCost[0]);\n  for (j = 1; j < limit; ++j) {\n    if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\n      minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\n    }\n    value[j] = new Array(minimumCost[j]);\n    type[j]  = new Array(minimumCost[j]);\n  }\n\n  for (i = 0; i < symbols; ++i) {\n    codeLength[i] = limit;\n  }\n\n  for (t = 0; t < minimumCost[limit-1]; ++t) {\n    value[limit-1][t] = freqs[t];\n    type[limit-1][t]  = t;\n  }\n\n  for (i = 0; i < limit; ++i) {\n    currentPosition[i] = 0;\n  }\n  if (flag[limit-1] === 1) {\n    --codeLength[0];\n    ++currentPosition[limit-1];\n  }\n\n  for (j = limit-2; j >= 0; --j) {\n    i = 0;\n    weight = 0;\n    next = currentPosition[j+1];\n\n    for (t = 0; t < minimumCost[j]; t++) {\n      weight = value[j+1][next] + value[j+1][next+1];\n\n      if (weight > freqs[i]) {\n        value[j][t] = weight;\n        type[j][t] = symbols;\n        next += 2;\n      } else {\n        value[j][t] = freqs[i];\n        type[j][t] = i;\n        ++i;\n      }\n    }\n\n    currentPosition[j] = 0;\n    if (flag[j] === 1) {\n      takePackage(j);\n    }\n  }\n\n  return codeLength;\n};\n\n/**\n * \n * reference: PuTTY Deflate implementation\n * @param {!(Array.<number>|Uint8Array)} lengths .\n * @return {!(Array.<number>|Uint16Array)} .\n * @private\n */\nZlib.RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {\n  var codes = new ( Uint16Array )(lengths.length),\n      count = [],\n      startCode = [],\n      code = 0, i, il, j, m;\n\n  // Count the codes of each length.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    count[lengths[i]] = (count[lengths[i]] | 0) + 1;\n  }\n\n  // Determine the starting code for each length block.\n  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {\n    startCode[i] = code;\n    code += count[i] | 0;\n    code <<= 1;\n  }\n\n  // Determine the code for each symbol. Mirrored, of course.\n  for (i = 0, il = lengths.length; i < il; i++) {\n    code = startCode[lengths[i]];\n    startCode[lengths[i]] += 1;\n    codes[i] = 0;\n\n    for (j = 0, m = lengths[i]; j < m; j++) {\n      codes[i] = (codes[i] << 1) | (code & 1);\n      code >>>= 1;\n    }\n  }\n\n  return codes;\n};\n\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {Object=} opt_params options.\n * @constructor\n */\nZlib.Unzip = function(input, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input =\n    ( (input instanceof Array)) ?\n    new Uint8Array(input) : input;\n  /** @type {number} */\n  this.ip = 0;\n  /** @type {number} */\n  this.eocdrOffset;\n  /** @type {number} */\n  this.numberOfThisDisk;\n  /** @type {number} */\n  this.startDisk;\n  /** @type {number} */\n  this.totalEntriesThisDisk;\n  /** @type {number} */\n  this.totalEntries;\n  /** @type {number} */\n  this.centralDirectorySize;\n  /** @type {number} */\n  this.centralDirectoryOffset;\n  /** @type {number} */\n  this.commentLength;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.comment;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  this.fileHeaderList;\n  /** @type {Object.<string, number>} */\n  this.filenameToIndex;\n  /** @type {boolean} */\n  this.verify = opt_params['verify'] || false;\n  /** @type {(Array.<number>|Uint8Array)} */\n  this.password = opt_params['password'];\n};\n\nZlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;\n\n/**\n * @type {Array.<number>}\n * @const\n */\nZlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.FileHeader = function(input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.version;\n  /** @type {number} */\n  this.os;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {number} */\n  this.fileCommentLength;\n  /** @type {number} */\n  this.diskNumberStart;\n  /** @type {number} */\n  this.internalFileAttributes;\n  /** @type {number} */\n  this.externalFileAttributes;\n  /** @type {number} */\n  this.relativeOffset;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.comment;\n};\n\nZlib.Unzip.FileHeader.prototype.parse = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // central file header signature\n  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] ||\n      input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {\n    throw new Error('invalid file header signature');\n  }\n\n  // version made by\n  this.version = input[ip++];\n  this.os = input[ip++];\n\n  // version needed to extract\n  this.needVersion = input[ip++] | (input[ip++] << 8);\n\n  // general purpose bit flag\n  this.flags = input[ip++] | (input[ip++] << 8);\n\n  // compression method\n  this.compression = input[ip++] | (input[ip++] << 8);\n\n  // last mod file time\n  this.time = input[ip++] | (input[ip++] << 8);\n\n  //last mod file date\n  this.date = input[ip++] | (input[ip++] << 8);\n\n  // crc-32\n  this.crc32 = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // compressed size\n  this.compressedSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n  // file comment length\n  this.fileCommentLength = input[ip++] | (input[ip++] << 8);\n\n  // disk number start\n  this.diskNumberStart = input[ip++] | (input[ip++] << 8);\n\n  // internal file attributes\n  this.internalFileAttributes = input[ip++] | (input[ip++] << 8);\n\n  // external file attributes\n  this.externalFileAttributes =\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24);\n\n  // relative offset of local header\n  this.relativeOffset = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, \n    input.subarray(ip, ip += this.fileNameLength) \n  );\n\n  // extra field\n  this.extraField = \n    input.subarray(ip, ip += this.extraFieldLength) ;\n\n  // file comment\n  this.comment = \n    input.subarray(ip, ip + this.fileCommentLength) ;\n\n  this.length = ip - this.offset;\n};\n\n/**\n * @param {!(Array.<number>|Uint8Array)} input input buffer.\n * @param {number} ip input position.\n * @constructor\n */\nZlib.Unzip.LocalFileHeader = function(input, ip) {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.input = input;\n  /** @type {number} */\n  this.offset = ip;\n  /** @type {number} */\n  this.length;\n  /** @type {number} */\n  this.needVersion;\n  /** @type {number} */\n  this.flags;\n  /** @type {number} */\n  this.compression;\n  /** @type {number} */\n  this.time;\n  /** @type {number} */\n  this.date;\n  /** @type {number} */\n  this.crc32;\n  /** @type {number} */\n  this.compressedSize;\n  /** @type {number} */\n  this.plainSize;\n  /** @type {number} */\n  this.fileNameLength;\n  /** @type {number} */\n  this.extraFieldLength;\n  /** @type {string} */\n  this.filename;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  this.extraField;\n};\n\nZlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;\n\nZlib.Unzip.LocalFileHeader.prototype.parse = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip = this.offset;\n\n  // local file header signature\n  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] ||\n      input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {\n    throw new Error('invalid local file header signature');\n  }\n\n  // version needed to extract\n  this.needVersion = input[ip++] | (input[ip++] << 8);\n\n  // general purpose bit flag\n  this.flags = input[ip++] | (input[ip++] << 8);\n\n  // compression method\n  this.compression = input[ip++] | (input[ip++] << 8);\n\n  // last mod file time\n  this.time = input[ip++] | (input[ip++] << 8);\n\n  //last mod file date\n  this.date = input[ip++] | (input[ip++] << 8);\n\n  // crc-32\n  this.crc32 = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // compressed size\n  this.compressedSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // uncompressed size\n  this.plainSize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // file name length\n  this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n  // extra field length\n  this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n  // file name\n  this.filename = String.fromCharCode.apply(null, \n    input.subarray(ip, ip += this.fileNameLength) \n  );\n\n  // extra field\n  this.extraField = \n    input.subarray(ip, ip += this.extraFieldLength) ;\n\n  this.length = ip - this.offset;\n};\n\n\nZlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  for (ip = input.length - 12; ip > 0; --ip) {\n    if (input[ip  ] === Zlib.Unzip.CentralDirectorySignature[0] &&\n        input[ip+1] === Zlib.Unzip.CentralDirectorySignature[1] &&\n        input[ip+2] === Zlib.Unzip.CentralDirectorySignature[2] &&\n        input[ip+3] === Zlib.Unzip.CentralDirectorySignature[3]) {\n      this.eocdrOffset = ip;\n      return;\n    }\n  }\n\n  throw new Error('End of Central Directory Record not found');\n};\n\nZlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {number} */\n  var ip;\n\n  if (!this.eocdrOffset) {\n    this.searchEndOfCentralDirectoryRecord();\n  }\n  ip = this.eocdrOffset;\n\n  // signature\n  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] ||\n      input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {\n    throw new Error('invalid signature');\n  }\n\n  // number of this disk\n  this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);\n\n  // number of the disk with the start of the central directory\n  this.startDisk = input[ip++] | (input[ip++] << 8);\n\n  // total number of entries in the central directory on this disk\n  this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);\n\n  // total number of entries in the central directory\n  this.totalEntries = input[ip++] | (input[ip++] << 8);\n\n  // size of the central directory\n  this.centralDirectorySize = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // offset of start of central directory with respect to the starting disk number\n  this.centralDirectoryOffset = (\n    (input[ip++]      ) | (input[ip++] <<  8) |\n    (input[ip++] << 16) | (input[ip++] << 24)\n  ) >>> 0;\n\n  // .ZIP file comment length\n  this.commentLength = input[ip++] | (input[ip++] << 8);\n\n  // .ZIP file comment\n  this.comment = \n    input.subarray(ip, ip + this.commentLength) ;\n};\n\nZlib.Unzip.prototype.parseFileHeader = function() {\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var filelist = [];\n  /** @type {Object.<string, number>} */\n  var filetable = {};\n  /** @type {number} */\n  var ip;\n  /** @type {Zlib.Unzip.FileHeader} */\n  var fileHeader;\n  /*: @type {number} */\n  var i;\n  /*: @type {number} */\n  var il;\n\n  if (this.fileHeaderList) {\n    return;\n  }\n\n  if (this.centralDirectoryOffset === void 0) {\n    this.parseEndOfCentralDirectoryRecord();\n  }\n  ip = this.centralDirectoryOffset;\n\n  for (i = 0, il = this.totalEntries; i < il; ++i) {\n    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);\n    fileHeader.parse();\n    ip += fileHeader.length;\n    filelist[i] = fileHeader;\n    filetable[fileHeader.filename] = i;\n  }\n\n  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {\n    throw new Error('invalid file header size');\n  }\n\n  this.fileHeaderList = filelist;\n  this.filenameToIndex = filetable;\n};\n\n/**\n * @param {number} index file header index.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} file data.\n */\nZlib.Unzip.prototype.getFileData = function(index, opt_params) {\n  opt_params = opt_params || {};\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var input = this.input;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList = this.fileHeaderList;\n  /** @type {Zlib.Unzip.LocalFileHeader} */\n  var localFileHeader;\n  /** @type {number} */\n  var offset;\n  /** @type {number} */\n  var length;\n  /** @type {!(Array.<number>|Uint8Array)} */\n  var buffer;\n  /** @type {number} */\n  var crc32;\n  /** @type {Array.<number>|Uint32Array|Object} */\n  var key;\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  if (!fileHeaderList) {\n    this.parseFileHeader();\n  }\n\n  if (fileHeaderList[index] === void 0) {\n    throw new Error('wrong index');\n  }\n\n  offset = fileHeaderList[index].relativeOffset;\n  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);\n  localFileHeader.parse();\n  offset += localFileHeader.length;\n  length = localFileHeader.compressedSize;\n\n  // decryption\n  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {\n    if (!(opt_params['password'] || this.password)) {\n      throw new Error('please set password');\n    }\n    key =  this.createDecryptionKey(opt_params['password'] || this.password);\n\n    // encryption header\n    for(i = offset, il = offset + 12; i < il; ++i) {\n      this.decode(key, input[i]);\n    }\n    offset += 12;\n    length -= 12;\n\n    // decryption\n    for (i = offset, il = offset + length; i < il; ++i) {\n      input[i] = this.decode(key, input[i]);\n    }\n  }\n\n  switch (localFileHeader.compression) {\n    case Zlib.Unzip.CompressionMethod.STORE:\n      buffer = \n        this.input.subarray(offset, offset + length) ;\n      break;\n    case Zlib.Unzip.CompressionMethod.DEFLATE:\n      buffer = new Zlib.RawInflate(this.input, {\n        'index': offset,\n        'bufferSize': localFileHeader.plainSize\n      }).decompress();\n      break;\n    default:\n      throw new Error('unknown compression type');\n  }\n\n  if (this.verify) {\n    crc32 = Zlib.CRC32.calc(buffer);\n    if (localFileHeader.crc32 !== crc32) {\n      throw new Error(\n        'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +\n        ', data=0x' + crc32.toString(16)\n      );\n    }\n  }\n\n  return buffer;\n};\n\n/**\n * @return {Array.<string>}\n */\nZlib.Unzip.prototype.getFilenames = function() {\n  /** @type {Array.<string>} */\n  var filenameList = [];\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n  /** @type {Array.<Zlib.Unzip.FileHeader>} */\n  var fileHeaderList;\n\n  if (!this.fileHeaderList) {\n    this.parseFileHeader();\n  }\n  fileHeaderList = this.fileHeaderList;\n\n  for (i = 0, il = fileHeaderList.length; i < il; ++i) {\n    filenameList[i] = fileHeaderList[i].filename;\n  }\n\n  return filenameList;\n};\n\n/**\n * @param {string} filename extract filename.\n * @param {Object=} opt_params\n * @return {!(Array.<number>|Uint8Array)} decompressed data.\n */\nZlib.Unzip.prototype.decompress = function(filename, opt_params) {\n  /** @type {number} */\n  var index;\n\n  if (!this.filenameToIndex) {\n    this.parseFileHeader();\n  }\n  index = this.filenameToIndex[filename];\n\n  if (index === void 0) {\n    throw new Error(filename + ' not found');\n  }\n\n  return this.getFileData(index, opt_params);\n};\n\n/**\n * @param {(Array.<number>|Uint8Array)} password\n */\nZlib.Unzip.prototype.setPassword = function(password) {\n  this.password = password;\n};\n\n/**\n * @param {(Array.<number>|Uint32Array|Object)} key\n * @param {number} n\n * @return {number}\n */\nZlib.Unzip.prototype.decode = function(key, n) {\n  n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n  this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n  return n;\n};\n\n// common method\nZlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;\nZlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;\nZlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;\n\n/**\n * @fileoverview .\n */\n\n\n/**\n * Byte String  Byte Array .\n * @param {!string} str byte string.\n * @return {!Array.<number>} byte array.\n */\nZlib.Util.stringToByteArray = function(str) {\n  /** @type {!Array.<(string|number)>} */\n  var tmp = str.split('');\n  /** @type {number} */\n  var i;\n  /** @type {number} */\n  var il;\n\n  for (i = 0, il = tmp.length; i < il; i++) {\n    tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;\n  }\n\n  return tmp;\n};\n\n\n/**\n * @fileoverview Adler32 checksum .\n */\n\n\n/**\n * Adler32 \n * @param {!(Array|Uint8Array|string)} array  byte array.\n * @return {number} Adler32 .\n */\nZlib.Adler32 = function(array) {\n  if (typeof(array) === 'string') {\n    array = Zlib.Util.stringToByteArray(array);\n  }\n  return Zlib.Adler32.update(1, array);\n};\n\n/**\n * Adler32 \n * @param {number} adler .\n * @param {!(Array|Uint8Array)} array  byte array.\n * @return {number} Adler32 .\n */\nZlib.Adler32.update = function(adler, array) {\n  /** @type {number} */\n  var s1 = adler & 0xffff;\n  /** @type {number} */\n  var s2 = (adler >>> 16) & 0xffff;\n  /** @type {number} array length */\n  var len = array.length;\n  /** @type {number} loop length (don't overflow) */\n  var tlen;\n  /** @type {number} array index */\n  var i = 0;\n\n  while (len > 0) {\n    tlen = len > Zlib.Adler32.OptimizationParameter ?\n      Zlib.Adler32.OptimizationParameter : len;\n    len -= tlen;\n    do {\n      s1 += array[i++];\n      s2 += s1;\n    } while (--tlen);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return ((s2 << 16) | s1) >>> 0;\n};\n\n/**\n * Adler32 \n *  1024 .\n * @see http://jsperf.com/adler-32-simple-vs-optimized/3\n * @define {number}\n */\nZlib.Adler32.OptimizationParameter = 1024;\n\n\n\n\n/**\n * \n * @constructor\n * @param {!(Array|Uint8Array)=} buffer output buffer.\n * @param {number=} bufferPosition start buffer pointer.\n */\nZlib.BitStream = function(buffer, bufferPosition) {\n  /** @type {number} buffer index. */\n  this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\n  /** @type {number} bit index. */\n  this.bitindex = 0;\n  /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\n  this.buffer = buffer instanceof ( Uint8Array ) ?\n    buffer :\n    new ( Uint8Array )(Zlib.BitStream.DefaultBlockSize);\n\n  //  index \n  if (this.buffer.length * 2 <= this.index) {\n    throw new Error(\"invalid index\");\n  } else if (this.buffer.length <= this.index) {\n    this.expandBuffer();\n  }\n};\n\n/**\n * .\n * @const\n * @type {number}\n */\nZlib.BitStream.DefaultBlockSize = 0x8000;\n\n/**\n * expand buffer.\n * @return {!(Array|Uint8Array)} new buffer.\n */\nZlib.BitStream.prototype.expandBuffer = function() {\n  /** @type {!(Array|Uint8Array)} old buffer. */\n  var oldbuf = this.buffer;\n  /** @type {number} loop limiter. */\n  var il = oldbuf.length;\n  /** @type {!(Array|Uint8Array)} new buffer. */\n  var buffer =\n    new ( Uint8Array )(il << 1);\n\n  // copy buffer\n  {\n    buffer.set(oldbuf);\n  }\n\n  return (this.buffer = buffer);\n};\n\n\n/**\n * .\n * @param {number} number .\n * @param {number} n .\n * @param {boolean=} reverse  true.\n */\nZlib.BitStream.prototype.writeBits = function(number, n, reverse) {\n  var buffer = this.buffer;\n  var index = this.index;\n  var bitindex = this.bitindex;\n\n  /** @type {number} current octet. */\n  var current = buffer[index];\n  /** @type {number} loop counter. */\n  var i;\n\n  /**\n   * 32-bit \n   * @param {number} n 32-bit integer.\n   * @return {number} reversed 32-bit integer.\n   * @private\n   */\n  function rev32_(n) {\n    return (Zlib.BitStream.ReverseTable[n & 0xFF] << 24) |\n      (Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |\n      (Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |\n      Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];\n  }\n\n  if (reverse && n > 1) {\n    number = n > 8 ?\n      rev32_(number) >> (32 - n) :\n      Zlib.BitStream.ReverseTable[number] >> (8 - n);\n  }\n\n  // Byte \n  if (n + bitindex < 8) {\n    current = (current << n) | number;\n    bitindex += n;\n  // Byte \n  } else {\n    for (i = 0; i < n; ++i) {\n      current = (current << 1) | ((number >> n - i - 1) & 1);\n\n      // next byte\n      if (++bitindex === 8) {\n        bitindex = 0;\n        buffer[index++] = Zlib.BitStream.ReverseTable[current];\n        current = 0;\n\n        // expand\n        if (index === buffer.length) {\n          buffer = this.expandBuffer();\n        }\n      }\n    }\n  }\n  buffer[index] = current;\n\n  this.buffer = buffer;\n  this.bitindex = bitindex;\n  this.index = index;\n};\n\n\n/**\n * \n * @return {!(Array|Uint8Array)}  byte array .\n */\nZlib.BitStream.prototype.finish = function() {\n  var buffer = this.buffer;\n  var index = this.index;\n\n  /** @type {!(Array|Uint8Array)} output buffer. */\n  var output;\n\n  // bitindex  0  index \n  if (this.bitindex > 0) {\n    buffer[index] <<= 8 - this.bitindex;\n    buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];\n    index++;\n  }\n\n  // array truncation\n  {\n    output = buffer.subarray(0, index);\n  }\n\n  return output;\n};\n\n/**\n * 0-255 \n * @const\n * @type {!(Uint8Array|Array.<number>)}\n */\nZlib.BitStream.ReverseTable = (function(table) {\n  return table;\n})((function() {\n  /** @type {!(Array|Uint8Array)} reverse table. */\n  var table = new ( Uint8Array )(256);\n  /** @type {number} loop counter. */\n  var i;\n\n  // generate\n  for (i = 0; i < 256; ++i) {\n    table[i] = (function(n) {\n      var r = n;\n      var s = 7;\n\n      for (n >>>= 1; n; n >>>= 1) {\n        r <<= 1;\n        r |= n & 1;\n        --s;\n      }\n\n      return (r << s & 0xff) >>> 0;\n    })(i);\n  }\n\n  return table;\n})());\n\n/**\n * CRC32 \n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.calc = function(data, pos, length) {\n  return Zlib.CRC32.update(data, 0, pos, length);\n};\n\n/**\n * CRC32\n * @param {!(Array.<number>|Uint8Array)} data data byte array.\n * @param {number} crc CRC32.\n * @param {number=} pos data position.\n * @param {number=} length data length.\n * @return {number} CRC32.\n */\nZlib.CRC32.update = function(data, crc, pos, length) {\n  var table = Zlib.CRC32.Table;\n  var i = (typeof pos === 'number') ? pos : (pos = 0);\n  var il = (typeof length === 'number') ? length : data.length;\n\n  crc ^= 0xffffffff;\n\n  // loop unrolling for performance\n  for (i = il & 7; i--; ++pos) {\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];\n  }\n  for (i = il >> 3; i--; pos += 8) {\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];\n    crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];\n  }\n\n  return (crc ^ 0xffffffff) >>> 0;\n};\n\n/**\n * @param {number} num\n * @param {number} crc\n * @returns {number}\n */\nZlib.CRC32.single = function(num, crc) {\n  return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;\n};\n\n/**\n * @type {Array.<number>}\n * @const\n * @private\n */\nZlib.CRC32.Table_ = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\n  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\n  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\n  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\n  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\n  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\n  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\n  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\n  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\n  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\n  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\n  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\n  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\n  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\n  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\n  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\n  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\n  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\n  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\n  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\n  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\n  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\n  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\n  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\n  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\n  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\n];\n\n/**\n * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.\n * @const\n */\nZlib.CRC32.Table =   new Uint32Array(Zlib.CRC32.Table_) ;\n\n/**\n * @fileoverview Deflate (RFC1951) .\n * Deflate Zlib.RawDeflate .\n */\n\n/**\n * Zlib Deflate\n * @constructor\n * @param {!(Array|Uint8Array)} input  byte array.\n * @param {Object=} opt_params option parameters.\n */\nZlib.Deflate = function(input, opt_params) {\n  /** @type {!(Array|Uint8Array)} */\n  this.input = input;\n  /** @type {!(Array|Uint8Array)} */\n  this.output =\n    new ( Uint8Array )(Zlib.Deflate.DefaultBufferSize);\n  /** @type {Zlib.Deflate.CompressionType} */\n  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;\n  /** @type {Zlib.RawDeflate} */\n  this.rawDeflate;\n  /** @type {Object} */\n  var rawDeflateOption = {};\n  /** @type {string} */\n  var prop;\n\n  // option parameters\n  if (opt_params || !(opt_params = {})) {\n    if (typeof opt_params['compressionType'] === 'number') {\n      this.compressionType = opt_params['compressionType'];\n    }\n  }\n\n  // copy options\n  for (prop in opt_params) {\n    rawDeflateOption[prop] = opt_params[prop];\n  }\n\n  // set raw-deflate output buffer\n  rawDeflateOption['outputBuffer'] = this.output;\n\n  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);\n};\n\n/**\n * @const\n * @type {number} .\n */\nZlib.Deflate.DefaultBufferSize = 0x8000;\n\n/**\n * @enum {number}\n */\nZlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;\n\n/**\n * .\n * @param {!(Array|Uint8Array)} input target buffer.\n * @param {Object=} opt_params option parameters.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.compress = function(input, opt_params) {\n  return (new Zlib.Deflate(input, opt_params)).compress();\n};\n\n/**\n * Deflate Compression.\n * @return {!(Array|Uint8Array)} compressed data byte array.\n */\nZlib.Deflate.prototype.compress = function() {\n  /** @type {Zlib.CompressionMethod} */\n  var cm;\n  /** @type {number} */\n  var cinfo;\n  /** @type {number} */\n  var cmf;\n  /** @type {number} */\n  var flg;\n  /** @type {number} */\n  var fcheck;\n  /** @type {number} */\n  var fdict;\n  /** @type {number} */\n  var flevel;\n  /** @type {number} */\n  var adler;\n  /** @type {!(Array|Uint8Array)} */\n  var output;\n  /** @type {number} */\n  var pos = 0;\n\n  output = this.output;\n\n  // Compression Method and Flags\n  cm = Zlib.CompressionMethod.DEFLATE;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  cmf = (cinfo << 4) | cm;\n  output[pos++] = cmf;\n\n  // Flags\n  fdict = 0;\n  switch (cm) {\n    case Zlib.CompressionMethod.DEFLATE:\n      switch (this.compressionType) {\n        case Zlib.Deflate.CompressionType.NONE: flevel = 0; break;\n        case Zlib.Deflate.CompressionType.FIXED: flevel = 1; break;\n        case Zlib.Deflate.CompressionType.DYNAMIC: flevel = 2; break;\n        default: throw new Error('unsupported compression type');\n      }\n      break;\n    default:\n      throw new Error('invalid compression method');\n  }\n  flg = (flevel << 6) | (fdict << 5);\n  fcheck = 31 - (cmf * 256 + flg) % 31;\n  flg |= fcheck;\n  output[pos++] = flg;\n\n  // Adler-32 checksum\n  adler = Zlib.Adler32(this.input);\n\n  this.rawDeflate.op = pos;\n  output = this.rawDeflate.compress();\n  pos = output.length;\n\n  {\n    // subarray \n    output = new Uint8Array(output.buffer);\n    // expand buffer\n    if (output.length <= pos + 4) {\n      this.output = new Uint8Array(output.length + 4);\n      this.output.set(output);\n      output = this.output;\n    }\n    output = output.subarray(0, pos + 4);\n  }\n\n  // adler32\n  output[pos++] = (adler >> 24) & 0xff;\n  output[pos++] = (adler >> 16) & 0xff;\n  output[pos++] = (adler >>  8) & 0xff;\n  output[pos++] = (adler      ) & 0xff;\n\n  return output;\n};\n\nconst isNode =\n    typeof process !== 'undefined' &&\n    process.versions != null &&\n    process.versions.node != null;\n\n\nconst crossFetch = isNode ? require(\"node-fetch\") : fetch;\n\nclass BrowserLocalFile {\n\n    constructor(blob) {\n        this.file = blob;\n    }\n\n    async read(position, length) {\n\n        const file = this.file;\n\n        return new Promise(function (fullfill, reject) {\n\n            const fileReader = new FileReader();\n\n            fileReader.onload = function (e) {\n                fullfill(fileReader.result);\n            };\n\n            fileReader.onerror = function (e) {\n                console.err(\"Error reading local file \" + file.name);\n                reject(null, fileReader);\n            };\n\n            if (position !== undefined) {\n                const blob = file.slice(position, position + length);\n                fileReader.readAsArrayBuffer(blob);\n\n            } else {\n                fileReader.readAsArrayBuffer(file);\n\n            }\n\n        });\n    }\n}\n\nconst isNode$1 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\nlet fs;\nlet fsOpen;\nlet fsRead;\n\nif (isNode$1) {\n    const util = require('util');\n    fs = require('fs');\n    fsOpen = fs && util.promisify(fs.open);\n    fsRead = fs && util.promisify(fs.read);\n}\n\nclass NodeLocalFile {\n\n    constructor(args) {\n        this.path = args.path;\n    }\n\n\n    async read(position, length) {\n\n        const buffer = Buffer.alloc(length);\n        const fd = await fsOpen(this.path, 'r');\n        const result = await fsRead(fd, buffer, 0, length, position);\n\n        fs.close(fd, function (error) {\n            // TODO Do something with error\n        });\n\n        //TODO -- compare result.bytesRead with length\n        const b = result.buffer;\n        const arrayBuffer = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);\n        return arrayBuffer\n    }\n}\n\nconst  isNode$2 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\nclass RemoteFile {\n\n    constructor(args) {\n        this.config = args;\n        this.url = mapUrl(args.path || args.url);\n    }\n\n\n    async read(position, length) {\n\n        length = Math.ceil(length);\n        const headers = this.config.headers || {};\n        const rangeString = \"bytes=\" + position + \"-\" + (position + length - 1);\n        headers['Range'] = rangeString;\n\n        let url = this.url.slice();    // slice => copy\n        if (isNode$2) {\n            headers['User-Agent'] = 'straw';\n        } else {\n            if (this.config.oauthToken) {\n                const token = resolveToken(this.config.oauthToken);\n                headers['Authorization'] = `Bearer ${token}`;\n            }\n            const isSafari = navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent);\n            const isChrome = navigator.userAgent.indexOf('Chrome') > -1;\n            const isAmazonV4Signed = this.url.indexOf(\"X-Amz-Signature\") > -1;\n\n            if (isChrome && !isAmazonV4Signed) {\n                url = addParameter(url, \"randomSeed\", Math.random().toString(36));\n            }\n        }\n\n        if (this.config.apiKey) {\n            url = addParameter(url, \"key\", this.config.apiKey);\n        }\n\n        const response = await crossFetch(url, {\n            method: 'GET',\n            headers: headers,\n            redirect: 'follow',\n            mode: 'cors',\n\n        });\n\n        const status = response.status;\n\n        if (status >= 400) {\n            console.error(`${status}  ${this.config.url}`);\n            const err = Error(response.statusText);\n            err.code = status;\n            throw err\n        } else {\n            return response.arrayBuffer();\n        }\n\n        /**\n         * token can be a string, a function that returns a string, or a function that returns a Promise for a string\n         * @param token\n         * @returns {Promise<*>}\n         */\n        async function resolveToken(token) {\n            if (typeof token === 'function') {\n                return await Promise.resolve(token())    // Normalize the result to a promise, since we don't know what the function returns\n            } else {\n                return token\n            }\n        }\n\n    }\n}\n\n\nfunction mapUrl(url) {\n\n    if (url.includes(\"//www.dropbox.com\")) {\n        return url.replace(\"//www.dropbox.com\", \"//dl.dropboxusercontent.com\");\n    } else if (url.startsWith(\"ftp://ftp.ncbi.nlm.nih.gov\")) {\n        return url.replace(\"ftp://\", \"https://\")\n    } else {\n        return url\n    }\n}\n\n\nfunction addParameter(url, name, value) {\n    const paramSeparator = url.includes(\"?\") ? \"&\" : \"?\";\n    return url + paramSeparator + name + \"=\" + value;\n}\n\nclass ThrottledFile {\n\n    constructor(file, rateLimiter) {\n        this.file = file;\n        this.rateLimiter = rateLimiter;\n    }\n\n\n    async read(position, length) {\n\n        const file = this.file;\n        const rateLimiter = this.rateLimiter;\n\n        return new Promise(function (fulfill, reject) {\n            rateLimiter.limiter(async function (f) {\n                try {\n                    const result = await f.read(position, length);\n                    fulfill(result);\n                } catch (e) {\n                    reject(e);\n                }\n            })(file);\n        })\n    }\n}\n\nclass RateLimiter {\n\n    constructor(wait) {\n        this.wait = wait === undefined ? 100 : wait;\n\n        this.isCalled = false;\n        this.calls = [];\n    }\n\n\n    limiter(fn) {\n\n        const self = this;\n\n        let caller = function () {\n\n            if (self.calls.length && !self.isCalled) {\n                self.isCalled = true;\n                self.calls.shift().call();\n                setTimeout(function () {\n                    self.isCalled = false;\n                    caller();\n                }, self.wait);\n            }\n        };\n\n        return function () {\n            self.calls.push(fn.bind(this, ...arguments));\n            caller();\n        };\n    }\n\n}\n\nclass BufferedFile {\n\n    constructor(args) {\n        this.file = args.file;\n        this.size = args.size || 64000;\n        this.position = 0;\n        this.bufferStart = 0;\n        this.bufferLength = 0;\n        this.buffer = undefined;\n    }\n\n\n    async read(position, length) {\n\n        const start = position;\n        const end = position + length;\n        const bufferStart = this.bufferStart;\n        const bufferEnd = this.bufferStart + this.bufferLength;\n\n\n        if (length > this.size) {\n            // Request larger than max buffer size,  pass through to underlying file\n            //console.log(\"0\")\n            this.buffer = undefined;\n            this.bufferStart = 0;\n            this.bufferLength = 0;\n            return this.file.read(position, length)\n        }\n\n        if (start >= bufferStart && end <= bufferEnd) {\n            // Request within buffer bounds\n            //console.log(\"1\")\n            const sliceStart = start - bufferStart;\n            const sliceEnd = sliceStart + length;\n            return this.buffer.slice(sliceStart, sliceEnd)\n        }\n\n        else if (start < bufferStart && end > bufferStart) {\n            // Overlap left, here for completness but this is an unexpected case in straw.  We don't adjust the buffer.\n            //console.log(\"2\")\n            const l1 = bufferStart - start;\n            const a1 = await this.file.read(position, l1);\n            const l2 = length - l1;\n            if (l2 > 0) {\n                //this.buffer = await this.file.read(bufferStart, this.size)\n                const a2 = this.buffer.slice(0, l2);\n                return concatBuffers(a1, a2)\n            } else {\n                return a1\n            }\n\n        }\n\n        else if (start < bufferEnd && end > bufferEnd) {\n            // Overlap right\n            // console.log(\"3\")\n            const l1 = bufferEnd - start;\n            const sliceStart = this.bufferLength - l1;\n            const a1 = this.buffer.slice(sliceStart, this.bufferLength);\n\n            const l2 = length - l1;\n            if (l2 > 0) {\n                try {\n                    this.buffer = await this.file.read(bufferEnd, this.size);\n                    this.bufferStart = bufferEnd;\n                    this.bufferLength = this.buffer.byteLength;\n                    const a2 = this.buffer.slice(0, l2);\n                    return concatBuffers(a1, a2)\n                } catch (e) {\n                    // A \"unsatisfiable range\" error is expected here if we overlap past the end of file\n                    if (e.code && e.code === 416) {\n                        return a1\n                    }\n                    else {\n                        throw e\n                    }\n                }\n\n            } else {\n                return a1\n            }\n\n        }\n\n        else {\n            // No overlap with buffer\n            // console.log(\"4\")\n            this.buffer = await this.file.read(position, this.size);\n            this.bufferStart = position;\n            this.bufferLength = this.buffer.byteLength;\n            return this.buffer.slice(0, length)\n        }\n\n    }\n\n}\n\n/**\n * concatenates 2 array buffers.\n * Credit: https://gist.github.com/72lions/4528834\n *\n * @private\n * @param {ArrayBuffers} buffer1 The first buffer.\n * @param {ArrayBuffers} buffer2 The second buffer.\n * @return {ArrayBuffers} The new ArrayBuffer created out of the two.\n */\nvar concatBuffers = function (buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n};\n\n// TODO -- big endian\n\nconst BinaryParser = function (dataView, littleEndian) {\n\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n    this.position = 0;\n    this.view = dataView;\n    this.length = dataView.byteLength;\n};\n\nBinaryParser.prototype.available = function () {\n    return this.length - this.position;\n};\n\nBinaryParser.prototype.remLength = function () {\n    return this.length - this.position;\n};\n\nBinaryParser.prototype.hasNext = function () {\n    return this.position < this.length - 1;\n};\n\nBinaryParser.prototype.getByte = function () {\n    var retValue = this.view.getUint8(this.position, this.littleEndian);\n    this.position++;\n    return retValue;\n};\n\nBinaryParser.prototype.getShort = function () {\n\n    var retValue = this.view.getInt16(this.position, this.littleEndian);\n    this.position += 2;\n    return retValue;\n};\n\nBinaryParser.prototype.getUShort = function () {\n\n    // var byte1 = this.getByte(),\n    //     byte2 = this.getByte(),\n    //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\n    //     return retValue;\n\n    //\n    var retValue = this.view.getUint16(this.position, this.littleEndian);\n    this.position += 2;\n    return retValue;\n};\n\n\nBinaryParser.prototype.getInt = function () {\n\n    var retValue = this.view.getInt32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n};\n\n\nBinaryParser.prototype.getUInt = function () {\n    var retValue = this.view.getUint32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n};\n\nBinaryParser.prototype.getLong = function () {\n\n    // DataView doesn't support long. So we'll try manually\n\n    var b = [];\n    b[0] = this.view.getUint8(this.position);\n    b[1] = this.view.getUint8(this.position + 1);\n    b[2] = this.view.getUint8(this.position + 2);\n    b[3] = this.view.getUint8(this.position + 3);\n    b[4] = this.view.getUint8(this.position + 4);\n    b[5] = this.view.getUint8(this.position + 5);\n    b[6] = this.view.getUint8(this.position + 6);\n    b[7] = this.view.getUint8(this.position + 7);\n\n    var value = 0;\n    if (this.littleEndian) {\n        for (var i = b.length - 1; i >= 0; i--) {\n            value = (value * 256) + b[i];\n        }\n    } else {\n        for (var i = 0; i < b.length; i++) {\n            value = (value * 256) + b[i];\n        }\n    }\n\n\n    this.position += 8;\n    return value;\n};\n\nBinaryParser.prototype.getString = function (len) {\n\n    var s = \"\";\n    var c;\n    while ((c = this.view.getUint8(this.position++)) != 0) {\n        s += String.fromCharCode(c);\n        if (len && s.length == len) break;\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFixedLengthString = function (len) {\n\n    var s = \"\";\n    var i;\n    var c;\n    for (i = 0; i < len; i++) {\n        c = this.view.getUint8(this.position++);\n        if (c > 0) {\n            s += String.fromCharCode(c);\n        }\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFixedLengthTrimmedString = function (len) {\n\n    var s = \"\";\n    var i;\n    var c;\n    for (i = 0; i < len; i++) {\n        c = this.view.getUint8(this.position++);\n        if (c > 32) {\n            s += String.fromCharCode(c);\n        }\n    }\n    return s;\n};\n\nBinaryParser.prototype.getFloat = function () {\n\n    var retValue = this.view.getFloat32(this.position, this.littleEndian);\n    this.position += 4;\n    return retValue;\n\n\n};\n\nBinaryParser.prototype.getDouble = function () {\n\n    var retValue = this.view.getFloat64(this.position, this.littleEndian);\n    this.position += 8;\n    return retValue;\n};\n\nBinaryParser.prototype.skip = function (n) {\n\n    this.position += n;\n    return this.position;\n};\n\n\n/**\n * Return a bgzip (bam and tabix) virtual pointer\n * TODO -- why isn't 8th byte used ?\n * @returns {*}\n */\nBinaryParser.prototype.getVPointer = function () {\n\n    var position = this.position,\n        offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),\n        byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),\n        byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),\n        byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),\n        byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),\n        byte2 = ((this.view.getUint8(position + 2) & 0xff)),\n        block = byte6 + byte5 + byte4 + byte3 + byte2;\n    this.position += 8;\n\n    //       if (block == 0 && offset == 0) {\n    //           return null;\n    //       } else {\n    return new VPointer(block, offset);\n    //       }\n};\n\n\nfunction VPointer(block, offset) {\n    this.block = block;\n    this.offset = offset;\n}\n\nVPointer.prototype.isLessThan = function (vp) {\n    return this.block < vp.block ||\n        (this.block === vp.block && this.offset < vp.offset);\n};\n\nVPointer.prototype.isGreaterThan = function (vp) {\n    return this.block > vp.block ||\n        (this.block === vp.block && this.offset > vp.offset);\n};\n\nVPointer.prototype.print = function () {\n    return \"\" + this.block + \":\" + this.offset;\n};\n\nclass MatrixZoomData {\n\n    constructor(chr1, chr2) {\n\n        this.chr1 = chr1;    // chromosome index\n        this.chr2 = chr2;\n    }\n\n    getKey () {\n        return this.chr1.name + \"_\" + this.chr2.name + \"_\" + this.zoom.unit + \"_\" + this.zoom.binSize;\n    }\n\n    getBlockNumbers(region1, region2, version) {\n\n        // Verify region chromosomes and swap if neccessary\n        if(region1.chr == this.chr2 && region2.chr === this.chr1) {\n            const tmp = region1;\n            region1 = region2;\n            region2 = tmp;\n        }\n\n        const sameChr = this.chr1 === this.chr2;\n        const binsize = this.zoom.binSize;\n        const blockBinCount = this.blockBinCount;\n        const blockColumnCount = this.blockColumnCount;\n        return (version < 9 || !sameChr) ? getBlockNumbersV8() : getBlockNumbersV9();\n\n        function getBlockNumbersV8()\n        {\n            const x1 = region1.start / binsize;\n            const x2 = region1.end / binsize;\n            const y1 = region2.start / binsize;\n            const y2 = region2.end / binsize;\n\n            const col1 = Math.floor(x1 / blockBinCount);\n            const col2 = Math.floor((x2 - 1) / blockBinCount);\n            const row1 = Math.floor(y1 / blockBinCount);\n            const row2 = Math.floor((y2 - 1) / blockBinCount);\n\n            const blockNumbers = [];\n            for (let row = row1; row <= row2; row++) {\n                for (let column = col1; column <= col2; column++) {\n                    let blockNumber;\n                    if (sameChr && row < column) {\n                        blockNumber = column * blockColumnCount + row;\n                    } else {\n                        blockNumber = row * blockColumnCount + column;\n                    }\n                    if (!blockNumbers.includes(blockNumber)) {  // possible from transposition\n                        blockNumbers.push(blockNumber);\n                    }\n                }\n            }\n            return blockNumbers\n        }\n\n        function getBlockNumbersV9()\n        {\n\n            const binX1 = region1.start / binsize;\n            const binX2 = region1.end / binsize;\n            const binY1 = region2.start / binsize;\n            const binY2 = region2.end / binsize;\n\n            // PAD = positionAlongDiagonal (~projected)\n            // Depth is axis perpendicular to diagonal; nearer means closer to diagonal\n            const translatedLowerPAD = Math.floor((binX1 + binY1) / 2 / blockBinCount);\n            const translatedHigherPAD = Math.floor((binX2 + binY2) / 2 / blockBinCount);\n            const translatedNearerDepth = Math.floor(Math.log2(1 + Math.abs(binX1 - binY2) / Math.sqrt(2) / blockBinCount));\n            const translatedFurtherDepth = Math.floor(Math.log2(1 + Math.abs(binX2 - binY1) / Math.sqrt(2) / blockBinCount));\n\n            // because code above assume above diagonal; but we could be below diagonal\n            const containsDiagonal = (binX2 - binY1) * (binX1 - binY2) < 0;   // i.e. sign of (x-y) opposite on 2 corners\n            const nearerDepth = containsDiagonal ? 0 : Math.min(translatedNearerDepth, translatedFurtherDepth);\n            const furtherDepth = Math.max(translatedNearerDepth, translatedFurtherDepth);\n\n            const blockNumbers = [];\n            for (let depth = nearerDepth; depth <= furtherDepth; depth++) {\n                for (let pad = translatedLowerPAD; pad <= translatedHigherPAD; pad++) {\n                    const block_number = depth * blockColumnCount + pad;\n                    blockNumbers.push(block_number);\n                }\n            }\n            return blockNumbers\n        }\n    }\n\n    static parseMatrixZoomData(chr1, chr2, dis) {\n\n        const zd = new MatrixZoomData(chr1, chr2);\n\n        const unit = dis.getString();\n        const zoomIndex = dis.getInt();\n        const sumCounts = dis.getFloat();\n        const occupiedCellCount = dis.getFloat();\n        const stdDev = dis.getFloat();\n        const percent95 = dis.getFloat();\n        const binSize = dis.getInt();\n        zd. blockBinCount = dis.getInt();\n        zd. blockColumnCount = dis.getInt();\n        const nBlocks = dis.getInt();\n\n        zd. zoom = {index: zoomIndex, unit: unit, binSize: binSize};\n\n        zd.blockIndex = new StaticBlockIndex(nBlocks, dis);\n\n        const nBins1 = (chr1.size / binSize);\n        const nBins2 = (chr2.size / binSize);\n        const avgCount = (sumCounts / nBins1) / nBins2;   // <= trying to avoid overflows\n\n        zd.averageCount = avgCount;\n        zd.sumCounts = sumCounts;\n        zd.stdDev = stdDev;\n        zd.occupiedCellCount = occupiedCellCount;\n        zd.percent95 = percent95;\n\n        return zd;\n    }\n}\n\n\nclass StaticBlockIndex {\n\n    constructor(nBlocks, dis) {\n        this.blockIndex = {};\n        while (nBlocks-- > 0) {\n            const blockNumber = dis.getInt();\n            const filePosition = dis.getLong();\n            const size = dis.getInt();\n            this.blockIndex[blockNumber] = {filePosition, size};\n        }\n    }\n\n    getBlockIndexEntry(blockNumber) {\n        return this.blockIndex[blockNumber];\n    }\n}\n\nclass Matrix {\n\n    constructor(chr1, chr2, zoomDataList) {\n        this.chr1 = chr1;\n        this.chr2 = chr2;\n        this.bpZoomData = [];\n        this.fragZoomData = [];\n        for (let zd of zoomDataList) {\n            if (zd.zoom.unit === \"BP\") {\n                this.bpZoomData.push(zd);\n            } else {\n                this.fragZoomData.push(zd);\n            }\n        }\n    }\n\n    /**\n     * Find the best zoom level for the given bin size\n     * @param binSize\n     * @param unit\n     * @returns {number}\n     */\n    findZoomForResolution(binSize, unit) {\n        const zdArray = \"FRAG\" === unit ? this.fragZoomData : this.bpZoomData;\n        for (let i = 1; i < zdArray.length; i++) {\n            var zd = zdArray[i];\n            if (zd.zoom.binSize < binSize) {\n                return i - 1\n            }\n        }\n        return zdArray.length - 1\n    }\n\n    /**\n     * Fetch zoom data by bin size.  If no matching level exists return undefined.\n     *\n     * @param unit\n     * @param binSize\n     * @param zoom\n     * @returns {undefined|*}\n     */\n    getZoomData(binSize, unit) {\n        unit = unit || \"BP\";\n        const zdArray = unit === \"BP\" ? this.bpZoomData : this.fragZoomData;\n        for (let i = 0; i < zdArray.length; i++) {\n            var zd = zdArray[i];\n            if (binSize === zd.zoom.binSize) {\n                return zd\n            }\n        }\n        return undefined\n    }\n\n    /**\n     * Return zoom data by resolution index.\n     * @param index\n     * @param unit\n     * @returns {*}\n     */\n    getZoomDataByIndex(index, unit) {\n        const zdArray = \"FRAG\" === unit ? this.fragZoomData : this.bpZoomData;\n        return zdArray[index]\n    }\n\n    static getKey(chrIdx1, chrIdx2) {\n        if (chrIdx1 > chrIdx2) {\n            const tmp = chrIdx1;\n            chrIdx1 = chrIdx2;\n            chrIdx2 = tmp;\n        }\n        return `${chrIdx1}_${chrIdx2}`;\n    }\n\n    static parseMatrix(data, chromosomes) {\n\n        const dis = new BinaryParser(new DataView(data));\n        const c1 = dis.getInt();     // Should equal chrIdx1\n        const c2 = dis.getInt();     // Should equal chrIdx2\n\n        // TODO validate this\n        const chr1 = chromosomes[c1];\n        const chr2 = chromosomes[c2];\n\n        // # of resolution levels (bp and frags)\n        let nResolutions = dis.getInt();\n        const zdList = [];\n\n        while (nResolutions-- > 0) {\n            const zd = MatrixZoomData.parseMatrixZoomData(chr1, chr2, dis);\n            zdList.push(zd);\n        }\n        return new Matrix(c1, c2, zdList);\n    }\n\n}\n\nclass ContactRecord {\n\n    constructor(bin1, bin2, counts) {\n        this.bin1 = bin1;\n        this.bin2 = bin2;\n        this.counts = counts;\n    };\n\n    getKey() {\n        return \"\" + this.bin1 + \"_\" + this.bin2;\n    }\n}\n\nclass LRU {\n    constructor(max = 10) {\n        this.max = max;\n        this.map = new Map();\n    }\n\n    get(key) {\n        let item = this.map.get(key);\n        if (item) {\n            // refresh key\n            this.map.delete(key);\n            this.map.set(key, item);\n        }\n        return item;\n    }\n\n    set(key, val) {\n        // refresh key\n        if (this.map.has(key)) this.map.delete(key);\n        // evict oldest\n        else if (this.map.size === this.max) {\n            this.map.delete(this.first());\n        }\n        this.map.set(key, val);\n    }\n\n    has(key) {\n        return this.map.has(key);\n    }\n\n    clear() {\n        this.map.clear();\n    }\n\n    first() {\n        return this.map.keys().next().value;\n    }\n}\n\n/*\n *  The MIT License (MIT)\n *\n * Copyright (c) 2016-2017 The Regents of the University of California\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n * associated documentation files (the \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\nconst DOUBLE = 8;\n\nclass NormalizationVector {\n\n    constructor(file, filePosition, nValues, dataType) {\n        this.file = file;\n        this.filePosition = filePosition;\n        this.nValues = nValues;\n        this.dataType = dataType;\n        this.cache = undefined;\n    }\n\n    async getValues(start, end) {\n\n        if(!this.cache || start < this.cache.start || end > this.cache.end) {\n            const adjustedStart = Math.max(0, start - 1000);\n            const adjustedEnd = Math.min(this.nValues, end + 1000);\n            const startPosition = this.filePosition + adjustedStart * this.dataType;\n            const n = adjustedEnd - adjustedStart;\n            const sizeInBytes = n  * this.dataType;\n            const data = await this.file.read(startPosition, sizeInBytes);\n            if (!data) {\n                return undefined;\n            }\n            const parser = new BinaryParser(new DataView(data));\n\n            const values = [];\n            for (let i = 0; i < n; i++) {\n                values[i] = this.dataType === DOUBLE ? parser.getDouble() : parser.getFloat();\n\n            }\n            this.cache = {\n                start: adjustedStart,\n                end: adjustedEnd,\n                values: values\n            };\n        }\n\n        const sliceStart = start - this.cache.start;\n        const sliceEnd = sliceStart + (end - start);\n        return this.cache.values.slice(sliceStart, sliceEnd);\n    }\n\n    getKey() {\n        return NormalizationVector.getKey(this.type, this.chrIdx, this.unit, this.resolution);\n    }\n\n\n    static getNormalizationVectorKey(type, chrIdx, unit, resolution) {\n        return type + \"_\" + chrIdx + \"_\" + unit + \"_\" + resolution;\n    }\n}\n\nconst isNode$3 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\nconst Short_MIN_VALUE = -32768;\nconst DOUBLE$1 = 8;\nconst FLOAT = 4;\nconst INT = 4;\nconst GoogleRateLimiter = new RateLimiter(100);\n\n\nclass HicFile {\n\n    constructor(args) {\n\n        this.config = args;\n\n        this.loadFragData = args.loadFragData;\n        this.fragmentSitesCache = {};\n        this.normVectorCache = new LRU(10);\n        this.normalizationTypes = ['NONE'];\n        this.matrixCache = new LRU(10);\n        this.blockCache = new BlockCache();\n\n        // args may specify an io.File object, a local path (Node only), or a url\n        if (args.file) {\n            this.file = args.file;\n        } else if (args.blob) {\n            this.file = new BrowserLocalFile(args.blob);\n        } else if (args.url || (args.path && !isNode$3)) {\n            this.url = args.url || this.path;\n            this.remote = true;\n\n            // Google drive must be rate limited.  Perhaps all remote files should be rate limited?\n            const remoteFile = new RemoteFile(args);\n            if (isGoogleDrive(this.url)) {\n                this.file = new ThrottledFile(remoteFile, GoogleRateLimiter);\n            } else {\n                this.file = remoteFile;\n            }\n        } else if (args.path) {\n            // path argument, assumed local file\n            this.file = new NodeLocalFile({path: args.path});\n\n        } else {\n            throw Error(\"Arguments must include file, blob, url, or path\")\n        }\n    }\n\n\n    async init() {\n\n        if (this.initialized) {\n            return;\n        } else {\n            await this.readHeaderAndFooter();\n            // Footer is read with header\n            //await this.readFooter()\n            this.initialized = true;\n        }\n    }\n\n    async getVersion() {\n        if (this.version === undefined) {\n            const data = await this.file.read(0, 128);\n            if (!data) {\n                return undefined;\n            }\n            const binaryParser = new BinaryParser(new DataView(data));\n            this.magic = binaryParser.getString();\n            this.version = binaryParser.getInt();\n            return this.version\n        } else {\n            return this.version\n        }\n    }\n\n    async getMetaData() {\n        await this.init();\n        return this.meta\n    }\n\n    async readHeaderAndFooter() {\n\n        // Read initial fields magic, version, and footer position\n        let data = await this.file.read(0, 16);\n        if (!data || data.byteLength === 0) {\n            throw Error(\"File content is empty\")\n        }\n        let binaryParser = new BinaryParser(new DataView(data));\n        this.magic = binaryParser.getString();\n        this.version = binaryParser.getInt();\n        if (this.version < 5) {\n            throw Error(\"Unsupported hic version: \" + this.version)\n        }\n        this.footerPosition = binaryParser.getLong();\n\n        // Read footer and determine file position for body section (i.e. end of header)\n\n        await this.readFooter();\n\n        const bodyPostion = Object.values(this.masterIndex).reduce((min, currentValue) => {\n            return Math.min(min, currentValue.start)\n        }, Number.MAX_VALUE);\n\n        const remainingSize = bodyPostion - 16;\n        data = await this.file.read(16, remainingSize);\n        binaryParser = new BinaryParser(new DataView(data));\n\n        this.genomeId = binaryParser.getString();\n\n        if (this.version >= 9) {\n            this.normVectorIndexPosition = binaryParser.getLong();\n            this.normVectorIndexSize = binaryParser.getLong();\n        }\n\n        this.attributes = {};\n        let nAttributes = binaryParser.getInt();\n        while (nAttributes-- > 0) {\n            this.attributes[binaryParser.getString()] = binaryParser.getString();\n        }\n\n        this.chromosomes = [];\n        this.chromosomeIndexMap = {};\n        let nChrs = binaryParser.getInt();\n        let i = 0;\n        while (nChrs-- > 0) {\n            const chr = {\n                index: i,\n                name: binaryParser.getString(),\n                size: this.version < 9 ? binaryParser.getInt() : binaryParser.getLong()\n            };\n            if (chr.name.toLowerCase() === \"all\") {\n                this.wholeGenomeChromosome = chr;\n                this.wholeGenomeResolution = Math.round(chr.size * (1000 / 500));    // Hardcoded in juicer\n            }\n            this.chromosomes.push(chr);\n            this.chromosomeIndexMap[chr.name] = chr.index;\n            i++;\n        }\n\n        this.bpResolutions = [];\n        let nBpResolutions = binaryParser.getInt();\n        while (nBpResolutions-- > 0) {\n            this.bpResolutions.push(binaryParser.getInt());\n        }\n\n        if (this.loadFragData) {\n            this.fragResolutions = [];\n            let nFragResolutions = binaryParser.getInt();\n            if (nFragResolutions > 0) {\n                while (nFragResolutions-- > 0) {\n                    this.fragResolutions.push(binaryParser.getInt());\n                }\n\n                // this.sites = [];\n                // for(let i=0; i<this.chromosomes.length - 1; i++) {\n                //     const chrSites = [];\n                //     this.sites.push(chrSites);\n                //     let nSites = binaryParser.getInt();\n                //     console.log(nSites);\n                //     for(let s=0; s<nSites; s++) {\n                //         chrSites.push(binaryParser.getInt());\n                //     }\n                // }\n            }\n        }\n\n        // Build lookup table for well-known chr aliases\n        this.chrAliasTable = {};\n        for (let chrName of Object.keys(this.chromosomeIndexMap)) {\n\n            if (chrName.startsWith(\"chr\")) {\n                this.chrAliasTable[chrName.substr(3)] = chrName;\n            } else if (chrName === \"MT\") {\n                this.chrAliasTable[\"chrM\"] = chrName;\n            } else {\n                this.chrAliasTable[\"chr\" + chrName] = chrName;\n            }\n        }\n\n\n        // Meta data for the API\n        this.meta = {\n            \"version\": this.version,\n            \"genome\": this.genomeId,\n            \"chromosomes\": this.chromosomes,\n            \"resolutions\": this.bpResolutions,\n        };\n\n\n    }\n\n    async readFooter() {\n\n\n        const skip = this.version < 9 ? 8 : 12;\n        let data = await this.file.read(this.footerPosition, skip);\n        if (!data) {\n            return null;\n        }\n\n        let binaryParser = new BinaryParser(new DataView(data));\n        const nBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();  // Total size, master index + expected values\n        let nEntries = binaryParser.getInt();\n\n        // Estimate the size of the master index. String length of key is unknown, be conservative (100 bytes)\n\n        const miSize = nEntries * (100 + 64 + 32);\n        data = await this.file.read(this.footerPosition + skip, Math.min(miSize, nBytes));\n\n        binaryParser = new BinaryParser(new DataView(data));\n\n        this.masterIndex = {};\n        while (nEntries-- > 0) {\n            const key = binaryParser.getString();\n            const pos = binaryParser.getLong();\n            const size = binaryParser.getInt();\n            this.masterIndex[key] = {start: pos, size: size};\n        }\n\n        this.expectedValueVectors = {};\n\n        // Expected values\n        // const nExpValues = binaryParser.readInt();\n        // while (nExpValues-- > 0) {\n        //     type = \"NONE\";\n        //     unit = binaryParser.getString();\n        //     binSize = binaryParser.getInt();\n        //     nValues = binaryParser.getInt();\n        //     values = [];\n        //     while (nValues-- > 0) {\n        //         values.push(binaryParser.getDouble());\n        //     }\n        //\n        //     nChrScaleFactors = binaryParser.getInt();\n        //     normFactors = {};\n        //     while (nChrScaleFactors-- > 0) {\n        //         normFactors[binaryParser.getInt()] = binaryParser.getDouble();\n        //     }\n        //\n        //     // key = unit + \"_\" + binSize + \"_\" + type;\n        //     //  NOT USED YET SO DON'T STORE\n        //     //  dataset.expectedValueVectors[key] =\n        //     //      new ExpectedValueFunction(type, unit, binSize, values, normFactors);\n        // }\n\n        // normalized expected values start after expected value.  Add 4 for\n        if (this.version > 5) {\n            const skip = this.version < 9 ? 4 : 8;\n            this.normExpectedValueVectorsPosition = this.footerPosition + skip + nBytes;\n        }\n        return this;\n    };\n\n    async printIndexStats() {\n\n        let totalSize = 0;\n        let maxSize = 0;\n        await await this.init();\n        for (let key of Object.keys(this.masterIndex)) {\n            const entry = this.masterIndex[key];\n            //  console.log(`${key}\\t${entry.start}\\t${entry.size}`)\n            totalSize += entry.size;\n            if (entry.size > maxSize) {\n                maxSize = entry.size;\n            }\n        }\n        // console.log(`Total size  = ${totalSize}`);\n    }\n\n    async getMatrix(chrIdx1, chrIdx2) {\n        const key = Matrix.getKey(chrIdx1, chrIdx2);\n        if (this.matrixCache.has(key)) {\n            return this.matrixCache.get(key);\n        } else {\n            const matrix = await this.readMatrix(chrIdx1, chrIdx2);\n            this.matrixCache.set(key, matrix);\n            return matrix;\n        }\n    }\n\n    async readMatrix(chrIdx1, chrIdx2) {\n\n        await this.init();\n\n        if (chrIdx1 > chrIdx2) {\n            const tmp = chrIdx1;\n            chrIdx1 = chrIdx2;\n            chrIdx2 = tmp;\n        }\n\n        const key = Matrix.getKey(chrIdx1 , chrIdx2);\n        const idx = this.masterIndex[key];\n        if (!idx) {\n            return undefined\n        }\n        const data = await this.file.read(idx.start, idx.size);\n        if (!data) {\n            return undefined\n        }\n\n        return Matrix.parseMatrix(data, this.chromosomes);\n\n    }\n\n    async getContactRecords(normalization, region1, region2, units, binsize, allRecords = false) {\n\n        await this.init();\n\n        const idx1 = this.chromosomeIndexMap[this.getFileChrName(region1.chr)];\n        const idx2 = this.chromosomeIndexMap[this.getFileChrName(region2.chr)];\n\n        const transpose = (idx1 > idx2) || (idx1 === idx2 && region1.start >= region2.end);\n        if (transpose) {\n            const tmp = region1;\n            region1 = region2;\n            region2 = tmp;\n        }\n\n        const blocks = await this.getBlocks(region1, region2, units, binsize);\n        if (!blocks || blocks.length === 0) {\n            return []\n        }\n\n        const contactRecords = [];\n        const x1 = region1.start / binsize;\n        const x2 = region1.end / binsize;\n        const y1 = region2.start / binsize;\n        const y2 = region2.end / binsize;\n        const nvX1 = Math.floor(x1);\n        const nvX2 = Math.ceil(x2);\n        const nvY1 = Math.floor(y1);\n        const nvY2 = Math.ceil(y2);\n        for (let block of blocks) {\n            if (block) { // An undefined block is most likely caused by a base pair range outside the chromosome\n                let normVector1;\n                let normVector2;\n                let isNorm = normalization && normalization !== \"NONE\";\n                const chr1 = this.getFileChrName(region1.chr);\n                const chr2 = this.getFileChrName(region2.chr);\n                if (isNorm) {\n                    const nv1 = await this.getNormalizationVector(normalization, chr1, units, binsize);\n                    const nv2 = (chr1 === chr2) ? nv1 : await this.getNormalizationVector(normalization, chr2, units, binsize);\n\n                    if (nv1 && nv2) {\n                        normVector1 = await nv1.getValues(nvX1, nvX2);\n                        normVector2 = await nv2.getValues(nvY1, nvY2);\n                    } else {\n                        isNorm = false;\n                        // Raise message and switch pulldown\n                    }\n                }\n\n                for (let rec of block.records) {\n                    if (allRecords || (rec.bin1 >= x1 && rec.bin1 < x2 && rec.bin2 >= y1 && rec.bin2 < y2)) {\n                        if (isNorm) {\n                            const x = rec.bin1;\n                            const y = rec.bin2;\n                            const nvnv = normVector1[x - nvX1] * normVector2[y - nvY1];\n                            if (nvnv !== 0 && !isNaN(nvnv)) {\n                                const counts = rec.counts / nvnv;\n                                contactRecords.push(new ContactRecord(x, y, counts));\n                            }\n                        } else {\n                            contactRecords.push(rec);\n                        }\n                    }\n                }\n            }\n        }\n\n        return contactRecords;\n    }\n\n    async getBlocks(region1, region2, unit, binSize) {\n\n        await this.init();\n        const chr1 = this.getFileChrName(region1.chr);\n        const chr2 = this.getFileChrName(region2.chr);\n        const idx1 = this.chromosomeIndexMap[chr1];\n        const idx2 = this.chromosomeIndexMap[chr2];\n\n        if (idx1 === undefined) {\n            return []\n        }\n        if (idx2 === undefined) {\n            return []\n        }\n\n        const matrix = await this.getMatrix(idx1, idx2);\n        if (!matrix) {\n            return []\n        }\n\n        const zd = matrix.getZoomData(binSize, unit);\n        if (!zd) {\n            let msg = `No data avalailble for resolution: ${binSize}  for map ${region1.chr}-${region2.chr}`;\n            throw new Error(msg)\n        }\n\n        const blockNumbers = zd.getBlockNumbers(region1, region2, this.version);\n\n        const blocks = [];\n        const blockNumbersToQuery = [];\n        for (let num of blockNumbers) {\n            if (this.blockCache.has(binSize, num)) {\n                blocks.push(this.blockCache.get(binSize, num));\n            } else {\n                blockNumbersToQuery.push(num);\n            }\n        }\n\n        const promises = blockNumbersToQuery.map(blockNumber => this.readBlock(blockNumber, zd));\n        const newBlocks = await Promise.all(promises);\n        for (let block of newBlocks) {\n            if (block) {\n                this.blockCache.set(binSize, block.blockNumber, block);\n            }\n        }\n        return blocks.concat(newBlocks);\n    }\n\n    async readBlock(blockNumber, zd) {\n\n        const idx = await zd.blockIndex.getBlockIndexEntry(blockNumber);\n\n        if (!idx) {\n            return undefined\n        } else {\n            let data = await this.file.read(idx.filePosition, idx.size);\n            if (!data) {\n                return undefined;\n            }\n\n            const inflate = new Zlib.Inflate(new Uint8Array(data));\n            const plain = inflate.decompress();\n            //var plain = zlib.inflateSync(Buffer.from(data))   //.decompress();\n            data = plain.buffer;\n\n            const parser = new BinaryParser(new DataView(data));\n            const nRecords = parser.getInt();\n            const records = [];\n\n            if (this.version < 7) {\n                for (let i = 0; i < nRecords; i++) {\n                    const binX = parser.getInt();\n                    const binY = parser.getInt();\n                    const counts = parser.getFloat();\n                    records.push(new ContactRecord(binX, binY, counts));\n                }\n            } else {\n\n                const binXOffset = parser.getInt();\n                const binYOffset = parser.getInt();\n\n                const useFloatContact = parser.getByte() === 1;\n                const useIntXPos = this.version < 9 ? false : parser.getByte() == 1;\n                const useIntYPos = this.version < 9 ? false : parser.getByte() == 1;\n                const type = parser.getByte();\n\n                if (type === 1) {\n                    // List-of-rows representation\n                    const rowCount = useIntYPos ? parser.getInt() : parser.getShort();\n                    for (let i = 0; i < rowCount; i++) {\n                        const dy = useIntYPos ? parser.getInt() : parser.getShort();\n                        const binY = binYOffset + dy;\n                        const colCount = useIntXPos ? parser.getInt() : parser.getShort();\n                        for (let j = 0; j < colCount; j++) {\n                            const dx = useIntXPos ? parser.getInt() : parser.getShort();\n                            const binX = binXOffset + dx;\n                            const counts = useFloatContact ? parser.getFloat() : parser.getShort();\n                            records.push(new ContactRecord(binX, binY, counts));\n                        }\n                    }\n                } else if (type == 2) {\n\n                    const nPts = parser.getInt();\n                    const w = parser.getShort();\n\n                    for (let i = 0; i < nPts; i++) {\n                        //int idx = (p.y - binOffset2) * w + (p.x - binOffset1);\n                        const row = Math.floor(i / w);\n                        const col = i - row * w;\n                        const bin1 = binXOffset + col;\n                        const bin2 = binYOffset + row;\n\n                        if (useFloatContact) {\n                            const counts = parser.getFloat();\n                            if (!isNaN(counts)) {\n                                records.push(new ContactRecord(bin1, bin2, counts));\n                            }\n                        } else {\n                            const counts = parser.getShort();\n                            if (counts != Short_MIN_VALUE) {\n                                records.push(new ContactRecord(bin1, bin2, counts));\n                            }\n                        }\n                    }\n                } else {\n                    throw new Error(\"Unknown block type: \" + type);\n                }\n\n            }\n\n            return new Block(blockNumber, zd, records, idx);\n\n\n        }\n    };\n\n    async hasNormalizationVector(type, chr, unit, binSize) {\n        await this.init();\n        let chrIdx;\n        if (Number.isInteger(chr)) {\n            chrIdx = chr;\n        } else {\n            const canonicalName = this.getFileChrName(chr);\n            chrIdx = this.chromosomeIndexMap[canonicalName];\n        }\n        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);\n        const normVectorIndex = await this.getNormVectorIndex();\n        return normVectorIndex && normVectorIndex[key];\n    }\n\n    async getNormalizationVector(type, chr, unit, binSize) {\n\n        await this.init();\n\n        let chrIdx;\n        if (Number.isInteger(chr)) {\n            chrIdx = chr;\n        } else {\n            const canonicalName = this.getFileChrName(chr);\n            chrIdx = this.chromosomeIndexMap[canonicalName];\n        }\n\n        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);\n\n        if (this.normVectorCache.has(key)) {\n            return this.normVectorCache.get(key);\n        }\n\n        const normVectorIndex = await this.getNormVectorIndex();\n\n        if (!normVectorIndex) {\n            return undefined\n        }\n\n        const idx = normVectorIndex[key];\n        if (!idx) {\n            // TODO -- alert in browsers\n            return undefined;\n        }\n\n        const data = await this.file.read(idx.filePosition, 8);\n\n        if (!data) {\n            return undefined;\n        }\n\n        const parser = new BinaryParser(new DataView(data));\n        const nValues = this.version < 9 ? parser.getInt() : parser.getLong();\n        const dataType = this.version < 9 ? DOUBLE$1 : FLOAT;\n        const filePosition = this.version < 9 ? idx.filePosition + 4 : idx.filePosition + 8;\n        const nv = new NormalizationVector(this.file, filePosition, nValues, dataType);\n        this.normVectorCache.set(key, nv);\n        return nv;\n\n    }\n\n    async getNormVectorIndex() {\n\n        if (this.version < 6) {\n            return undefined;\n        }\n\n        if (!this.normVectorIndex) {\n\n            // If nvi is not supplied, try reading from remote lambda service\n            if (!this.config.nvi && this.remote && this.url) {\n                const url = new URL(this.url);\n                const key = encodeURIComponent(url.hostname + url.pathname);\n                const nviResponse = await crossFetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);\n                if (nviResponse.status === 200) {\n                    const nvi = await nviResponse.text();\n                    if (nvi) {\n                        this.config.nvi = nvi;\n                    }\n                }\n            }\n\n            if (this.config.nvi) {\n                const nviArray = decodeURIComponent(this.config.nvi).split(\",\");\n                const range = {start: parseInt(nviArray[0]), size: parseInt(nviArray[1])};\n                return this.readNormVectorIndex(range)\n            } else {\n                try {\n                    await this.readNormExpectedValuesAndNormVectorIndex();\n                    return this.normVectorIndex\n                } catch (e) {\n                    if (e.code === \"416\" || e.code === 416) {\n                        // This is expected if file does not contain norm vectors\n                        this.normExpectedValueVectorsPosition = undefined;\n                    } else {\n                        console.error(e);\n                    }\n                }\n            }\n        }\n\n        return this.normVectorIndex\n    }\n\n    async getNormalizationOptions() {\n        // Normalization options are computed as a side effect of loading the index.  A bit\n        // ugly but alternatives are worse.\n        await this.getNormVectorIndex();\n        return this.normalizationTypes;\n    }\n\n    /**\n     * Return a promise to load the normalization vector index\n     *\n     * @param dataset\n     * @param range  -- file range {position, size}\n     * @returns Promise for the normalization vector index\n     */\n    async readNormVectorIndex(range) {\n\n        await this.init();\n\n        this.normalizationVectorIndexRange = range;\n\n        const data = await this.file.read(range.start, range.size);\n\n        const binaryParser = new BinaryParser(new DataView(data));\n\n        this.normVectorIndex = {};\n\n        let nEntries = binaryParser.getInt();\n        while (nEntries-- > 0) {\n            this.parseNormVectorEntry(binaryParser);\n        }\n\n        return this.normVectorIndex;\n\n    }\n\n    /**\n     * This function is used when the position of the norm vector index is unknown.  We must read through the expected\n     * values to find the index\n     *\n     * @param dataset\n     * @returns {Promise}\n     */\n    async readNormExpectedValuesAndNormVectorIndex() {\n\n        await this.init();\n\n        if (this.normExpectedValueVectorsPosition === undefined) {\n            return;\n        }\n\n        const nviStart = await this.skipExpectedValues(this.normExpectedValueVectorsPosition);\n        let byteCount = INT;\n\n        let data = await this.file.read(nviStart, INT);\n        if (data.byteLength === 0) {\n            // This is possible if there are no norm vectors.  Its a legal v8 file, though uncommon\n            return;\n        }\n        const binaryParser = new BinaryParser(new DataView(data));\n        const nEntries = binaryParser.getInt();\n        const sizeEstimate = nEntries * 30;\n        const range = {start: nviStart + byteCount, size: sizeEstimate};\n\n        data = await this.file.read(range.start, range.size);\n        this.normalizedExpectedValueVectors = {};\n        this.normVectorIndex = {};\n\n        // Recursively process entries\n        await processEntries.call(this, nEntries, data);\n\n        this.config.nvi = nviStart.toString() + \",\" + byteCount;\n\n        async function processEntries(nEntries, data) {\n\n            const binaryParser = new BinaryParser(new DataView(data));\n\n            while (nEntries-- > 0) {\n\n                if (binaryParser.available() < 100) {\n\n                    nEntries++;   // Reset counter as entry is not processed\n\n                    byteCount += binaryParser.position;\n                    const sizeEstimate = Math.max(1000, nEntries * 30);\n                    const range = {start: nviStart + byteCount, size: sizeEstimate};\n                    const data = await this.file.read(range.start, range.size);\n                    return processEntries.call(this, nEntries, data);\n                }\n\n                this.parseNormVectorEntry(binaryParser);\n\n            }\n            byteCount += binaryParser.position;\n        }\n    }\n\n    /**\n     * This function is used when the position of the norm vector index is unknown.  We must read through the\n     * normalized expected values to find the index\n     *\n     * @param dataset\n     * @returns {Promise}\n     */\n    async skipExpectedValues(start) {\n\n        const version = this.version;\n        const file = new BufferedFile({file: this.file, size: 256000});\n        const range = {start: start, size: INT};\n        const data = await file.read(range.start, range.size);\n        const binaryParser = new BinaryParser(new DataView(data));\n        const nEntries = binaryParser.getInt();   // Total # of expected value chunks\n        if (nEntries === 0) {\n            return start + INT;\n        } else {\n            return parseNext(start + INT, nEntries);\n        }     // Skip 4 bytes for int\n\n\n        async function parseNext(start, nEntries) {\n\n            let range = {start: start, size: 500};\n            let chunkSize = 0;\n            let p0 = start;\n\n            let data = await file.read(range.start, range.size);\n            let binaryParser = new BinaryParser(new DataView(data));\n            const type = binaryParser.getString(); // type\n            const unit = binaryParser.getString(); // unit\n            const binSize = binaryParser.getInt(); // binSize\n            const nValues = version < 9 ? binaryParser.getInt() : binaryParser.getLong();\n\n            chunkSize += binaryParser.position + nValues * (version < 9 ? DOUBLE$1 : FLOAT);\n\n            range = {start: start + chunkSize, size: INT};\n            data = await file.read(range.start, range.size);\n            binaryParser = new BinaryParser(new DataView(data));\n            const nChrScaleFactors = binaryParser.getInt();\n            chunkSize += (INT + nChrScaleFactors * (INT + (version < 9 ? DOUBLE$1 : FLOAT)));\n\n\n            nEntries--;\n            if (nEntries === 0) {\n                return p0 + chunkSize;\n            } else {\n                return parseNext(p0 + chunkSize, nEntries);\n            }\n        }\n    }\n\n    getZoomIndexForBinSize(binSize, unit) {\n\n        unit = unit || \"BP\";\n\n        let resolutionArray;\n        if (unit === \"BP\") {\n            resolutionArray = this.bpResolutions;\n        } else if (unit === \"FRAG\") {\n            resolutionArray = this.fragResolutions;\n        } else {\n            throw new Error(\"Invalid unit: \" + unit);\n        }\n\n        for (let i = 0; i < resolutionArray.length; i++) {\n            if (resolutionArray[i] === binSize) return i;\n        }\n\n        return -1;\n    }\n\n    parseNormVectorEntry(binaryParser) {\n        const type = binaryParser.getString();      //15\n        const chrIdx = binaryParser.getInt();       //4\n        const unit = binaryParser.getString();      //3\n        const binSize = binaryParser.getInt();      //4\n        const filePosition = binaryParser.getLong();  //8\n        const sizeInBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();     //4:8\n        const key = type + \"_\" + chrIdx + \"_\" + unit + \"_\" + binSize;\n        // TODO -- why does this not work?  NormalizationVector.getNormalizationVectorKey(type, chrIdx, unit, binSize);\n\n        if (!this.normalizationTypes.includes(type)) {\n            this.normalizationTypes.push(type);\n        }\n        this.normVectorIndex[key] = {filePosition: filePosition, size: sizeInBytes};\n    }\n\n    getFileChrName(chrAlias) {\n        if (this.chrAliasTable.hasOwnProperty(chrAlias)) {\n            return this.chrAliasTable[chrAlias]\n        } else {\n            return chrAlias\n        }\n    }\n\n\n    // NOTE sties are not currently used\n    // async getSites(chrName) {\n    //     let sites = this.fragmentSitesCache[chrName];\n    //     if (!sites) {\n    //         if (this.fragmentSitesIndex) {\n    //             const entry = self.fragmentSitesIndex[chrName];\n    //             if (entry && entry.nSites > 0) {\n    //                 sites = await this.readSites(entry.position, entry.nSites)\n    //                 this.fragmentSitesCache[chrName] = sites;\n    //             }\n    //         }\n    //     }\n    //     return sites;\n    // }\n    //\n\n}\n\n\nfunction getNormalizationVectorKey(type, chrIdx, unit, resolution) {\n    return type + \"_\" + chrIdx + \"_\" + unit + \"_\" + resolution;\n}\n\nfunction isGoogleDrive(url) {\n    return url.indexOf(\"drive.google.com\") >= 0 || url.indexOf(\"www.googleapis.com/drive\") > 0\n}\n\nclass Block {\n    constructor(blockNumber, zoomData, records, idx) {\n        this.blockNumber = blockNumber;\n        this.zoomData = zoomData;\n        this.records = records;\n        this.idx = idx;\n    }\n}\n\n\nclass BlockCache {\n\n    constructor() {\n        this.resolution = undefined;\n        this.map = new LRU(6);\n    }\n\n    set(resolution, key, value) {\n        if (this.resolution !== resolution) {\n            this.map.clear();\n        }\n        this.resolution = resolution;\n        this.map.set(key, value);\n    }\n\n    get(resolution, key) {\n        return this.resolution === resolution ? this.map.get(key) : undefined;\n    }\n\n    has(resolution, key) {\n        return this.resolution === resolution && this.map.has(key);\n    }\n}\n\nclass Straw {\n\n    constructor(config) {\n        this.config = config;\n        this.hicFile = new HicFile(config);\n    }\n\n    async getMetaData() {\n        return await this.hicFile.getMetaData()\n    }\n\n    //straw <NONE/VC/VC_SQRT/KR> <ile> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>\n    async getContactRecords(normalization, region1, region2, units, binsize) {\n        return this.hicFile.getContactRecords(normalization, region1, region2, units, binsize);\n    }\n\n    async getNormalizationOptions() {\n        return this.hicFile.getNormalizationOptions()\n    }\n\n    async getNVI() {\n        await this.hicFile.getNormVectorIndex();\n        return this.hicFile.config.nvi;\n    }\n\n    async printIndexStats() {\n        await this.hicFile.printIndexStats();\n    }\n\n    getFileChrName(chrAlias) {\n        if (this.hicFile.chrAliasTable.hasOwnProperty(chrAlias)) {\n            return this.hicFile.chrAliasTable[chrAlias]\n        } else {\n            return chrAlias\n        }\n    }\n}\n\nexport default Straw;\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nif (global.fetch) {\n\texports.default = global.fetch.bind(global);\n}\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;"],"sourceRoot":""}