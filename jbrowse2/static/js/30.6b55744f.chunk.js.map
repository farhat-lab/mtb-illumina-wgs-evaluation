{"version":3,"sources":["../../../plugins/variants/node_modules/@gmod/vcf/dist/index.js","../../../plugins/variants/node_modules/@gmod/vcf/dist/parse.js","../../../plugins/variants/node_modules/@gmod/vcf/dist/vcfReserved.js","../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"names":["VCF","require","module","_interopRequireDefault","_slicedToArray2","_classCallCheck2","_createClass2","_vcfReserved","Breakend","key","value","char","this","MateDirection","Join","concat","_this","args","Error","headerLines","line","JSON","INFO","FORMAT","ALT","FILTER","FilterTypes","fields","thisHeader","correctHeader","index","_line$trim$match$slic","_line$trim$match$slic2","metaKey","metaVal","_this$_parseStructure","_parseStructuredMetaVal","_this$_parseStructure2","id","keyVals","_parseKeyValue","Number","filteredMetadata","_len","arguments","Array","_key","i","pairSeparator","data","currKey","currValue","state","str","_this2","currChar","currField","rest","variant","CHROM","POS","ID","REF","QUAL","parseFloat","strict","info","Object","items","val","itemType","console","_parseBreakend","bind","that","Variant","get","samples","tokens","breakendString","parsed","tok","_this3","genotypes","formatKeys","sample","formatValue","formatIndex","thisValue","valueType","exports","InfoFields","AA","Type","Description","AC","AD","ADF","ADR","AF","AN","BQ","CIGAR","DB","DP","END","H2","H3","MQ","MQ0","NS","SB","SOMATIC","VALIDATED","IMPRECISE","NOVEL","SVTYPE","SVLEN","CIPOS","CIEND","HOMLEN","HOMSEQ","BKPTID","MEINFO","METRANS","DGVID","DBVARID","DBRIPID","MATEID","PARID","EVENT","CILEN","DPADJ","CN","CNADJ","CICN","CICNADJ","GenotypeFields","EC","FT","GL","GP","GQ","GT","HQ","PL","PQ","PS","AltTypes","DEL","INS","DUP","INV","CNV","NON_REF","PASS","configured","vcfGzLocation","readConfObject","config","location","indexType","filehandle","openLocation","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","chunkSizeLimit","getHeader","then","header","parser","VcfParser","catch","e","opts","configure","getReferenceSequenceNames","getMetadata","query","ObservableCreate","observer","a","refName","start","end","getLines","lineCallback","fileOffset","next","VcfFeature","parseLine","complete","signal","regions","superGetFeaturesInMultipleRegions","bytesForRegions","bytes","stat","pct","Math","round","size","warn","call","subscribe","Promise","all","map","region","blocksForRange","blockResults","byteRanges","forEach","blocks","block","minv","blockPosition","maxv","find","range","min","max","push","reduce","b","BaseFeatureDataAdapter"],"mappings":"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","file":"static/js/30.6b55744f.chunk.js","sourcesContent":["\"use strict\"; /** @module VCF */\nvar VCF = require('./parse');\n\nmodule.exports = VCF;","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _vcfReserved = _interopRequireDefault(require(\"./vcfReserved\"));var\n\nBreakend = /*#__PURE__*/function () {function Breakend() {(0, _classCallCheck2.default)(this, Breakend);}(0, _createClass2.default)(Breakend, [{ key: \"toString\", value: function toString()\n    {\n      var char = this.MateDirection === 'left' ? ']' : '[';\n      if (this.Join === 'left') {\n        return \"\".concat(char).concat(this.MatePosition).concat(char).concat(this.Replacement);\n      }\n      return \"\".concat(this.Replacement).concat(char).concat(this.MatePosition).concat(char);\n    } }]);return Breakend;}();\n\n\n/**\n                                * Class representing a VCF parser, instantiated with the VCF header.\n                                * @param {object} args\n                                * @param {string} args.header - The VCF header. Supports both LF and CRLF\n                                * newlines.\n                                * @param {boolean} args.strict - Whether to parse in strict mode or not (default true)\n                                */var\nVCF = /*#__PURE__*/function () {\n  function VCF(args) {var _this = this;(0, _classCallCheck2.default)(this, VCF);\n    if (!args || !args.header || !args.header.length) {\n      throw new Error('empty header received');\n    }\n    var headerLines = args.header.split(/[\\r\\n]+/).filter(function (line) {return line;});\n    if (!headerLines.length) {\n      throw new Error('no non-empty header lines specified');\n    }\n\n    // allow access to the Breakend class in case anybody wants to use it for checking\n    this.Breakend = Breakend;\n    this.strict = args.strict !== undefined ? args.strict : true; // true by default\n    this.metadata = JSON.parse(\n    JSON.stringify({\n      INFO: _vcfReserved.default.InfoFields,\n      FORMAT: _vcfReserved.default.GenotypeFields,\n      ALT: _vcfReserved.default.AltTypes,\n      FILTER: _vcfReserved.default.FilterTypes }));\n\n\n    headerLines.forEach(function (line) {\n      if (!line.startsWith('#')) {\n        throw new Error(\"Bad line in header:\\n\".concat(line));\n      }\n      if (line.startsWith('##')) {\n        _this._parseMetadata(line);\n      } else if (line) {\n        var fields = line.split('\\t');\n        var thisHeader = fields.slice(0, 8);\n        var correctHeader = [\n        '#CHROM',\n        'POS',\n        'ID',\n        'REF',\n        'ALT',\n        'QUAL',\n        'FILTER',\n        'INFO'];\n\n        if (fields.length < 8) {\n          throw new Error(\"VCF header missing columns:\\n\".concat(line));\n        } else if (fields.length === 9) {\n          throw new Error(\"VCF header has FORMAT but no samples:\\n\".concat(line));\n        } else if (\n        thisHeader.length !== correctHeader.length ||\n        !thisHeader.every(function (value, index) {return value === correctHeader[index];}))\n        {\n          throw new Error(\"VCF column headers not correct:\\n\".concat(line));\n        }\n        _this.samples = fields.slice(9);\n      }\n    });\n    if (!this.samples) throw new Error('VCF does not have a header line');\n  }\n\n  /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */(0, _createClass2.default)(VCF, [{ key: \"_parseMetadata\", value: function _parseMetadata(\n    line) {var _line$trim$match$slic =\n      line.\n      trim().\n      match(/^##(.+?)=(.*)/).\n      slice(1, 3),_line$trim$match$slic2 = (0, _slicedToArray2.default)(_line$trim$match$slic, 2),metaKey = _line$trim$match$slic2[0],metaVal = _line$trim$match$slic2[1];\n      if (metaVal.startsWith('<')) {\n        if (!(metaKey in this.metadata)) {\n          this.metadata[metaKey] = {};\n        }var _this$_parseStructure =\n        this._parseStructuredMetaVal(metaVal),_this$_parseStructure2 = (0, _slicedToArray2.default)(_this$_parseStructure, 2),id = _this$_parseStructure2[0],keyVals = _this$_parseStructure2[1];\n        this.metadata[metaKey][id] = keyVals;\n      } else {\n        this.metadata[metaKey] = metaVal;\n      }\n    }\n\n    /**\n       * Parse a VCF header structured meta string (i.e. a meta value that starts\n       * with \"<ID=...\")\n       * @param {string} metaVal - The VCF metadata value\n       *\n       * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n       * and 2) an object with the other key-value pairs in the metadata\n       */ }, { key: \"_parseStructuredMetaVal\", value: function _parseStructuredMetaVal(\n    metaVal) {\n      var keyVals = this._parseKeyValue(metaVal.replace(/^<|>$/g, ''), ',');\n      var id = keyVals.ID;\n      delete keyVals.ID;\n      if ('Number' in keyVals) {\n        if (!Number.isNaN(Number(keyVals.Number))) {\n          keyVals.Number = Number(keyVals.Number);\n        }\n      }\n      return [id, keyVals];\n    }\n\n    /**\n       * Get metadata filtered by the elements in args. For example, can pass\n       * ('INFO', 'DP') to only get info on an metadata tag that was like\n       * \"##INFO=<ID=DP,...>\"\n       * @param  {...string} args - List of metadata filter strings.\n       *\n       * @returns {any} An object, string, or number, depending on the filtering\n       */ }, { key: \"getMetadata\", value: function getMetadata()\n    {\n      var filteredMetadata = this.metadata;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      for (var i = 0; i < args.length; i += 1) {\n        filteredMetadata = filteredMetadata[args[i]];\n        if (!filteredMetadata) return filteredMetadata;\n      }\n      return filteredMetadata;\n    }\n\n    /**\n       * Sometimes VCFs have key-value strings that allow the separator within\n       * the value if it's in quotes, like:\n       * 'ID=DB,Number=0,Type=Flag,Description=\"dbSNP membership, build 129\"'\n       *\n       * Parse this at a low level since we can't just split at \",\" (or whatever\n       * separator). Above line would be parsed to:\n       * {ID: 'DB', Number: '0', Type: 'Flag', Description: 'dbSNP membership, build 129'}\n       * @param {string} str - Key-value pairs in a string\n       * @param {string} [pairSeparator] - A string that separates sets of key-value\n       * pairs\n       *\n       * @returns {object} An object containing the key-value pairs\n       */ }, { key: \"_parseKeyValue\", value: function _parseKeyValue(\n    str) {var pairSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ';';\n      var data = {};\n      var currKey = '';\n      var currValue = '';\n      var state = 1; // states: 1: read key to = or pair sep, 2: read value to sep or quote, 3: read value to quote\n      for (var i = 0; i < str.length; i += 1) {\n        if (state === 1) {\n          // read key to = or pair sep\n          if (str[i] === '=') {\n            state = 2;\n          } else if (str[i] !== pairSeparator) {\n            currKey += str[i];\n          } else if (currValue === '') {\n            data[currKey] = null;\n            currKey = '';\n          }\n        } else if (state === 2) {\n          // read value to pair sep or quote\n          if (str[i] === pairSeparator) {\n            data[currKey] = currValue;\n            currKey = '';\n            currValue = '';\n            state = 1;\n          } else if (str[i] === '\"') {\n            state = 3;\n          } else currValue += str[i];\n        } else if (state === 3) {\n          // read value to quote\n          if (str[i] !== '\"') currValue += str[i];else\n          state = 2;\n        }\n      }\n      if (state === 2 || state === 3) {\n        data[currKey] = currValue;\n      } else if (state === 1) {\n        data[currKey] = null;\n      }\n      return data;\n    }\n\n    /**\n       * Parse a VCF line into an object like { CHROM POS ID REF ALT QUAL FILTER\n       * INFO } with SAMPLES optionally included if present in the VCF\n       * @param {string} line - A string of a line from a VCF. Supports both LF and\n       * CRLF newlines.\n       */ }, { key: \"parseLine\", value: function parseLine(\n    line) {var _this2 = this;\n      // eslint-disable-next-line no-param-reassign\n      line = line.trim();\n      if (!line.length) return undefined;\n      var currChar = 0;\n      for (var currField = 0; currChar < line.length; currChar += 1) {\n        if (line[currChar] === '\\t') {\n          currField += 1;\n        }\n        if (currField === 9) {\n          // reached genotypes, rest of fields are evaluated lazily\n          break;\n        }\n      }\n      var fields = line.substr(0, currChar).split('\\t');\n      var rest = line.substr(currChar + 1);\n      var variant = {\n        CHROM: fields[0],\n        POS: Number(fields[1]),\n        ID: fields[2] === '.' ? null : fields[2].split(';'),\n        REF: fields[3],\n        ALT: fields[4] === '.' ? null : fields[4].split(','),\n        QUAL: fields[5] === '.' ? null : parseFloat(fields[5]) };\n\n      if (fields[6] === '.') {\n        variant.FILTER = null;\n      } else if (fields[6] === 'PASS') {\n        variant.FILTER = 'PASS';\n      } else {\n        variant.FILTER = fields[6].split(';');\n      }\n      if (this.strict && fields[7] === undefined) {\n        throw new Error(\n        \"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n\n      }\n      var info =\n      fields[7] === undefined || fields[7] === '.' ?\n      {} :\n      this._parseKeyValue(fields[7]);\n      Object.keys(info).forEach(function (key) {\n        var items;\n        if (info[key]) {\n          items = info[key].split(',');\n          items = items.map(function (val) {return val === '.' ? null : val;});\n        } else items = info[key];\n        var itemType = _this2.getMetadata('INFO', key, 'Type');\n        if (itemType) {\n          if (itemType === 'Integer' || itemType === 'Float') {\n            items = items.map(function (val) {\n              if (val === null) return null;\n              return Number(val);\n            });\n          } else if (itemType === 'Flag') {\n            if (info[key])\n              // eslint-disable-next-line no-console\n              console.warn(\"Info field \".concat(\n              key, \" is a Flag and should not have a value (got value \").concat(info[key], \")\"));else\n\n            items = true;\n          }\n        }\n        info[key] = items;\n      });\n      variant.INFO = info;\n\n      // if this has SVTYPE=BND, parse ALTS for breakend descriptions\n      if (variant.ALT && info && info.SVTYPE && info.SVTYPE[0] === 'BND') {\n        variant.ALT = variant.ALT.map(this._parseBreakend.bind(this));\n      }\n\n      // This creates a closure that allows us to attach \"SAMPLES\" as a lazy\n      // attribute\n\n      function Variant(stuff) {\n        Object.assign(this, stuff);\n      }\n\n      var that = this;\n\n      Object.defineProperty(Variant.prototype, 'SAMPLES', {\n        get: function get() {\n          var samples = that._parseGenotypes(fields[8], rest);\n\n          Object.defineProperty(this, 'SAMPLES', {\n            value: samples });\n\n\n          return samples;\n        } });\n\n\n      return new Variant(variant);\n    } }, { key: \"_parseBreakend\", value: function _parseBreakend(\n\n    breakendString) {\n      var tokens = breakendString.split(/[[\\]]/);\n      if (tokens.length > 1) {\n        var parsed = new Breakend();\n        parsed.MateDirection = breakendString.includes('[') ? 'right' : 'left';\n        for (var i = 0; i < tokens.length; i += 1) {\n          var tok = tokens[i];\n          if (tok) {\n            if (tok.includes(':')) {\n              // this is the remote location\n              parsed.MatePosition = tok;\n              parsed.Join = parsed.Replacement ? 'right' : 'left';\n            } else {\n              // this is the local alteration\n              parsed.Replacement = tok;\n            }\n          }\n        }\n        return parsed;\n      }\n      // if there is not more than one token, there are no [ or ] characters,\n      // so just return it unmodified\n      return breakendString;\n    } }, { key: \"_parseGenotypes\", value: function _parseGenotypes(\n\n    formatKeys, rest) {var _this3 = this;\n      // eslint-disable-next-line no-param-reassign\n      rest = rest.split('\\t');\n      var genotypes = {};\n      // eslint-disable-next-line no-param-reassign\n      formatKeys = formatKeys && formatKeys.split(':');\n      this.samples.forEach(function (sample, index) {\n        genotypes[sample] = {};\n        formatKeys.forEach(function (key) {\n          genotypes[sample][key] = null;\n        });\n        rest[index].split(':').forEach(function (formatValue, formatIndex) {\n          var thisValue;\n          if (\n          formatValue === '' ||\n          formatValue === '.' ||\n          formatValue === undefined)\n          {\n            thisValue = null;\n          } else {\n            thisValue = formatValue.\n            split(',').\n            map(function (val) {return val === '.' ? null : val;});\n            var valueType = _this3.getMetadata(\n            'FORMAT',\n            formatKeys[formatIndex],\n            'Type');\n\n            if ((valueType === 'Integer' || valueType === 'Float') && thisValue) {\n              thisValue = thisValue.map(function (val) {\n                if (!val) return null;\n                return Number(val);\n              });\n            }\n          }\n          genotypes[sample][formatKeys[formatIndex]] = thisValue;\n        }, {});\n      });\n      return genotypes;\n    } }]);return VCF;}();\n\n\nmodule.exports = VCF;","\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;var _default = {\n  // INFO fields\n  InfoFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n    AC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description:\n      'Allele count in genotypes, for each ALT allele, in the same order as listed' },\n\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Total read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    AF: {\n      Number: 'A',\n      Type: 'Float',\n      Description:\n      'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)' },\n\n    AN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Total number of alleles in called genotypes' },\n\n    BQ: {\n      Number: 1,\n      Type: 'Float',\n      Description: 'RMS base quality' },\n\n    CIGAR: {\n      Number: 1,\n      Type: 'Float',\n      Description:\n      'Cigar string describing how to align an alternate allele to the reference allele' },\n\n    DB: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'dbSNP membership' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'combined depth across samples' },\n\n    END: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'End position (for use with symbolic alleles)' },\n\n    H2: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap2 membership' },\n\n    H3: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap3 membership' },\n\n    MQ: {\n      Number: 1,\n      Type: null,\n      Description: 'RMS mapping quality' },\n\n    MQ0: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of MAPQ == 0 reads' },\n\n    NS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of samples with data' },\n\n    SB: {\n      Number: 4,\n      Type: 'Integer',\n      Description: 'Strand bias' },\n\n    SOMATIC: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Somatic mutation (for cancer genomics)' },\n\n    VALIDATED: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Validated by follow-up experiment' },\n\n    '1000G': {\n      Number: 0,\n      Type: 'Flag',\n      Description: '1000 Genomes membership' },\n\n    // specifically for structural variants\n    IMPRECISE: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Imprecise structural variation' },\n\n    NOVEL: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Indicates a novel structural variation' },\n\n    // For precise variants, END is POS + length of REF allele - 1,\n    // and the for imprecise variants the corresponding best estimate.\n    SVTYPE: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Type of structural variant' },\n\n    // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n    // be derived from the REF/ALT fields but is useful for filtering.\n    SVLEN: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Difference in length between REF and ALT alleles' },\n\n    // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n    // have positive values, shorter ALT alleles (e.g. deletions)\n    // have negative values.\n    CIPOS: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around POS for imprecise variants' },\n\n    CIEND: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around END for imprecise variants' },\n\n    HOMLEN: {\n      Type: 'Integer',\n      Description:\n      'Length of base pair identical micro-homology at event breakpoints' },\n\n    HOMSEQ: {\n      Type: 'String',\n      Description:\n      'Sequence of base pair identical micro-homology at event breakpoints' },\n\n    BKPTID: {\n      Type: 'String',\n      Description: 'ID of the assembled alternate allele in the assembly file' },\n\n    // For precise variants, the consensus sequence the alternate allele assembly\n    // is derivable from the REF and ALT fields. However, the alternate allele\n    // assembly file may contain additional information about the characteristics\n    // of the alt allele contigs.\n    MEINFO: {\n      Number: 4,\n      Type: 'String',\n      Description: 'Mobile element info of the form NAME,START,END,POLARITY' },\n\n    METRANS: {\n      Number: 4,\n      Type: 'String',\n      Description:\n      'Mobile element transduction info of the form CHR,START,END,POLARITY' },\n\n    DGVID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in Database of Genomic Variation' },\n\n    DBVARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBVAR' },\n\n    DBRIPID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBRIP' },\n\n    MATEID: {\n      Number: null,\n      Type: 'String',\n      Description: 'ID of mate breakends' },\n\n    PARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of partner breakend' },\n\n    EVENT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of event associated to breakend' },\n\n    CILEN: {\n      Number: 2,\n      Type: 'Integer',\n      Description:\n      'Confidence interval around the inserted material between breakend' },\n\n    DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n    CN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Copy number of segment containing breakend' },\n\n    CNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Copy number of adjacency' },\n\n    CICN: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the segment' },\n\n    CICNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the adjacency' } },\n\n\n\n  // FORMAT fields\n  GenotypeFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Read depth' },\n\n    EC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description: 'Expected alternate allele counts' },\n\n    FT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Filter indicating if this genotype was \"called\"' },\n\n    GL: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype likelihoods' },\n\n    GP: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype posterior probabilities' },\n\n    GQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Conditional genotype quality' },\n\n    GT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Genotype' },\n\n    HQ: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Haplotype quality' },\n\n    MQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'RMS mapping quality' },\n\n    PL: {\n      Number: 'G',\n      Type: 'Integer',\n      Description:\n      'Phred-scaled genotype likelihoods rounded to the closest integer' },\n\n    PQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phasing quality' },\n\n    PS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phase set' } },\n\n\n\n  // ALT fields\n  AltTypes: {\n    DEL: {\n      Description: 'Deletion relative to the reference' },\n\n    INS: {\n      Description: 'Insertion of novel sequence relative to the reference' },\n\n    DUP: {\n      Description: 'Region of elevated copy number relative to the reference' },\n\n    INV: {\n      Description: 'Inversion of reference sequence' },\n\n    CNV: {\n      Description:\n      'Copy number variable region (may be both deletion and duplication)' },\n\n    'DUP:TANDEM': {\n      Description: 'Tandem duplication' },\n\n    'DEL:ME': {\n      Description: 'Deletion of mobile element relative to the reference' },\n\n    'INS:ME': {\n      Description: 'Insertion of a mobile element relative to the reference' },\n\n    NON_REF: {\n      Description:\n      'Represents any possible alternative allele at this location' },\n\n    '*': {\n      Description:\n      'Represents any possible alternative allele at this location' } },\n\n\n\n  // FILTER fields\n  FilterTypes: {\n    PASS: {\n      Description: 'Passed all filters' } } };exports.default = _default;","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  FileLocation,\n  NoAssemblyRegion,\n  Region,\n} from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport VcfParser from '@gmod/vcf'\nimport { Observer } from 'rxjs'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport VcfFeature from './VcfFeature'\n\nexport default class extends BaseFeatureDataAdapter {\n  protected configured?: Promise<{\n    vcf: TabixIndexedFile\n    parser: typeof VcfParser\n    filehandle: GenericFilehandle\n  }>\n\n  protected async configure() {\n    if (!this.configured) {\n      const vcfGzLocation = readConfObject(this.config, 'vcfGzLocation')\n      const location = readConfObject(this.config, ['index', 'location'])\n      const indexType = readConfObject(this.config, ['index', 'indexType'])\n\n      const filehandle = openLocation(vcfGzLocation as FileLocation)\n      const isCSI = indexType === 'CSI'\n      const vcf = new TabixIndexedFile({\n        filehandle,\n        csiFilehandle: isCSI ? openLocation(location) : undefined,\n        tbiFilehandle: !isCSI ? openLocation(location) : undefined,\n        chunkCacheSize: 50 * 2 ** 20,\n        chunkSizeLimit: 1000000000,\n      })\n\n      this.configured = vcf\n        .getHeader()\n        .then(header => ({\n          filehandle,\n          vcf,\n          parser: new VcfParser({ header }),\n        }))\n        .catch(e => {\n          this.configured = undefined\n          throw e\n        })\n    }\n    return this.configured\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure()\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    const { vcf } = await this.configure()\n    return vcf.getHeader()\n  }\n\n  async getMetadata() {\n    const { parser } = await this.configure()\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { vcf, parser } = await this.configure()\n      await vcf.getLines(refName, start, end, {\n        lineCallback: (line: string, fileOffset: number) => {\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(line),\n              parser,\n              id: `${this.id}-vcf-${fileOffset}`,\n            }),\n          )\n        },\n        ...opts,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  /**\n   * Checks if the data source has data for the given reference sequence,\n   * and then gets the features in the region if it does\n   *\n   * Currently this just calls getFeatureInRegion for each region. Adapters that\n   * are frequently called on multiple regions simultaneously may want to\n   * implement a more efficient custom version of this method.\n   *\n   * Also includes a bit of extra logging to warn when fetching a large portion\n   * of a VCF\n   * @param regions - Regions\n   * @param opts - Feature adapter options\n   * @returns Observable of Feature objects in the regions\n   */\n  public getFeaturesInMultipleRegions(\n    regions: Region[],\n    opts: BaseOptions = {},\n  ) {\n    // TODO: restore commented version below once TSDX supports Rollup v2\n    // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45\n    const superGetFeaturesInMultipleRegions = super.getFeaturesInMultipleRegions\n    return ObservableCreate<Feature>(async (observer: Observer<Feature>) => {\n      const bytes = await this.bytesForRegions(regions)\n      const { filehandle } = await this.configure()\n      const stat = await filehandle.stat()\n      let pct = Math.round((bytes / stat.size) * 100)\n      if (pct > 100) {\n        // this is just a bad estimate, make 100% if it goes over\n        pct = 100\n      }\n      if (pct > 60) {\n        console.warn(\n          `getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`,\n        )\n      }\n      superGetFeaturesInMultipleRegions\n        .call(this, regions, opts)\n        .subscribe(observer)\n      // super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)\n    })\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[]) {\n    const { vcf } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region =>\n        // @ts-ignore\n        vcf.index.blocksForRange(region.refName, region.start, region.end),\n      ),\n    )\n    interface ByteRange {\n      start: number\n      end: number\n    }\n    interface VirtualOffset {\n      blockPosition: number\n    }\n    interface Block {\n      minv: VirtualOffset\n      maxv: VirtualOffset\n    }\n    const byteRanges: ByteRange[] = []\n    blockResults.forEach((blocks: Block[]) => {\n      blocks.forEach(block => {\n        const start = block.minv.blockPosition\n        const end = block.maxv.blockPosition + 64000\n        if (\n          !byteRanges.find(range => {\n            if (range.start <= end && range.end >= start) {\n              range.start = Math.min(range.start, start)\n              range.end = Math.max(range.end, end)\n              return true\n            }\n            return false\n          })\n        ) {\n          byteRanges.push({ start, end })\n        }\n      })\n    })\n\n    return byteRanges.reduce((a, b) => a + b.end - b.start + 1, 0)\n  }\n\n  public freeResources(/* { region } */): void {}\n}\n"],"sourceRoot":""}