{"version":3,"sources":["../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/BamAdapter.ts","../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts"],"names":["BamSlightlyLazyFeature","record","adapter","ref","this","get","flags","isReverseComplemented","readGroupId","isPaired","getPairOrientation","undefined","_next_refid","_refID","refIdToName","_next_pos","getReadBases","md","seq","generateMD","qualRaw","properties","Object","getOwnPropertyNames","prototype","Set","filter","prop","startsWith","map","methodName","replace","concat","_tags","id","field","seq_id","tags","fromEntries","t","elt","uniqueId","opts","cigarAttributeName","mismatches","cigarOps","cigarString","parseCigar","cigarToMismatches","mdAttributeName","mdString","mdToMismatches","seen","m","key","type","start","length","s","cigar","match","BamAdapter","samHeader","setupP","configured","bamLocation","readConfObject","config","location","indexType","chunkSizeLimit","fetchSizeLimit","bam","BamFile","bamFilehandle","openLocation","csiFilehandle","baiFilehandle","adapterConfig","getSubAdapter","then","dataAdapter","sequenceAdapter","Promise","resolve","configure","getHeaderText","statusCallback","a","getHeader","idToName","nameToId","l","tag","forEach","sqLine","refId","data","item","refName","value","catch","e","setup","end","refSeqStore","features","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","trimmed","sort","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","push","substr","sequence","join","Error","toLocaleString","region","originalRefName","signal","ObservableCreate","observer","getRecordsForRange","records","checkAbortSignal","seqFetch","next","complete","BaseFeatureDataAdapter","HtsgetBamAdapter","htsgetBase","htsgetTrackId","HtsgetFile","baseUrl","trackId"],"mappings":"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","file":"static/js/39.990ecf6b.chunk.js","sourcesContent":["/* eslint-disable @typescript-eslint/camelcase,no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { BamRecord } from '@gmod/bam'\nimport {\n  parseCigar,\n  generateMD,\n  cigarToMismatches,\n  mdToMismatches,\n  Mismatch,\n} from './MismatchParser'\n\nimport BamAdapter from './BamAdapter'\n\nexport default class BamSlightlyLazyFeature implements Feature {\n  private record: BamRecord\n\n  private adapter: BamAdapter\n\n  private ref?: string\n\n  constructor(record: BamRecord, adapter: BamAdapter, ref?: string) {\n    this.record = record\n    this.adapter = adapter\n    this.ref = ref\n  }\n\n  _get_name() {\n    return this.record.get('name')\n  }\n\n  _get_type(): string {\n    return 'match'\n  }\n\n  _get_score(): number {\n    return this.record.get('mq')\n  }\n\n  _get_flags(): string {\n    // @ts-ignore\n    return this.record.flags\n  }\n\n  _get_strand(): number {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _get_read_group_id(): number {\n    // @ts-ignore\n    return this.record.readGroupId\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_next_seq_id() {\n    return this.record._next_refid()\n  }\n\n  _get_seq_id() {\n    // @ts-ignore\n    return this.record._refID\n  }\n\n  _get_next_refName(): string | undefined {\n    return this.adapter.refIdToName(this.record._next_refid())\n  }\n\n  _get_next_segment_position(): string | undefined {\n    return this.record.isPaired()\n      ? `${this.adapter.refIdToName(this.record._next_refid())}:${\n          this.record._next_pos() + 1\n        }`\n      : undefined\n  }\n\n  _get_seq(): string {\n    return this.record.getReadBases()\n  }\n\n  _get_MD(): string | undefined {\n    const md = this.record.get('MD')\n    const seq = this.get('seq')\n    if (!md && seq && this.ref) {\n      return generateMD(this.ref, this.record.getReadBases(), this.get('CIGAR'))\n    }\n    return md\n  }\n\n  qualRaw(): Buffer | undefined {\n    return this.record.qualRaw()\n  }\n\n  set(): void {}\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      BamSlightlyLazyFeature.prototype,\n    )\n\n    return [\n      ...new Set(\n        properties\n          .filter(\n            prop =>\n              prop.startsWith('_get_') &&\n              prop !== '_get_mismatches' &&\n              prop !== '_get_skips_and_dels' &&\n              prop !== '_get_cram_read_features' &&\n              prop !== '_get_tags' &&\n              prop !== '_get_next_seq_id' &&\n              prop !== '_get_seq_id',\n          )\n          .map(methodName => methodName.replace('_get_', ''))\n          .concat(this.record._tags()),\n      ),\n    ]\n  }\n\n  id(): string {\n    return `${this.adapter.id}-${this.record.id()}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(field: string): any {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return this.record.get(field)\n  }\n\n  _get_refName(): string | undefined {\n    return this.adapter.refIdToName(this.record.seq_id())\n  }\n\n  parent(): undefined {\n    return undefined\n  }\n\n  children(): undefined {\n    return undefined\n  }\n\n  pairedFeature(): boolean {\n    return false\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    const tags = Object.fromEntries(\n      this.tags()\n        .map(t => {\n          return [t, this.get(t)]\n        })\n        .filter(elt => elt[1] !== undefined),\n    )\n\n    return {\n      ...tags,\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_skips_and_dels(\n    opts: {\n      cigarAttributeName: string\n    } = {\n      cigarAttributeName: 'CIGAR',\n    },\n  ): Mismatch[] {\n    const { cigarAttributeName } = opts\n    let mismatches: Mismatch[] = []\n    let cigarOps: string[] = []\n\n    // parse the CIGAR tag if it has one\n    const cigarString = this.get(cigarAttributeName)\n    if (cigarString) {\n      cigarOps = parseCigar(cigarString)\n      mismatches = mismatches.concat(\n        cigarToMismatches(cigarOps, this.get('seq'), this.qualRaw()),\n      )\n    }\n    return mismatches\n  }\n\n  _get_mismatches({\n    cigarAttributeName = 'CIGAR',\n    mdAttributeName = 'MD',\n  }: {\n    cigarAttributeName?: string\n    mdAttributeName?: string\n  } = {}): Mismatch[] {\n    let mismatches: Mismatch[] = []\n    let cigarOps: string[] = []\n\n    // parse the CIGAR tag if it has one\n    const cigarString = this.get(cigarAttributeName)\n    if (cigarString) {\n      cigarOps = parseCigar(cigarString)\n      mismatches = mismatches.concat(\n        cigarToMismatches(cigarOps, this.get('seq'), this.qualRaw()),\n      )\n    }\n\n    // now let's look for CRAM or MD mismatches\n    const mdString = this.get(mdAttributeName)\n    if (mdString) {\n      mismatches = mismatches.concat(\n        mdToMismatches(\n          mdString,\n          cigarOps,\n          mismatches,\n          this.get('seq'),\n          this.qualRaw(),\n        ),\n      )\n    }\n\n    // uniqify the mismatches\n    const seen: { [index: string]: boolean } = {}\n    return mismatches.filter(m => {\n      const key = `${m.type},${m.start},${m.length}`\n      const s = seen[key]\n      seen[key] = true\n      return !s\n    })\n  }\n\n  _get_clipPos() {\n    const cigar = this.get('CIGAR') || ''\n    return this.get('strand') === -1\n      ? +(cigar.match(/(\\d+)[SH]$/) || [])[1] || 0\n      : +(cigar.match(/^(\\d+)([SH])/) || [])[1] || 0\n  }\n}\n","import { BamFile } from '@gmod/bam'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { checkAbortSignal } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { toArray } from 'rxjs/operators'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n\n  protected configured?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom\n  // configure method allows derived classes to override this behavior\n  protected async configure() {\n    if (!this.configured) {\n      const bamLocation = readConfObject(this.config, 'bamLocation')\n      const location = readConfObject(this.config, ['index', 'location'])\n      const indexType = readConfObject(this.config, ['index', 'indexType'])\n      const chunkSizeLimit = readConfObject(this.config, 'chunkSizeLimit')\n      const fetchSizeLimit = readConfObject(this.config, 'fetchSizeLimit')\n      const bam = new BamFile({\n        bamFilehandle: openLocation(bamLocation),\n        csiFilehandle: indexType === 'CSI' ? openLocation(location) : undefined,\n        baiFilehandle: indexType !== 'CSI' ? openLocation(location) : undefined,\n        chunkSizeLimit,\n        fetchSizeLimit,\n      })\n\n      const adapterConfig = readConfObject(this.config, 'sequenceAdapter')\n      if (adapterConfig && this.getSubAdapter) {\n        this.configured = this.getSubAdapter(adapterConfig).then(\n          ({ dataAdapter }) => ({\n            bam,\n            sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n          }),\n        )\n      } else {\n        this.configured = Promise.resolve({ bam })\n      }\n    }\n    return this.configured\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText(opts)\n  }\n\n  private async setup(opts?: BaseOptions) {\n    // note that derived classes may not provide a BAM directly so this is\n    // conditional\n    const { statusCallback = () => {} } = opts || {}\n    if (!this.setupP) {\n      this.setupP = this.configure()\n        .then(async ({ bam }) => {\n          statusCallback('Downloading index')\n          const samHeader = await bam.getHeader(opts)\n\n          // use the @SQ lines in the header to figure out the\n          // mapping between ref ref ID numbers and names\n          const idToName: string[] = []\n          const nameToId: Record<string, number> = {}\n          samHeader\n            .filter(l => l.tag === 'SQ')\n            .forEach((sqLine, refId) => {\n              sqLine.data.forEach(item => {\n                if (item.tag === 'SN') {\n                  // this is the ref name\n                  const refName = item.value\n                  nameToId[refName] = refId\n                  idToName[refId] = refName\n                }\n              })\n            })\n          statusCallback('')\n          this.samHeader = { idToName, nameToId }\n          return this.samHeader\n        })\n        .catch(e => {\n          this.setupP = undefined\n          throw e\n        })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) return undefined\n    if (!refName) return undefined\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await features.pipe(toArray()).toPromise()\n\n    const trimmed: string[] = []\n    seqChunks\n      .sort((a: Feature, b: Feature) => a.get('start') - b.get('start'))\n      .forEach((chunk: Feature) => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        trimmed.push(chunkSeq.substr(trimStart, trimLength))\n      })\n\n    const sequence = trimmed.join('')\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions,\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { signal, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      statusCallback('Downloading alignments')\n      const records = await bam.getRecordsForRange(refName, start, end, opts)\n\n      checkAbortSignal(signal)\n\n      for (const record of records) {\n        let ref: string | undefined\n        if (!record.get('md')) {\n          // eslint-disable-next-line no-await-in-loop\n          ref = await this.seqFetch(\n            originalRefName || refName,\n            record.get('start'),\n            record.get('end'),\n          )\n        }\n        observer.next(new BamSlightlyLazyFeature(record, this, ref))\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number): string | undefined {\n    return this.samHeader?.idToName[refId]\n  }\n}\n","import { HtsgetFile } from '@gmod/bam'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport BamAdapter from '../BamAdapter/BamAdapter'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected async configure() {\n    if (!this.configured) {\n      const htsgetBase = readConfObject(this.config, 'htsgetBase')\n      const htsgetTrackId = readConfObject(this.config, 'htsgetTrackId')\n      const bam = new HtsgetFile({\n        baseUrl: htsgetBase,\n        trackId: htsgetTrackId,\n      })\n\n      const adapterConfig = readConfObject(this.config, 'sequenceAdapter')\n      if (adapterConfig && this.getSubAdapter) {\n        this.configured = this.getSubAdapter(adapterConfig).then(\n          ({ dataAdapter }) => {\n            return {\n              bam,\n              sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n            }\n          },\n        )\n      }\n      this.configured = Promise.resolve({ bam })\n    }\n    return this.configured\n  }\n}\n"],"sourceRoot":""}