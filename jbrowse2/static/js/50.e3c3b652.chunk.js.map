{"version":3,"sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"names":["CramSlightlyLazyFeature","record","store","_store","this","readName","alignmentStart","lengthOnRef","readFeatures","mappingQuality","flags","isReverseComplemented","rg","samHeader","readGroups","readGroupId","undefined","qualityScores","join","refIdToName","sequenceId","_get_seq_id","mate","isPaired","getPairOrientation","templateLength","templateSize","RG","_read_group_id","tags","getReadBases","seq","cigar","op","oplen","ref","_refRegion","refStart","start","last_pos","sublen","forEach","code","refPos","sub","data","substring","ret","split","added","String","fromCharCode","length","readLength","Object","getOwnPropertyNames","prototype","filter","prop","startsWith","map","methodName","replace","id","uniqueId","field","mismatches","get","type","cliplen","t","val","name","qual","qualRaw","args","pos","push","base","altbase","len","_get_mismatches","CramAdapter","cram","setupP","sequenceAdapter","seqIdToRefName","seqIdToOriginalRefName","cramLocation","readConfObject","config","craiLocation","Error","IndexedCramFile","cramFilehandle","openLocation","index","CraiIndex","filehandle","seqFetch","bind","checkSequenceMD5","fetchSizeLimit","sequenceAdapterType","getSubAdapter","dataAdapter","BaseFeatureDataAdapter","opts","configure","getHeaderText","seqId","end","refSeqStore","refName","refIdToOriginalName","features","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","trimmed","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","substr","sequence","toLocaleString","statusCallback","then","getSamHeader","signal","idToName","nameToId","l","tag","sqLine","refId","item","value","rgLine","find","catch","e","setup","getRefNames","indexOf","region","originalRefName","ObservableCreate","observer","refNameToId","getRecordsForRange","records","checkAbortSignal","next","cramRecordToFeature","complete"],"mappings":"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","file":"static/js/50.e3c3b652.chunk.js","sourcesContent":["/* eslint-disable @typescript-eslint/camelcase,no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\n\nimport CramAdapter from './CramAdapter'\n\nexport interface Mismatch {\n  qual?: number\n  start: number\n  length: number\n  type: string\n  base: string\n  altbase?: string\n  seq?: string\n  cliplen?: number\n}\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private record: any\n\n  private _store: CramAdapter\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(record: any, store: CramAdapter) {\n    this.record = record\n    this._store = store\n  }\n\n  _get_name() {\n    return this.record.readName\n  }\n\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n\n  _get_end() {\n    return this.record.alignmentStart + this.record.lengthOnRef - 1\n  }\n\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n\n  _get_type() {\n    return 'match'\n  }\n\n  _get_score() {\n    return this.record.mappingQuality\n  }\n\n  _get_flags() {\n    return this.record.flags\n  }\n\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _read_group_id() {\n    const rg = this._store.samHeader.readGroups\n    return rg ? rg[this.record.readGroupId] : undefined\n  }\n\n  _get_qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  qualRaw() {\n    return this.record.qualityScores\n  }\n\n  _get_seq_id() {\n    return this._store.refIdToName(this.record.sequenceId)\n  }\n\n  _get_refName() {\n    return this._get_seq_id()\n  }\n\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  _get_next_seq_id() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.mate ? this.record.mate.alignmentStart : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  _get_tags() {\n    const RG = this._read_group_id()\n    const { tags } = this.record\n    // avoids a tag copy if no RG, but just copy if there is one\n    return RG !== undefined ? { ...tags, RG } : tags\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  _get_CIGAR() {\n    let seq = ''\n    let cigar = ''\n    let op = 'M'\n    let oplen = 0\n\n    // not sure I should access these, but...\n    const ref = this.record._refRegion.seq\n    const refStart = this.record._refRegion.start\n    let last_pos = this.record.alignmentStart\n    let sublen = 0\n    if (typeof this.record.readFeatures !== 'undefined') {\n      // @ts-ignore\n      this.record.readFeatures.forEach(({ code, refPos, sub, data }) => {\n        sublen = refPos - last_pos\n        seq += ref.substring(last_pos - refStart, refPos - refStart)\n        last_pos = refPos\n\n        if (oplen && op !== 'M') {\n          cigar += oplen + op\n          oplen = 0\n        }\n        if (sublen) {\n          op = 'M'\n          oplen += sublen\n        }\n\n        if (code === 'b') {\n          // An array of bases stored verbatim\n          const ret = data.split(',')\n          const added = String.fromCharCode(...ret)\n          seq += added\n          last_pos += added.length\n          oplen += added.length\n        } else if (code === 'B') {\n          // Single base (+ qual score)\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'X') {\n          // Substitution\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'D' || code === 'N') {\n          // Deletion or Ref Skip\n          last_pos += data\n          if (oplen) cigar += oplen + op\n          cigar += data + code\n          oplen = 0\n        } else if (code === 'I' || code === 'S') {\n          // Insertion or soft-clip\n          seq += data\n          if (oplen) cigar += oplen + op\n          cigar += data.length + code\n          oplen = 0\n        } else if (code === 'i') {\n          // Single base insertion\n          seq += data\n          if (oplen) cigar += oplen + op\n          cigar += `${1}I`\n          oplen = 0\n        } else if (code === 'P') {\n          // Padding\n          if (oplen) cigar += oplen + op\n          cigar += `${data}P`\n        } else if (code === 'H') {\n          // Hard clip\n          if (oplen) cigar += oplen + op\n          cigar += `${data}H`\n          oplen = 0\n        } // else q or Q\n      })\n    } else {\n      sublen = this.record.readLength - seq.length\n    }\n    if (seq.length !== this.record.readLength) {\n      sublen = this.record.readLength - seq.length\n      seq += ref.substring(last_pos - refStart, last_pos - refStart + sublen)\n\n      if (oplen && op !== 'M') {\n        cigar += oplen + op\n        oplen = 0\n      }\n      op = 'M'\n      oplen += sublen\n    }\n    if (oplen) {\n      cigar += oplen + op\n    }\n    return cigar\n  }\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      CramSlightlyLazyFeature.prototype,\n    )\n    return properties\n      .filter(\n        prop =>\n          prop.startsWith('_get_') &&\n          prop !== '_get_mismatches' &&\n          prop !== '_get_skips_and_dels' &&\n          prop !== '_get_cram_read_features',\n      )\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string) {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) return this[methodName]()\n    return undefined\n  }\n\n  parent(): undefined | Feature {\n    return undefined\n  }\n\n  children(): undefined | Feature[] {\n    return undefined\n  }\n\n  set(): void {}\n\n  pairedFeature() {\n    return false\n  }\n\n  _get_clipPos() {\n    const mismatches = this.get('mismatches')\n    if (mismatches.length) {\n      const record =\n        this.get('strand') === -1\n          ? mismatches[mismatches.length - 1]\n          : mismatches[0]\n      const { type, cliplen } = record\n      if (type === 'softclip' || type === 'hardclip') {\n        return cliplen\n      }\n    }\n    return 0\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const tags: Record<string, any> = {}\n    this.tags().forEach((t: string) => {\n      const val = this.get(t)\n      if (val !== undefined) {\n        tags[t] = val\n      }\n    })\n\n    return {\n      ...tags,\n      name: this.get('name'),\n      type: this.get('type'),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches(): Mismatch[] {\n    const readFeatures = this.get('cram_read_features')\n    const qual = this.qualRaw()\n    if (!readFeatures) return []\n    const start = this.get('start')\n    const mismatches: Mismatch[] = []\n    readFeatures.forEach(\n      (args: {\n        code: string\n        refPos: number\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: any\n        pos: number\n        sub: string\n        ref: string\n      }) => {\n        const { code, pos, data, sub, ref } = args\n        const refPos = args.refPos - 1 - start\n        if (code === 'X') {\n          // substitution\n          mismatches.push({\n            start: refPos,\n            length: 1,\n            base: sub,\n            qual: qual?.[pos],\n            altbase: ref,\n            type: 'mismatch',\n          })\n        } else if (code === 'I') {\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: `${data.length}`,\n            length: 0,\n          })\n        } else if (code === 'N') {\n          // reference skip\n          mismatches.push({\n            type: 'skip',\n            length: data,\n            start: refPos,\n            base: 'N',\n          })\n        } else if (code === 'S') {\n          // soft clip\n          const len = data.length\n          mismatches.push({\n            start: refPos,\n            type: 'softclip',\n            base: `S${len}`,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'P') {\n          // padding\n        } else if (code === 'H') {\n          // hard clip\n          const len = data\n          mismatches.push({\n            start: refPos,\n            type: 'hardclip',\n            base: `H${len}`,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'D') {\n          // deletion\n          mismatches.push({\n            type: 'deletion',\n            length: data,\n            start: refPos,\n            base: '*',\n          })\n        } else if (code === 'b') {\n          // stretch of bases\n        } else if (code === 'q') {\n          // stretch of qual scores\n        } else if (code === 'B') {\n          // a pair of [base, qual]\n        } else if (code === 'i') {\n          // single-base insertion\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: data,\n            length: 1,\n          })\n        } else if (code === 'Q') {\n          // single quality value\n        }\n      },\n    )\n    return mismatches\n  }\n\n  _get_skips_and_dels(): Mismatch[] {\n    return this._get_mismatches()\n  }\n}\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { checkAbortSignal } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { toArray } from 'rxjs/operators'\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\n\ninterface HeaderLine {\n  tag: string\n  value: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  data: HeaderLine[]\n}\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: number[]\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private cram: any\n\n  private setupP?: Promise<Header>\n\n  private sequenceAdapter?: BaseFeatureDataAdapter\n\n  public samHeader: Header = {}\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configure() {\n    const cramLocation = readConfObject(this.config, 'cramLocation')\n    const craiLocation = readConfObject(this.config, 'craiLocation')\n    if (!cramLocation) {\n      throw new Error('missing cramLocation argument')\n    }\n    if (!craiLocation) {\n      throw new Error('missing craiLocation argument')\n    }\n    this.cram = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation),\n      index: new CraiIndex({ filehandle: openLocation(craiLocation) }),\n      seqFetch: this.seqFetch.bind(this),\n      checkSequenceMD5: false,\n      fetchSizeLimit: this.config.fetchSizeLimit || 600000000,\n    })\n    // instantiate the sequence adapter\n    const sequenceAdapterType = readConfObject(this.config, [\n      'sequenceAdapter',\n      'type',\n    ])\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const { dataAdapter } = await this.getSubAdapter(\n      readConfObject(this.config, 'sequenceAdapter'),\n    )\n    if (dataAdapter instanceof BaseFeatureDataAdapter) {\n      this.sequenceAdapter = dataAdapter\n    } else {\n      throw new Error(\n        `CRAM feature adapters cannot use sequence adapters of type '${sequenceAdapterType}'`,\n      )\n    }\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    await this.configure()\n    return this.cram.cram.getHeaderText(opts)\n  }\n\n  private async seqFetch(seqId: number, start: number, end: number) {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const refSeqStore = this.sequenceAdapter\n    if (!refSeqStore) return undefined\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) return undefined\n\n    const features = refSeqStore.getFeatures(\n      {\n        refName,\n        start,\n        end,\n        assemblyName: '',\n      },\n      {},\n    )\n\n    const seqChunks = await features.pipe(toArray()).toPromise()\n\n    const trimmed: string[] = []\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach((chunk: Feature) => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        trimmed.push(chunkSeq.substr(trimStart, trimLength))\n      })\n\n    const sequence = trimmed.join('')\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setup(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    if (!this.setupP) {\n      this.setupP = this.configure()\n        .then(async () => {\n          statusCallback('Downloading index')\n          const samHeader: HeaderLine[] = await this.cram.cram.getSamHeader(\n            opts?.signal,\n          )\n\n          // use the @SQ lines in the header to figure out the\n          // mapping between ref ID numbers and names\n          const idToName: string[] = []\n          const nameToId: Record<string, number> = {}\n          samHeader\n            .filter(l => l.tag === 'SQ')\n            .forEach((sqLine, refId) => {\n              sqLine.data.forEach(item => {\n                if (item.tag === 'SN') {\n                  // this is the ref name\n                  const refName = item.value\n                  nameToId[refName] = refId\n                  idToName[refId] = refName\n                }\n              })\n            })\n\n          const readGroups = samHeader\n            .filter(l => l.tag === 'RG')\n            .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n          if (idToName.length) {\n            this.samHeader = { idToName, nameToId, readGroups }\n          }\n          statusCallback('')\n          return this.samHeader\n        })\n        .catch(e => {\n          this.setupP = undefined\n          throw e\n        })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    await this.setup(opts)\n    if (this.samHeader.idToName) {\n      return this.samHeader.idToName\n    }\n    if (this.sequenceAdapter) {\n      return this.sequenceAdapter.getRefNames()\n    }\n    throw new Error('unable to get refnames')\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    if (this.samHeader.idToName) {\n      return this.samHeader.idToName[refId]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName[refId]\n    }\n    return undefined\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions,\n  ) {\n    const { signal, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      await this.setup(opts)\n      if (this.sequenceAdapter && !this.seqIdToRefName) {\n        this.seqIdToRefName = await this.sequenceAdapter.getRefNames(opts)\n      }\n      const refId = this.refNameToId(refName)\n      if (refId !== undefined) {\n        if (originalRefName) {\n          this.seqIdToOriginalRefName[refId] = originalRefName\n        }\n        statusCallback('Downloading alignments')\n        const records = await this.cram.getRecordsForRange(\n          refId,\n          start,\n          end,\n          opts,\n        )\n        checkAbortSignal(signal)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        records.forEach((record: any) => {\n          observer.next(this.cramRecordToFeature(record))\n        })\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  cramRecordToFeature(record: any): Feature {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n}\n"],"sourceRoot":""}